From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 17 Apr 2023 19:47:57 -0700
Subject: [PATCH] Prevent block updates in non-loaded or non-owned chunks

This is to prevent block physics from tripping thread checks by
far exceeding the bounds of the current region. While this does
add explicit block update suppression techniques, it's better
than the server crashing.

diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 5849ef10c5b2d1d7d2650839d629c8a87689d322..40d8a43b6b4a3fdb623a796dcd219cabc8632d7c 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -2020,7 +2020,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public void updateNeighbourForOutputSignal(BlockPos pos, Block block) {
         for (Direction direction : Direction.Plane.HORIZONTAL) {
             BlockPos blockPos = pos.relative(direction);
-            if (this.hasChunkAt(blockPos)) {
+            if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, blockPos, 16) && this.hasChunkAt(blockPos)) { // Folia - block updates in unloaded chunks
                 BlockState blockState = this.getBlockState(blockPos);
                 if (blockState.is(Blocks.COMPARATOR)) {
                     this.neighborChanged(blockState, blockPos, block, null, false);
diff --git a/net/minecraft/world/level/block/DetectorRailBlock.java b/net/minecraft/world/level/block/DetectorRailBlock.java
index e7a4fe5bcb750262d7beab8d57bec59038fca241..62b79ef88083d2672c49c1d273a6f6e523e7ce43 100644
--- a/net/minecraft/world/level/block/DetectorRailBlock.java
+++ b/net/minecraft/world/level/block/DetectorRailBlock.java
@@ -128,8 +128,8 @@ public class DetectorRailBlock extends BaseRailBlock {
         RailState railState = new RailState(level, pos, state);
 
         for (BlockPos blockPos : railState.getConnections()) {
-            BlockState blockState = level.getBlockState(blockPos);
-            level.neighborChanged(blockState, blockPos, blockState.getBlock(), null, false);
+            BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, blockPos, 16) ? null : level.getBlockState(blockPos); // Folia - block updates in unloaded chunks
+            if (blockState != null) level.neighborChanged(blockState, blockPos, blockState.getBlock(), null, false); // Folia - block updates in unloaded chunks
         }
     }
 
diff --git a/net/minecraft/world/level/block/PoweredRailBlock.java b/net/minecraft/world/level/block/PoweredRailBlock.java
index 1d1a2e183624ebae22b966ab59a174e941f139c0..44a70268fef73e2bcd5ac7d11e58645e915a7bb9 100644
--- a/net/minecraft/world/level/block/PoweredRailBlock.java
+++ b/net/minecraft/world/level/block/PoweredRailBlock.java
@@ -102,8 +102,8 @@ public class PoweredRailBlock extends BaseRailBlock {
     }
 
     protected boolean isSameRailWithPower(Level level, BlockPos state, boolean searchForward, int recursionCount, RailShape shape) {
-        BlockState blockState = level.getBlockState(state);
-        if (!blockState.is(this)) {
+        BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, state, 16) ? null : level.getBlockState(state); // Folia - block updates in unloaded chunks
+        if (blockState == null || !blockState.is(this)) { // Folia - block updates in unloaded chunks
             return false;
         } else {
             RailShape railShape = blockState.getValue(SHAPE);
diff --git a/net/minecraft/world/level/block/RedStoneWireBlock.java b/net/minecraft/world/level/block/RedStoneWireBlock.java
index 56df64e48482b4caa7dc5dc843a18e6bc1e3bfa1..ba253a9af6141d8ea99c064e3cc0c6486c221098 100644
--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -210,8 +210,9 @@ public class RedStoneWireBlock extends Block {
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
         for (Direction direction : Direction.Plane.HORIZONTAL) {
+            BlockState currState; mutableBlockPos.setWithOffset(pos, direction); // Folia - block updates in unloaded chunks
             RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
-            if (redstoneSide != RedstoneSide.NONE && !level.getBlockState(mutableBlockPos.setWithOffset(pos, direction)).is(this)) {
+            if (redstoneSide != RedstoneSide.NONE && (currState = (level instanceof net.minecraft.server.level.ServerLevel serverLevel && !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel, pos, 16) ? null : level.getBlockStateIfLoaded(mutableBlockPos.setWithOffset(pos, direction)))) != null && !currState.is(this)) { // Folia - block updates in unloaded chunks
                 mutableBlockPos.move(Direction.DOWN);
                 BlockState blockState = level.getBlockState(mutableBlockPos);
                 if (blockState.is(this)) {
diff --git a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 70b4c63b5ff80f7d26761f016ecccac760328297..4d46aec741ee8ac5d813ecd698950df2d13b962c 100644
--- a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -134,7 +134,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         public boolean runNext(Level level) {
             Direction direction = NeighborUpdater.UPDATE_ORDER[this.idx++];
             BlockPos blockPos = this.sourcePos.relative(direction);
-            BlockState blockState = level.getBlockState(blockPos);
+            BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, blockPos, 16) ? null : level.getBlockState(blockPos); // Folia - block updates in unloaded chunks
+            if (blockState != null) { // Folia - block updates in unloaded chunks
             Orientation orientation = null;
             if (level.enabledFeatures().contains(FeatureFlags.REDSTONE_EXPERIMENTS)) {
                 if (this.orientation == null) {
@@ -147,6 +148,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             }
 
             NeighborUpdater.executeUpdate(level, blockState, blockPos, this.sourceBlock, orientation, false, this.sourcePos); // Paper - Add source block to BlockPhysicsEvent
+            } // Folia - block updates in unloaded chunks
             if (this.idx < NeighborUpdater.UPDATE_ORDER.length && NeighborUpdater.UPDATE_ORDER[this.idx] == this.skipDirection) {
                 this.idx++;
             }
@@ -175,7 +177,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         implements CollectingNeighborUpdater.NeighborUpdates {
         @Override
         public boolean runNext(Level level) {
+            if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, this.pos, 16) && level.getChunkIfLoaded(this.pos) != null) { // Folia - block updates in unloaded chunks
             NeighborUpdater.executeShapeUpdate(level, this.direction, this.pos, this.neighborPos, this.neighborState, this.updateFlags, this.updateLimit);
+            } // Folia - block updates in unloaded chunks
             return false;
         }
 
@@ -188,8 +192,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     record SimpleNeighborUpdate(BlockPos pos, Block block, @Nullable Orientation orientation) implements CollectingNeighborUpdater.NeighborUpdates {
         @Override
         public boolean runNext(Level level) {
-            BlockState blockState = level.getBlockState(this.pos);
-            NeighborUpdater.executeUpdate(level, blockState, this.pos, this.block, this.orientation, false);
+            BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, this.pos, 16) ? null : level.getBlockStateIfLoaded(this.pos); // Folia - block updates in unloaded chunks
+            if (blockState != null) NeighborUpdater.executeUpdate(level, blockState, this.pos, this.block, this.orientation, false);
             return false;
         }
 
