From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 20 Apr 1997 05:37:42 -0800
Subject: [PATCH] Region Threading Base


diff --git a/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java b/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
index 1b8193587814225c2ef2c5d9e667436eb50ff6c5..0027a3896c0cfce2f46eca8a0a77a90223723dc7 100644
--- a/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
+++ b/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
@@ -244,7 +244,7 @@ public final class NearbyPlayers {
                 created.addPlayer(parameter, type);
                 type.addTo(parameter, NearbyPlayers.this.world, chunkX, chunkZ);
 
-                ((ChunkSystemLevel)NearbyPlayers.this.world).moonrise$requestChunkData(chunkKey).nearbyPlayers = created;
+                //((ChunkSystemLevel)NearbyPlayers.this.world).moonrise$requestChunkData(chunkKey).nearbyPlayers = created; // Folia - region threading
             }
         }
 
@@ -263,10 +263,7 @@ public final class NearbyPlayers {
 
             if (chunk.isEmpty()) {
                 NearbyPlayers.this.byChunk.remove(chunkKey);
-                final ChunkData chunkData = ((ChunkSystemLevel)NearbyPlayers.this.world).moonrise$releaseChunkData(chunkKey);
-                if (chunkData != null) {
-                    chunkData.nearbyPlayers = null;
-                }
+                // Folia - region threading
             }
         }
     }
diff --git a/ca/spottedleaf/moonrise/paper/PaperHooks.java b/ca/spottedleaf/moonrise/paper/PaperHooks.java
index 0b96f4790f7837cebca874e23c4dae7cc799c1ba..3152b791354327867629b42cd9453f022a27b246 100644
--- a/ca/spottedleaf/moonrise/paper/PaperHooks.java
+++ b/ca/spottedleaf/moonrise/paper/PaperHooks.java
@@ -108,7 +108,7 @@ public final class PaperHooks extends BaseChunkSystemHooks implements PlatformHo
         }
 
         for (final EnderDragonPart part : parts) {
-            if (part != entity && part.getBoundingBox().intersects(boundingBox) && (predicate == null || predicate.test(part))) {
+            if (part != entity && part.getBoundingBox().intersects(boundingBox) && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(part) && (predicate == null || predicate.test(part))) { // Folia - region threading
                 into.add(part);
             }
         }
@@ -130,7 +130,7 @@ public final class PaperHooks extends BaseChunkSystemHooks implements PlatformHo
                 continue;
             }
             final T casted = (T)entityTypeTest.tryCast(part);
-            if (casted != null && (predicate == null || predicate.test(casted))) {
+            if (casted != null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(part) && (predicate == null || predicate.test(casted))) { // Folia - region threading
                 into.add(casted);
                 if (into.size() >= maxCount) {
                     break;
diff --git a/ca/spottedleaf/moonrise/paper/util/BaseChunkSystemHooks.java b/ca/spottedleaf/moonrise/paper/util/BaseChunkSystemHooks.java
index 3e7b616cbd196f56393719e84c7118ab47308337..874ffbcc0263ded98462a9fd2529e9a877ab8900 100644
--- a/ca/spottedleaf/moonrise/paper/util/BaseChunkSystemHooks.java
+++ b/ca/spottedleaf/moonrise/paper/util/BaseChunkSystemHooks.java
@@ -75,12 +75,16 @@ public abstract class BaseChunkSystemHooks implements ca.spottedleaf.moonrise.co
 
     @Override
     public void onChunkHolderCreate(final ServerLevel level, final ChunkHolder holder) {
-
+        // Folia start - threaded regions
+        level.regioniser.addChunk(holder.getPos().x, holder.getPos().z);
+        // Folia end - threaded regions
     }
 
     @Override
     public void onChunkHolderDelete(final ServerLevel level, final ChunkHolder holder) {
-
+        // Folia start - threaded regions
+        level.regioniser.removeChunk(holder.getPos().x, holder.getPos().z);
+        // Folia end - threaded regions
     }
 
     @Override
@@ -91,13 +95,13 @@ public abstract class BaseChunkSystemHooks implements ca.spottedleaf.moonrise.co
 
     @Override
     public void onChunkBorder(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getLoadedChunks().add(chunk);
+        chunk.getLevel().getCurrentWorldData().addChunk(chunk); // Folia - region threading
         chunk.loadCallback();
     }
 
     @Override
     public void onChunkNotBorder(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getLoadedChunks().remove(chunk);
+        chunk.getLevel().getCurrentWorldData().removeChunk(chunk); // Folia - region threading
         chunk.unloadCallback();
     }
 
@@ -109,7 +113,7 @@ public abstract class BaseChunkSystemHooks implements ca.spottedleaf.moonrise.co
 
     @Override
     public void onChunkTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getTickingChunks().add(chunk);
+        chunk.getLevel().getCurrentWorldData().addTickingChunk(chunk); // Folia - region threading
         if (!((ChunkSystemLevelChunk)chunk).moonrise$isPostProcessingDone()) {
             chunk.postProcessGeneration((ServerLevel)chunk.getLevel());
         }
@@ -118,18 +122,18 @@ public abstract class BaseChunkSystemHooks implements ca.spottedleaf.moonrise.co
 
     @Override
     public void onChunkNotTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getTickingChunks().remove(chunk);
+        chunk.getLevel().getCurrentWorldData().removeTickingChunk(chunk); // Folia - region threading
     }
 
     @Override
     public void onChunkEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getEntityTickingChunks().add(chunk);
+        chunk.getLevel().getCurrentWorldData().addEntityTickingChunk(chunk); // Folia - region threading
         ((ChunkTickServerLevel)(ServerLevel)chunk.getLevel()).moonrise$markChunkForPlayerTicking(chunk); // Moonrise - chunk tick iteration
     }
 
     @Override
     public void onChunkNotEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        ((ChunkSystemServerLevel)((ServerLevel)chunk.getLevel())).moonrise$getEntityTickingChunks().remove(chunk);
+        chunk.getLevel().getCurrentWorldData().removeEntityTickingChunk(chunk); // Folia - region threading
         ((ChunkTickServerLevel)(ServerLevel)chunk.getLevel()).moonrise$removeChunkForPlayerTicking(chunk); // Moonrise - chunk tick iteration
     }
 
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/chunk/ChunkData.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/chunk/ChunkData.java
index 8b9dc582627b46843f4b5ea6f8c3df2d8cac46fa..306216138e21c41937e4728e8004220a02d6ea4b 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/chunk/ChunkData.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/chunk/ChunkData.java
@@ -5,7 +5,7 @@ import ca.spottedleaf.moonrise.common.misc.NearbyPlayers;
 public final class ChunkData {
 
     private int referenceCount = 0;
-    public NearbyPlayers.TrackedChunk nearbyPlayers; // Moonrise - nearby players
+    //public NearbyPlayers.TrackedChunk nearbyPlayers; // Moonrise - nearby players // Folia - region threading
 
     public ChunkData() {
 
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index 2d24d03bbdb5ee0d862cbfff2219f58afffafe12..20941198b3a1227381c0a9039898a6506344a588 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -464,6 +464,19 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         return slices == null || !slices.isPreventingStatusUpdates();
     }
 
+    // Folia start - region threading
+    // only appropriate to use when in shutdown, as this performs no logic hooks to properly add to world
+    public boolean addEntityForShutdownTeleportComplete(final Entity entity) {
+        final BlockPos pos = entity.blockPosition();
+        final int sectionX = pos.getX() >> 4;
+        final int sectionY = Mth.clamp(pos.getY() >> 4, WorldUtil.getMinSection(this.world), WorldUtil.getMaxSection(this.world));
+        final int sectionZ = pos.getZ() >> 4;
+        final ChunkEntitySlices slices = this.getOrCreateChunk(sectionX, sectionZ);
+
+        return slices.addEntity(entity, sectionY);
+    }
+    // Folia end - region threading
+
     protected void removeEntity(final Entity entity) {
         final int sectionX = ((ChunkSystemEntity)entity).moonrise$getSectionX();
         final int sectionY = ((ChunkSystemEntity)entity).moonrise$getSectionY();
@@ -990,6 +1003,9 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             EntityLookup.this.removeEntityCallback(entity);
 
             this.entity.setLevelCallback(NoOpCallback.INSTANCE);
+
+            // only AFTER full removal callbacks, so that thread checking will work. // Folia - region threading
+            EntityLookup.this.world.getCurrentWorldData().removeEntity(entity); // Folia - region threading
         }
     }
 
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/server/ServerEntityLookup.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/server/ServerEntityLookup.java
index f312a7f5b1b2a777ab36b94ce7cbf3873f5e88bc..b31b55f00e2ce1bd6c1011fe852bd1dbb37de524 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/server/ServerEntityLookup.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/server/ServerEntityLookup.java
@@ -22,13 +22,13 @@ public final class ServerEntityLookup extends EntityLookup {
     private static final Entity[] EMPTY_ENTITY_ARRAY = new Entity[0];
 
     private final ServerLevel serverWorld;
-    public final ReferenceList<Entity> trackerEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY); // Moonrise - entity tracker
+    // Folia - move to regionized world data
 
     // Vanilla does not increment ticket timeouts if the chunk is progressing in generation. They made this change in 1.21.6 so that the ender pearl
     // ticket does not expire if the chunk fails to generate before the timeout expires. Rather than blindly adjusting the entire system behavior
     // to fix this small issue, we instead add non-expirable tickets here to keep ender pearls ticking. This is how the original feature should have
     // been implemented, but I don't think Vanilla has proper entity add/remove hooks like we do. Fixes MC-297591
-    private static final TicketType ENDER_PEARL_TICKER = ChunkSystemTicketType.create("chunk_system:ender_pearl_ticker", null, 0L, TicketType.FLAG_LOADING | TicketType.FLAG_SIMULATION | TicketType.FLAG_KEEP_DIMENSION_ACTIVE);
+    private static final TicketType ENDER_PEARL_TICKER = ChunkSystemTicketType.create("chunk_system:ender_pearl_ticker", Integer::compareTo, 0L, TicketType.FLAG_LOADING | TicketType.FLAG_SIMULATION | TicketType.FLAG_KEEP_DIMENSION_ACTIVE); // Folia - region threading
     private final Long2IntOpenHashMap enderPearlChunkCount = new Long2IntOpenHashMap();
     private final boolean keepEnderPearlsTicking;
 
@@ -78,8 +78,8 @@ public final class ServerEntityLookup extends EntityLookup {
             ((ChunkSystemServerLevel)this.serverWorld).moonrise$getNearbyPlayers().tickPlayer(player);
         }
         if (entity instanceof ThrownEnderpearl enderpearl && (oldSectionX != newSectionX || oldSectionZ != newSectionZ)) {
-            this.removeEnderPearl(CoordinateUtils.getChunkKey(oldSectionX, oldSectionZ));
-            this.addEnderPearl(CoordinateUtils.getChunkKey(newSectionX, newSectionZ));
+            this.removeEnderPearl(CoordinateUtils.getChunkKey(oldSectionX, oldSectionZ), enderpearl.getId()); // Folia - region threading
+            this.addEnderPearl(CoordinateUtils.getChunkKey(newSectionX, newSectionZ), enderpearl.getId()); // Folia - region threading
         }
         PlatformHooks.get().entityMove(
             entity,
@@ -90,11 +90,12 @@ public final class ServerEntityLookup extends EntityLookup {
 
     @Override
     protected void addEntityCallback(final Entity entity) {
+        this.world.getCurrentWorldData().addEntity(entity); // Folia - region threading
         if (entity instanceof ServerPlayer player) {
             ((ChunkSystemServerLevel)this.serverWorld).moonrise$getNearbyPlayers().addPlayer(player);
         }
         if (entity instanceof ThrownEnderpearl enderpearl) {
-            this.addEnderPearl(CoordinateUtils.getChunkKey(enderpearl.chunkPosition()));
+            this.addEnderPearl(CoordinateUtils.getChunkKey(enderpearl.chunkPosition()), enderpearl.getId()); // Folia - region threading
         }
         entity.registerScheduler(); // Paper - optimise Folia entity scheduler
     }
@@ -105,21 +106,22 @@ public final class ServerEntityLookup extends EntityLookup {
             ((ChunkSystemServerLevel)this.serverWorld).moonrise$getNearbyPlayers().removePlayer(player);
         }
         if (entity instanceof ThrownEnderpearl enderpearl) {
-            this.removeEnderPearl(CoordinateUtils.getChunkKey(enderpearl.chunkPosition()));
+            this.removeEnderPearl(CoordinateUtils.getChunkKey(enderpearl.chunkPosition()), enderpearl.getId()); // Folia - region threading
         }
+        entity.getBukkitEntity().taskScheduler.registerTo(null); // Folia - region threading
     }
 
     @Override
     protected void entityStartLoaded(final Entity entity) {
         // Moonrise start - entity tracker
-        this.trackerEntities.add(entity);
+        this.world.getCurrentWorldData().trackerEntities.add(entity); // Folia - region threading
         // Moonrise end - entity tracker
     }
 
     @Override
     protected void entityEndLoaded(final Entity entity) {
         // Moonrise start - entity tracker
-        this.trackerEntities.remove(entity);
+        this.world.getCurrentWorldData().trackerEntities.remove(entity); // Folia - region threading
         // Moonrise end - entity tracker
     }
 
@@ -138,30 +140,22 @@ public final class ServerEntityLookup extends EntityLookup {
         return PlatformHooks.get().screenEntity(this.serverWorld, entity, fromDisk, event);
     }
 
-    private void addEnderPearl(final long coordinate) {
+    private void addEnderPearl(final long coordinate, final int entityId) { // Folia - region threading
         if (!this.keepEnderPearlsTicking) {
             return;
         }
-
-        final int oldCount = this.enderPearlChunkCount.addTo(coordinate, 1);
-        if (oldCount != 0) {
-            return;
-        }
+        // Folia - region threading
         ((ChunkSystemServerLevel)this.serverWorld).moonrise$getChunkTaskScheduler().chunkHolderManager
-            .addTicketAtLevel(ENDER_PEARL_TICKER, coordinate, ChunkHolderManager.ENTITY_TICKING_TICKET_LEVEL, null);
+            .addTicketAtLevel(ENDER_PEARL_TICKER, coordinate, ChunkHolderManager.ENTITY_TICKING_TICKET_LEVEL, Integer.valueOf(entityId)); // Folia - region threading
     }
 
-    private void removeEnderPearl(final long coordinate) {
+    private void removeEnderPearl(final long coordinate, final int entityId) { // Folia - region threading
         if (!this.keepEnderPearlsTicking) {
             return;
         }
 
-        final int oldCount = this.enderPearlChunkCount.addTo(coordinate, -1);
-        if (oldCount != 1) {
-            return;
-        }
-        this.enderPearlChunkCount.remove(coordinate);
+        // Folia - region threading
         ((ChunkSystemServerLevel)this.serverWorld).moonrise$getChunkTaskScheduler().chunkHolderManager
-            .removeTicketAtLevel(ENDER_PEARL_TICKER, coordinate, ChunkHolderManager.ENTITY_TICKING_TICKET_LEVEL, null);
+            .removeTicketAtLevel(ENDER_PEARL_TICKER, coordinate, ChunkHolderManager.ENTITY_TICKING_TICKET_LEVEL, Integer.valueOf(entityId)); // Folia - region threading
     }
 }
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index 7129c5e1920008ac54f3a8ac83f5589396f4e4e9..d94c0d15f62b67378669d4ce7252d99b8f743fa5 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -218,7 +218,7 @@ public final class RegionizedPlayerChunkLoader {
         final PlayerChunkLoaderData loader = ((ChunkSystemServerPlayer)player).moonrise$getChunkLoader();
 
         if (loader == null) {
-            return;
+            throw new IllegalStateException("Player is already removed from player chunk loader"); // Folia - region threading
         }
 
         loader.remove();
@@ -306,7 +306,7 @@ public final class RegionizedPlayerChunkLoader {
     public void tick() {
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
-        for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
+        for (final ServerPlayer player : new java.util.ArrayList<>(this.world.getLocalPlayers())) { // Folia - region threding
             final PlayerChunkLoaderData loader = ((ChunkSystemServerPlayer)player).moonrise$getChunkLoader();
             if (loader == null || loader.removed || loader.world != this.world) {
                 // not our problem anymore
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java b/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
index 7eafc5b7cba23d8dec92ecc1050afe3fd8c9e309..4bfcae47ed76346e6200514ebce5b04f907c5026 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
@@ -29,6 +29,39 @@ public final class ChunkUnloadQueue {
 
     public static record SectionToUnload(int sectionX, int sectionZ, long order, int count) {}
 
+    // Folia start - threaded regions
+    public List<SectionToUnload> retrieveForCurrentRegion() {
+        final io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> region =
+            io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion();
+        final io.papermc.paper.threadedregions.ThreadedRegionizer<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> regionizer = region.regioniser;
+        final int shift = this.coordinateShift;
+
+        final List<SectionToUnload> ret = new ArrayList<>();
+
+        for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<UnloadSection>> iterator = this.unloadSections.entryIterator(); iterator.hasNext();) {
+            final ConcurrentLong2ReferenceChainedHashTable.TableEntry<UnloadSection> entry = iterator.next();
+            final long key = entry.getKey();
+            final UnloadSection section = entry.getValue();
+            final int sectionX = CoordinateUtils.getChunkX(key);
+            final int sectionZ = CoordinateUtils.getChunkZ(key);
+            final int chunkX = sectionX << shift;
+            final int chunkZ = sectionZ << shift;
+
+            if (regionizer.getRegionAtUnsynchronised(chunkX, chunkZ) != region) {
+                continue;
+            }
+
+            ret.add(new SectionToUnload(sectionX, sectionZ, section.order, section.chunks.size()));
+        }
+
+        ret.sort((final SectionToUnload s1, final SectionToUnload s2) -> {
+            return Long.compare(s1.order, s2.order);
+        });
+
+        return ret;
+    }
+    // Folia end - threaded regions
+
     public List<SectionToUnload> retrieveForAllRegions() {
         final List<SectionToUnload> ret = new ArrayList<>();
 
@@ -141,4 +174,4 @@ public final class ChunkUnloadQueue {
             this.order = order;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 467065e3b40df17f38716499259b46663c174fd0..01f24ac927661fa4b3895f66031c8b9d6c50742d 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -61,6 +61,14 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.Predicate;
 
+// Folia start - region threading
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+// Folia end - region threading
+
 public final class ChunkHolderManager {
 
     private static final Logger LOGGER = LogUtils.getClassLogger();
@@ -82,30 +90,83 @@ public final class ChunkHolderManager {
     private final ConcurrentLong2ReferenceChainedHashTable<NewChunkHolder> chunkHolders = ConcurrentLong2ReferenceChainedHashTable.createWithCapacity(16384, 0.25f);
     private final ServerLevel world;
     private final ChunkTaskScheduler taskScheduler;
-    private long currentTick;
+    // Folia start - region threading
+    public static final class HolderManagerRegionData {
+        private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
+        private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
+            if (c1 == c2) {
+                return 0;
+            }
+
+            final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
+
+            if (saveTickCompare != 0) {
+                return saveTickCompare;
+            }
+
+            final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
+            final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
+
+            if (coord1 == coord2) {
+                throw new IllegalStateException("Duplicate chunkholder in auto save queue");
+            }
+
+            return Long.compare(coord1, coord2);
+        });
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final MultiThreadedQueue<NewChunkHolder> offThreadPendingFullLoadUpdate = new MultiThreadedQueue<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
+        public void merge(final HolderManagerRegionData into, final long tickOffset) {
+            // Order doesn't really matter for the pending full update...
+            into.pendingFullLoadUpdate.addAll(this.pendingFullLoadUpdate);
+
+            // We need to copy the set to iterate over, because modifying the field used in compareTo while iterating
+            // will destroy the result from compareTo (However, the set is not destroyed _after_ iteration because a constant
+            // addition to every entry will not affect compareTo).
+            for (final NewChunkHolder holder : new ArrayList<>(this.autoSaveQueue)) {
+                holder.lastAutoSave += tickOffset;
+                into.autoSaveQueue.add(holder);
+            }
         }
 
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
+        public void split(final int chunkToRegionShift, final Long2ReferenceOpenHashMap<HolderManagerRegionData> regionToData,
+                          final ReferenceOpenHashSet<HolderManagerRegionData> dataSet) {
+            for (final NewChunkHolder fullLoadUpdate : this.pendingFullLoadUpdate) {
+                final int regionCoordinateX = fullLoadUpdate.chunkX >> chunkToRegionShift;
+                final int regionCoordinateZ = fullLoadUpdate.chunkZ >> chunkToRegionShift;
+
+                final HolderManagerRegionData data = regionToData.get(CoordinateUtils.getChunkKey(regionCoordinateX, regionCoordinateZ));
+                if (data != null) {
+                    data.pendingFullLoadUpdate.add(fullLoadUpdate);
+                } // else: fullLoadUpdate is an unloaded chunk holder
+            }
+
+            for (final NewChunkHolder autoSave : this.autoSaveQueue) {
+                final int regionCoordinateX = autoSave.chunkX >> chunkToRegionShift;
+                final int regionCoordinateZ = autoSave.chunkZ >> chunkToRegionShift;
 
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
+                final HolderManagerRegionData data = regionToData.get(CoordinateUtils.getChunkKey(regionCoordinateX, regionCoordinateZ));
+                if (data != null) {
+                    data.autoSaveQueue.add(autoSave);
+                } // else: autoSave is an unloaded chunk holder
+            }
         }
+    }
 
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
+    private ChunkHolderManager.HolderManagerRegionData getCurrentRegionData() {
+        final ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
 
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
+        if (region == null) {
+            return null;
         }
 
-        return Long.compare(coord1, coord2);
-    });
+        if (this.world != null && this.world != region.getData().world) {
+            throw new IllegalStateException("World check failed: expected world: " + this.world.getWorld().getKey() + ", region world: " + region.getData().world.getWorld().getKey());
+        }
+
+        return region.getData().getHolderManagerRegionData();
+    }
+    // Folia end - region threading
+
 
     // mapping of counter id -> (mapping of pos->count)
     private final ConcurrentLong2ReferenceChainedHashTable<ConcurrentLong2LongChainedHashTable> ticketCounters = new ConcurrentLong2ReferenceChainedHashTable<>();
@@ -192,8 +253,13 @@ public final class ChunkHolderManager {
     }
 
     public void close(final boolean save, final boolean halt) {
+        // Folia start - region threading
+        this.close(save, halt, true, true, true);
+    }
+    public void close(final boolean save, final boolean halt, final boolean first, final boolean last, final boolean checkRegions) {
+        // Folia end - region threading
         TickThread.ensureTickThread("Closing world off-main");
-        if (halt) {
+        if (first && halt) { // Folia - region threading
             LOGGER.info("Waiting 60s for chunk system to halt for world '" + WorldUtil.getWorldName(this.world) + "'");
             if (!this.taskScheduler.halt(true, TimeUnit.SECONDS.toNanos(60L))) {
                 LOGGER.warn("Failed to halt generation/loading tasks for world '" + WorldUtil.getWorldName(this.world) + "'");
@@ -203,9 +269,10 @@ public final class ChunkHolderManager {
         }
 
         if (save) {
-            this.saveAllChunks(true, true, true, false);
+            this.saveAllChunksRegionised(true, true, true, false, first, last, checkRegions); // Folia - region threading
         }
 
+        if (last) { // Folia - region threading
         MoonriseRegionFileIO.flush(this.world);
 
         if (halt) {
@@ -227,28 +294,35 @@ public final class ChunkHolderManager {
         }
 
         this.taskScheduler.setShutdown(true);
+        } // Folia - region threading
     }
 
     void ensureInAutosave(final NewChunkHolder holder) {
-        if (!this.autoSaveQueue.contains(holder)) {
-            holder.lastAutoSave = this.currentTick;
-            this.autoSaveQueue.add(holder);
+        // Folia start - region threading
+        final HolderManagerRegionData regionData = this.getCurrentRegionData();
+        if (!regionData.autoSaveQueue.contains(holder)) {
+            holder.lastAutoSave = RegionizedServer.getCurrentTick();
+            regionData.autoSaveQueue.add(holder);
+            // Folia end - region threading
         }
     }
 
     public void autoSave() {
         final List<NewChunkHolder> reschedule = new ArrayList<>();
-        final long currentTick = this.currentTick;
+        final long currentTick = RegionizedServer.getCurrentTick(); // Folia - region threading
         final long maxSaveTime = currentTick - Math.max(1L, PlatformHooks.get().configAutoSaveInterval(this.world));
         final int maxToSave = PlatformHooks.get().configMaxAutoSavePerTick(this.world);
-        for (int autoSaved = 0; autoSaved < maxToSave && !this.autoSaveQueue.isEmpty();) {
-            final NewChunkHolder holder = this.autoSaveQueue.first();
+        // Folia start - region threading
+        final HolderManagerRegionData regionData = this.getCurrentRegionData();
+        for (int autoSaved = 0; autoSaved < maxToSave && !regionData.autoSaveQueue.isEmpty();) {
+            final NewChunkHolder holder = regionData.autoSaveQueue.first();
+            // Folia end - region threading
 
             if (holder.lastAutoSave > maxSaveTime) {
                 break;
             }
 
-            this.autoSaveQueue.remove(holder);
+            regionData.autoSaveQueue.remove(holder); // Folia - region threading
 
             holder.lastAutoSave = currentTick;
             if (holder.save(false) != null) {
@@ -262,16 +336,40 @@ public final class ChunkHolderManager {
 
         for (final NewChunkHolder holder : reschedule) {
             if (holder.getChunkStatus().isOrAfter(FullChunkStatus.FULL)) {
-                this.autoSaveQueue.add(holder);
+                regionData.autoSaveQueue.add(holder); // Folia start - region threading
             }
         }
     }
 
     public void saveAllChunks(final boolean flush, final boolean shutdown, final boolean logProgress,
                               final boolean emergency) {
-        final List<NewChunkHolder> holders = this.getChunkHolders();
+        // Folia start - region threading
+        this.saveAllChunksRegionised(flush, shutdown, logProgress, emergency, true, true, true);
+    }
+    public void saveAllChunksRegionised(final boolean flush, final boolean shutdown, final boolean logProgress,
+                                        final boolean emergency, final boolean first, final boolean last, final boolean checkRegion) {
+        final List<NewChunkHolder> holders = new java.util.ArrayList<>(this.chunkHolders.size() / 10);
+        // we could iterate through all chunk holders with thread checks, however for many regions the iteration cost alone
+        // will multiply. to avoid this, we can simply iterate through all owned sections
+        final int regionShift = this.world.moonrise$getRegionChunkShift();
+        final int width = 1 << regionShift;
+        for (final LongIterator iterator = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion().getOwnedSectionsUnsynchronised(); iterator.hasNext();) {
+            final long sectionKey = iterator.nextLong();
+            final int offsetX = CoordinateUtils.getChunkX(sectionKey) << regionShift;
+            final int offsetZ = CoordinateUtils.getChunkZ(sectionKey) << regionShift;
+
+            for (int dz = 0; dz < width; ++dz) {
+                for (int dx = 0; dx < width; ++dx) {
+                    final NewChunkHolder holder = this.getChunkHolder(offsetX | dx, offsetZ | dz);
+                    if (holder != null) {
+                        holders.add(holder);
+                    }
+                }
+            }
+        }
+        // Folia end - region threading
 
-        if (logProgress) {
+        if (first && logProgress) { // Folia - region threading
             if (emergency) {
                 LOGGER.info("Emergency saving all chunkholders for world '" + WorldUtil.getWorldName(this.world) + "'");
             } else {
@@ -304,6 +402,12 @@ public final class ChunkHolderManager {
         }
         for (int i = 0, len = holders.size(); i < len; ++i) {
             final NewChunkHolder holder = holders.get(i);
+            // Folia start - region threading
+            if (!checkRegion && !TickThread.isTickThreadFor(this.world, holder.chunkX, holder.chunkZ)) {
+                // skip holders that would fail the thread check
+                continue;
+            }
+            // Folia end - region threading
             try {
                 final NewChunkHolder.SaveStat saveStat = holder.save(shutdown);
                 if (saveStat != null) {
@@ -339,7 +443,7 @@ public final class ChunkHolderManager {
                 }
             }
         }
-        if (flush) {
+        if (last && flush) { // Folia - region threading
             MoonriseRegionFileIO.flush(this.world);
             try {
                 MoonriseRegionFileIO.flushRegionStorages(this.world);
@@ -809,7 +913,13 @@ public final class ChunkHolderManager {
     }
 
     public void tick() {
-        ++this.currentTick;
+        // Folia start - region threading
+        final ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            throw new IllegalStateException("Not running tick() while on a region");
+        }
+        // Folia end - region threading
 
         final int sectionShift = ((ChunkSystemServerLevel)this.world).moonrise$getRegionChunkShift();
 
@@ -818,7 +928,7 @@ public final class ChunkHolderManager {
 
         Ticket[] removedList = new Ticket[4];
 
-        for (final PrimitiveIterator.OfLong iterator = this.sectionToChunkToExpireCount.keyIterator(); iterator.hasNext();) {
+        for (final LongIterator iterator = region.getOwnedSectionsUnsynchronised(); iterator.hasNext();) { // Folia - region threading
             final long sectionKey = iterator.nextLong();
 
             if (!this.sectionToChunkToExpireCount.containsKey(sectionKey)) {
@@ -1129,21 +1239,55 @@ public final class ChunkHolderManager {
         if (changedFullStatus.isEmpty()) {
             return;
         }
-        if (!TickThread.isTickThread()) {
-            // These will be handled on the next ServerChunkCache$MainThreadExecutor#pollTask, as it runs the distance manager update
-            // which will invoke processTicketUpdates
-            this.offThreadPendingFullLoadUpdate.addAll(changedFullStatus);
-        } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
-            for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
-                pendingFullLoadUpdate.add(changedFullStatus.get(i));
+
+        // Folia start - region threading
+        final Long2ObjectOpenHashMap<List<NewChunkHolder>> sectionToUpdates = new Long2ObjectOpenHashMap<>();
+        final List<NewChunkHolder> thisRegionHolders = new ArrayList<>();
+
+        final int regionShift = this.world.moonrise$getRegionChunkShift();
+        final ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> thisRegion
+            = TickRegionScheduler.getCurrentRegion();
+
+        for (final NewChunkHolder holder : changedFullStatus) {
+            final int regionX = holder.chunkX >> regionShift;
+            final int regionZ = holder.chunkZ >> regionShift;
+            final long holderSectionKey = CoordinateUtils.getChunkKey(regionX, regionZ);
+
+            // region may be null
+            if (thisRegion != null && this.world.regioniser.getRegionAtUnsynchronised(holder.chunkX, holder.chunkZ) == thisRegion) {
+                thisRegionHolders.add(holder);
+            } else {
+                sectionToUpdates.computeIfAbsent(holderSectionKey, (final long keyInMap) -> {
+                    return new ArrayList<>();
+                }).add(holder);
+            }
+        }
+        if (!thisRegionHolders.isEmpty()) {
+            thisRegion.getData().getHolderManagerRegionData().pendingFullLoadUpdate.addAll(thisRegionHolders);
+        }
+
+        if (!sectionToUpdates.isEmpty()) {
+            for (final Iterator<Long2ObjectMap.Entry<List<NewChunkHolder>>> iterator = sectionToUpdates.long2ObjectEntrySet().fastIterator();
+                iterator.hasNext();) {
+                final Long2ObjectMap.Entry<List<NewChunkHolder>> entry = iterator.next();
+                final long sectionKey = entry.getLongKey();
+
+                final int chunkX = CoordinateUtils.getChunkX(sectionKey) << regionShift;
+                final int chunkZ = CoordinateUtils.getChunkZ(sectionKey) << regionShift;
+
+                final List<NewChunkHolder> regionHolders = entry.getValue();
+                this.taskScheduler.scheduleChunkTaskEventually(chunkX, chunkZ, () -> {
+                    ChunkHolderManager.this.getCurrentRegionData().pendingFullLoadUpdate.addAll(regionHolders);
+                    ChunkHolderManager.this.processPendingFullUpdate();
+                }, Priority.HIGHEST);
             }
         }
+        // Folia end - region threading
     }
 
     private void removeChunkHolder(final NewChunkHolder holder) {
         holder.onUnload();
-        this.autoSaveQueue.remove(holder);
+        this.getCurrentRegionData().autoSaveQueue.remove(holder); // Folia - region threading
         PlatformHooks.get().onChunkHolderDelete(this.world, holder.vanillaChunkHolder);
         this.chunkHolders.remove(CoordinateUtils.getChunkKey(holder.chunkX, holder.chunkZ));
     }
@@ -1156,7 +1300,7 @@ public final class ChunkHolderManager {
             throw new IllegalStateException("Cannot unload chunks recursively");
         }
         final int sectionShift = this.unloadQueue.coordinateShift; // sectionShift <= lock shift
-        final List<ChunkUnloadQueue.SectionToUnload> unloadSectionsForRegion = this.unloadQueue.retrieveForAllRegions();
+        final List<ChunkUnloadQueue.SectionToUnload> unloadSectionsForRegion = this.unloadQueue.retrieveForCurrentRegion(); // Folia - threaded regions
         int unloadCountTentative = 0;
         for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
             final ChunkUnloadQueue.UnloadSection section
@@ -1458,22 +1602,17 @@ public final class ChunkHolderManager {
         return CURRENT_TICKET_UPDATE_SCHEDULING.get();
     }
 
-    // only call on tick thread
-    private void processOffThreadFullUpdates() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
-        final MultiThreadedQueue<NewChunkHolder> offThreadPendingFullLoadUpdate = this.offThreadPendingFullLoadUpdate;
-
-        NewChunkHolder toUpdate;
-        while ((toUpdate = offThreadPendingFullLoadUpdate.poll()) != null) {
-            pendingFullLoadUpdate.add(toUpdate);
-        }
-    }
+    // Folia - region threading
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        this.processOffThreadFullUpdates();
-
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        // Folia start - region threading
+        final HolderManagerRegionData data = this.getCurrentRegionData();
+        if (data == null) {
+            return false;
+        }
+        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = data.pendingFullLoadUpdate;
+        // Folia end - region threading
 
         boolean ret = false;
 
@@ -1489,9 +1628,7 @@ public final class ChunkHolderManager {
             ret |= holder.handleFullStatusChange(changedFullStatus);
 
             if (!changedFullStatus.isEmpty()) {
-                for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
-                    pendingFullLoadUpdate.add(changedFullStatus.get(i));
-                }
+                this.addChangedStatuses(changedFullStatus); // Folia - region threading
                 changedFullStatus.clear();
             }
         }
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
index 640548d78b87653871dd1f7b0f84574c5e205fe8..5068de75f6f38c0459b77eb7354ce9db2d251d2c 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
@@ -114,7 +114,7 @@ public final class ChunkTaskScheduler {
     public final BalancedPrioritisedThreadPool.OrderedStreamGroup.Queue compressionExecutor;
     public final BalancedPrioritisedThreadPool.OrderedStreamGroup.Queue saveExecutor;
 
-    private final PrioritisedTaskQueue mainThreadExecutor = new PrioritisedTaskQueue();
+    // Folia - regionised ticking
 
     public final ChunkHolderManager chunkHolderManager;
 
@@ -328,25 +328,18 @@ public final class ChunkTaskScheduler {
         };
 
         // this may not be good enough, specifically thanks to stupid ass plugins swallowing exceptions
-        this.scheduleChunkTask(chunkX, chunkZ, crash, Priority.BLOCKING);
+        this.scheduleChunkTaskEventually(chunkX, chunkZ, crash, Priority.BLOCKING); // Folia - region threading
         // so, make the main thread pick it up
         ((ChunkSystemMinecraftServer)this.world.getServer()).moonrise$setChunkSystemCrash(new RuntimeException("Chunk system crash propagated from unrecoverableChunkSystemFailure", reportedException));
     }
 
     public boolean executeMainThreadTask() {
-        TickThread.ensureTickThread("Cannot execute main thread task off-main");
-        return this.mainThreadExecutor.executeTask();
+        throw new UnsupportedOperationException("Use regionised ticking hooks"); // Folia - regionised ticking
     }
 
     // run only tasks queued before this function was invoked
     public void executeAllRecentlyQueuedMainThreadTasks() {
-        // note: order of retrieval is important to avoid race conditions
-        final long executed = this.mainThreadExecutor.getTotalTasksExecuted();
-        final long scheduled = this.mainThreadExecutor.getTotalTasksScheduled();
-
-        final long left = scheduled - executed;
-        // may execute more tasks than expected due to recursion
-        for (long i = 0; i < left && this.mainThreadExecutor.executeTask(); ++i);
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     public void raisePriority(final int x, final int z, final Priority priority) {
@@ -553,9 +546,20 @@ public final class ChunkTaskScheduler {
 
         // we could do a simple spinwait here, since we do not need to process tasks while performing this load
         // but we process tasks only because it's a better use of the time spent
-        this.world.getChunkSource().mainThreadProcessor.managedBlock(() -> {
-            return ((ChunkSystemServerLevel)this.world).moonrise$getSpecificChunkIfLoaded(chunkX, chunkZ, status) != null;
-        });
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
+                region = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            while (((ChunkSystemServerLevel)this.world).moonrise$getSpecificChunkIfLoaded(chunkX, chunkZ, status) == null) {
+                Thread.yield();
+                java.util.concurrent.locks.LockSupport.parkNanos(100_000L);
+            }
+        } else {
+            region.regioniser.world.getChunkSource().mainThreadProcessor.managedBlock(() -> {
+                return ((ChunkSystemServerLevel)this.world).moonrise$getSpecificChunkIfLoaded(chunkX, chunkZ, status) != null;
+            });
+        }
+        // Folia end - region threading
 
         loaded = ((ChunkSystemServerLevel)this.world).moonrise$getSpecificChunkIfLoaded(chunkX, chunkZ, status);
 
@@ -831,7 +835,7 @@ public final class ChunkTaskScheduler {
      */
     @Deprecated
     public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final Runnable run, final Priority priority) {
-        return this.mainThreadExecutor.queueTask(run, priority);
+        throw new UnsupportedOperationException(); // Folia - regionised ticking
     }
 
     public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
@@ -840,7 +844,7 @@ public final class ChunkTaskScheduler {
 
     public PrioritisedExecutor.PrioritisedTask createChunkTask(final int chunkX, final int chunkZ, final Runnable run,
                                                                final Priority priority) {
-        return this.mainThreadExecutor.createTask(run, priority);
+        return io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.createChunkTask(this.world, chunkX, chunkZ, run, priority); // Folia - regionised ticking
     }
 
     public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run) {
@@ -849,8 +853,26 @@ public final class ChunkTaskScheduler {
 
     public PrioritisedExecutor.PrioritisedTask scheduleChunkTask(final int chunkX, final int chunkZ, final Runnable run,
                                                                  final Priority priority) {
-        return this.mainThreadExecutor.queueTask(run, priority);
+        return io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this.world, chunkX, chunkZ, run, priority); // Folia - regionised ticking
+    }
+
+    // Folia start - region threading
+    // this function is guaranteed to never touch the ticket lock or schedule lock
+    // yes, this IS a hack so that we can avoid deadlock due to region threading introducing the
+    // ticket lock in the schedule logic
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTaskEventually(final int chunkX, final int chunkZ, final Runnable run) {
+        return this.scheduleChunkTaskEventually(chunkX, chunkZ, run, Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask scheduleChunkTaskEventually(final int chunkX, final int chunkZ, final Runnable run,
+                                                                           final Priority priority) {
+        final PrioritisedExecutor.PrioritisedTask ret = this.createChunkTask(chunkX, chunkZ, run, priority);
+        this.world.taskQueueRegionData.pushGlobalChunkTask(() -> {
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(ChunkTaskScheduler.this.world, chunkX, chunkZ, run, priority);
+        });
+        return ret;
     }
+    // Folia end - region threading
 
     public boolean halt(final boolean sync, final long maxWaitNS) {
         this.parallelGenExecutor.halt();
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
index 9a9a599ef178f851ee5c783631a724013a693586..fdb0bcdca1cd38f55f191d42e422c354af4452b5 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -1350,7 +1350,7 @@ public final class NewChunkHolder {
         }
 
         // must be scheduled to main, we do not trust the callback to not do anything stupid
-        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+        this.scheduler.scheduleChunkTaskEventually(this.chunkX, this.chunkZ, () -> { // Folia - region threading
             for (final Consumer<ChunkAccess> consumer : consumers) {
                 try {
                     consumer.accept(chunk);
@@ -1378,7 +1378,7 @@ public final class NewChunkHolder {
         }
 
         // must be scheduled to main, we do not trust the callback to not do anything stupid
-        this.scheduler.scheduleChunkTask(this.chunkX, this.chunkZ, () -> {
+        this.scheduler.scheduleChunkTaskEventually(this.chunkX, this.chunkZ, () -> { // Folia - region threading
             for (final Consumer<LevelChunk> consumer : consumers) {
                 try {
                     consumer.accept(chunk);
diff --git a/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java b/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
index 817e4ffd597938697f0c4dca16068f8d20c088b3..e8bdc71a97c404f162e62ef777f47df8499c200c 100644
--- a/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
+++ b/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
@@ -1940,6 +1940,17 @@ public final class CollisionUtil {
 
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
             for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+                // Folia start - region threading
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(world, currChunkX, currChunkZ, 4)) {
+                    if (checkOnly) {
+                        return true;
+                    } else {
+                        intoAABB.add(getBoxForChunk(currChunkX, currChunkZ));
+                        ret = true;
+                        continue;
+                    }
+                }
+                // Folia end - region threading
                 final ChunkAccess chunk = chunkSource.getChunk(currChunkX, currChunkZ, ChunkStatus.FULL, loadChunks);
 
                 if (chunk == null) {
diff --git a/io/papermc/paper/entity/activation/ActivationRange.java b/io/papermc/paper/entity/activation/ActivationRange.java
index c18823746ab2edcab536cb1589b7720e3af07e0f..e22bd0f080fa2de8b17aa4d79e1228e7cfa16fdd 100644
--- a/io/papermc/paper/entity/activation/ActivationRange.java
+++ b/io/papermc/paper/entity/activation/ActivationRange.java
@@ -54,33 +54,34 @@ public final class ActivationRange {
 
     private static int checkInactiveWakeup(final Entity entity) {
         final Level world = entity.level();
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - threaded regions
         final SpigotWorldConfig config = world.spigotConfig;
-        final long inactiveFor = MinecraftServer.currentTick - entity.activatedTick;
+        final long inactiveFor = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() - entity.activatedTick; // Folia - threaded regions
         if (entity.activationType == ActivationType.VILLAGER) {
-            if (inactiveFor > config.wakeUpInactiveVillagersEvery && world.wakeupInactiveRemainingVillagers > 0) {
-                world.wakeupInactiveRemainingVillagers--;
+            if (inactiveFor > config.wakeUpInactiveVillagersEvery && worldData.wakeupInactiveRemainingVillagers > 0) { // Folia - threaded regions
+                worldData.wakeupInactiveRemainingVillagers--; // Folia - threaded regions
                 return config.wakeUpInactiveVillagersFor;
             }
         } else if (entity.activationType == ActivationType.ANIMAL) {
-            if (inactiveFor > config.wakeUpInactiveAnimalsEvery && world.wakeupInactiveRemainingAnimals > 0) {
-                world.wakeupInactiveRemainingAnimals--;
+            if (inactiveFor > config.wakeUpInactiveAnimalsEvery && worldData.wakeupInactiveRemainingAnimals > 0) { // Folia - threaded regions
+                worldData.wakeupInactiveRemainingAnimals--; // Folia - threaded regions
                 return config.wakeUpInactiveAnimalsFor;
             }
         } else if (entity.activationType == ActivationType.FLYING_MONSTER) {
-            if (inactiveFor > config.wakeUpInactiveFlyingEvery && world.wakeupInactiveRemainingFlying > 0) {
-                world.wakeupInactiveRemainingFlying--;
+            if (inactiveFor > config.wakeUpInactiveFlyingEvery && worldData.wakeupInactiveRemainingFlying > 0) { // Folia - threaded regions
+                worldData.wakeupInactiveRemainingFlying--; // Folia - threaded regions
                 return config.wakeUpInactiveFlyingFor;
             }
         } else if (entity.activationType == ActivationType.MONSTER || entity.activationType == ActivationType.RAIDER) {
-            if (inactiveFor > config.wakeUpInactiveMonstersEvery && world.wakeupInactiveRemainingMonsters > 0) {
-                world.wakeupInactiveRemainingMonsters--;
+            if (inactiveFor > config.wakeUpInactiveMonstersEvery && worldData.wakeupInactiveRemainingMonsters > 0) { // Folia - threaded regions
+                worldData.wakeupInactiveRemainingMonsters--; // Folia - threaded regions
                 return config.wakeUpInactiveMonstersFor;
             }
         }
         return -1;
     }
 
-    static AABB maxBB = new AABB(0, 0, 0, 0, 0, 0);
+    //static AABB maxBB = new AABB(0, 0, 0, 0, 0, 0); // Folia - threaded regions - replaced by local variable
 
     /**
      * These entities are excluded from Activation range checks.
@@ -128,10 +129,11 @@ public final class ActivationRange {
         final int waterActivationRange = world.spigotConfig.waterActivationRange;
         final int flyingActivationRange = world.spigotConfig.flyingMonsterActivationRange;
         final int villagerActivationRange = world.spigotConfig.villagerActivationRange;
-        world.wakeupInactiveRemainingAnimals = Math.min(world.wakeupInactiveRemainingAnimals + 1, world.spigotConfig.wakeUpInactiveAnimals);
-        world.wakeupInactiveRemainingVillagers = Math.min(world.wakeupInactiveRemainingVillagers + 1, world.spigotConfig.wakeUpInactiveVillagers);
-        world.wakeupInactiveRemainingMonsters = Math.min(world.wakeupInactiveRemainingMonsters + 1, world.spigotConfig.wakeUpInactiveMonsters);
-        world.wakeupInactiveRemainingFlying = Math.min(world.wakeupInactiveRemainingFlying + 1, world.spigotConfig.wakeUpInactiveFlying);
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - threaded regions
+        worldData.wakeupInactiveRemainingAnimals = Math.min(worldData.wakeupInactiveRemainingAnimals + 1, world.spigotConfig.wakeUpInactiveAnimals); // Folia - threaded regions
+        worldData.wakeupInactiveRemainingVillagers = Math.min(worldData.wakeupInactiveRemainingVillagers + 1, world.spigotConfig.wakeUpInactiveVillagers); // Folia - threaded regions
+        worldData.wakeupInactiveRemainingMonsters = Math.min(worldData.wakeupInactiveRemainingMonsters + 1, world.spigotConfig.wakeUpInactiveMonsters); // Folia - threaded regions
+        worldData.wakeupInactiveRemainingFlying = Math.min(worldData.wakeupInactiveRemainingFlying + 1, world.spigotConfig.wakeUpInactiveFlying); // Folia - threaded regions
 
         int maxRange = Math.max(monsterActivationRange, animalActivationRange);
         maxRange = Math.max(maxRange, raiderActivationRange);
@@ -141,30 +143,37 @@ public final class ActivationRange {
         maxRange = Math.max(maxRange, villagerActivationRange);
         maxRange = Math.min((world.spigotConfig.simulationDistance << 4) - 8, maxRange);
 
-        for (final Player player : world.players()) {
-            player.activatedTick = MinecraftServer.currentTick;
+        for (final Player player : world.getLocalPlayers()) { // Folia - region threading
+            player.activatedTick = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - region threading
             if (world.spigotConfig.ignoreSpectatorActivation && player.isSpectator()) {
                 continue;
             }
 
             final int worldHeight = world.getHeight();
-            ActivationRange.maxBB = player.getBoundingBox().inflate(maxRange, worldHeight, maxRange);
-            ActivationType.MISC.boundingBox = player.getBoundingBox().inflate(miscActivationRange, worldHeight, miscActivationRange);
-            ActivationType.RAIDER.boundingBox = player.getBoundingBox().inflate(raiderActivationRange, worldHeight, raiderActivationRange);
-            ActivationType.ANIMAL.boundingBox = player.getBoundingBox().inflate(animalActivationRange, worldHeight, animalActivationRange);
-            ActivationType.MONSTER.boundingBox = player.getBoundingBox().inflate(monsterActivationRange, worldHeight, monsterActivationRange);
-            ActivationType.WATER.boundingBox = player.getBoundingBox().inflate(waterActivationRange, worldHeight, waterActivationRange);
-            ActivationType.FLYING_MONSTER.boundingBox = player.getBoundingBox().inflate(flyingActivationRange, worldHeight, flyingActivationRange);
-            ActivationType.VILLAGER.boundingBox = player.getBoundingBox().inflate(villagerActivationRange, worldHeight, villagerActivationRange);
+            final AABB maxBB = player.getBoundingBox().inflate(maxRange, worldHeight, maxRange); // Folia - threaded regions
+            final AABB[] bbByType = new AABB[ActivationType.values().length]; // Folia - threaded regions
+            bbByType[ActivationType.MISC.ordinal()] = player.getBoundingBox().inflate(miscActivationRange, worldHeight, miscActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.RAIDER.ordinal()] = player.getBoundingBox().inflate(raiderActivationRange, worldHeight, raiderActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.ANIMAL.ordinal()] = player.getBoundingBox().inflate(animalActivationRange, worldHeight, animalActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.MONSTER.ordinal()] = player.getBoundingBox().inflate(monsterActivationRange, worldHeight, monsterActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.WATER.ordinal()] = player.getBoundingBox().inflate(waterActivationRange, worldHeight, waterActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.FLYING_MONSTER.ordinal()] = player.getBoundingBox().inflate(flyingActivationRange, worldHeight, flyingActivationRange); // Folia - threaded regions
+            bbByType[ActivationType.VILLAGER.ordinal()] = player.getBoundingBox().inflate(villagerActivationRange, worldHeight, villagerActivationRange); // Folia - threaded regions
 
-            final List<Entity> entities = world.getEntities((Entity) null, ActivationRange.maxBB, e -> true);
+            final java.util.List<Entity> entities = new java.util.ArrayList<>();  // Folia - region ticking - bypass getEntities thread check, we perform a check on the entities later
+            ((net.minecraft.server.level.ServerLevel)world).moonrise$getEntityLookup().getEntities((Entity)null, maxBB, entities, null); // Folia - region ticking - bypass getEntities thread check, we perform a check on the entities later
             final boolean tickMarkers = world.paperConfig().entities.markers.tick;
             for (final Entity entity : entities) {
+                // Folia start - region ticking
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity)) {
+                    continue;
+                }
+                // Folia end - region ticking
                 if (!tickMarkers && entity instanceof Marker) {
                     continue;
                 }
 
-                ActivationRange.activateEntity(entity);
+                ActivationRange.activateEntity(entity, bbByType); // Folia - threaded regions
             }
         }
     }
@@ -174,14 +183,14 @@ public final class ActivationRange {
      *
      * @param entity
      */
-    private static void activateEntity(final Entity entity) {
-        if (MinecraftServer.currentTick > entity.activatedTick) {
+    private static void activateEntity(final Entity entity, final AABB[] bbByType) { // Folia - threaded regions
+        if (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() > entity.activatedTick) { // Folia - threaded regions
             if (entity.defaultActivationState) {
-                entity.activatedTick = MinecraftServer.currentTick;
+                entity.activatedTick = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - threaded regions
                 return;
             }
-            if (entity.activationType.boundingBox.intersects(entity.getBoundingBox())) {
-                entity.activatedTick = MinecraftServer.currentTick;
+            if (bbByType[entity.activationType.ordinal()].intersects(entity.getBoundingBox())) { // Folia - threaded regions
+                entity.activatedTick = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - threaded regions
             }
         }
     }
@@ -195,6 +204,7 @@ public final class ActivationRange {
      */
     public static int checkEntityImmunities(final Entity entity) { // return # of ticks to get immunity
         final SpigotWorldConfig config = entity.level().spigotConfig;
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = entity.level().getCurrentWorldData(); // Folia - threaded regions
         final int inactiveWakeUpImmunity = checkInactiveWakeup(entity);
         if (inactiveWakeUpImmunity > -1) {
             return inactiveWakeUpImmunity;
@@ -202,10 +212,10 @@ public final class ActivationRange {
         if (entity.getRemainingFireTicks() > 0) {
             return 2;
         }
-        if (entity.activatedImmunityTick >= MinecraftServer.currentTick) {
+        if (entity.activatedImmunityTick >= io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick()) { // Folia - threaded regions
             return 1;
         }
-        final long inactiveFor = MinecraftServer.currentTick - entity.activatedTick;
+        final long inactiveFor = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() - entity.activatedTick; // Folia - threaded regions
         if ((entity.activationType != ActivationType.WATER && entity.isInWater() && entity.isPushedByFluid())) {
             return 100;
         }
@@ -302,16 +312,16 @@ public final class ActivationRange {
             return true;
         }
 
-        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick;
+        boolean isActive = entity.activatedTick >= io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - threaded regions
         entity.isTemporarilyActive = false;
 
         // Should this entity tick?
         if (!isActive) {
-            if ((MinecraftServer.currentTick - entity.activatedTick - 1) % 20 == 0) {
+            if ((io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() - entity.activatedTick - 1) % 20 == 0) { // Folia - threaded regions
                 // Check immunities every 20 ticks.
                 final int immunity = checkEntityImmunities(entity);
                 if (immunity >= 0) {
-                    entity.activatedTick = MinecraftServer.currentTick + immunity;
+                    entity.activatedTick = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + immunity; // Folia - threaded regions
                 } else {
                     entity.isTemporarilyActive = true;
                 }
diff --git a/io/papermc/paper/redstone/RedstoneWireTurbo.java b/io/papermc/paper/redstone/RedstoneWireTurbo.java
index ff747a1ecdf3c888bca0d69de4f85dcd810b6139..5a76c93eada8db35b1ddbb562ccfbd2f0d35f0ca 100644
--- a/io/papermc/paper/redstone/RedstoneWireTurbo.java
+++ b/io/papermc/paper/redstone/RedstoneWireTurbo.java
@@ -829,14 +829,14 @@ public final class RedstoneWireTurbo {
         j = getMaxCurrentStrength(upd, j);
         int l = 0;
 
-        wire.shouldSignal = false;
+        io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal = false; // Folia - region threading
         // Unfortunately, World.isBlockIndirectlyGettingPowered is complicated,
         // and I'm not ready to try to replicate even more functionality from
         // elsewhere in Minecraft into this accelerator.  So sadly, we must
         // suffer the performance hit of this very expensive call.  If there
         // is consistency to what this call returns, we may be able to cache it.
         final int k = worldIn.getBestNeighborSignal(upd.self);
-        wire.shouldSignal = true;
+        io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal = true; // Folia - region threading
 
         // The variable 'k' holds the maximum redstone power value of any adjacent blocks.
         // If 'k' has the highest level of all neighbors, then the power level of this
diff --git a/io/papermc/paper/threadedregions/RegionShutdownThread.java b/io/papermc/paper/threadedregions/RegionShutdownThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..bbd14cf34438a9366f5ff29f1acba4282d77d983
--- /dev/null
+++ b/io/papermc/paper/threadedregions/RegionShutdownThread.java
@@ -0,0 +1,226 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.moonrise.common.util.WorldUtil;
+import com.mojang.logging.LogUtils;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import org.slf4j.Logger;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public final class RegionShutdownThread extends ca.spottedleaf.moonrise.common.util.TickThread {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> shuttingDown;
+
+    public RegionShutdownThread(final String name) {
+        super(name);
+        this.setUncaughtExceptionHandler((thread, thr) -> {
+            LOGGER.error("Error shutting down server", thr);
+        });
+    }
+
+    static ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> getRegion() {
+        final Thread currentThread = Thread.currentThread();
+        if (currentThread instanceof RegionShutdownThread shutdownThread) {
+            return shutdownThread.shuttingDown;
+        }
+        return null;
+    }
+
+
+    static RegionizedWorldData getWorldData() {
+        final Thread currentThread = Thread.currentThread();
+        if (currentThread instanceof RegionShutdownThread shutdownThread) {
+            // no fast path for shutting down
+            if (shutdownThread.shuttingDown != null) {
+                return shutdownThread.shuttingDown.getData().world.worldRegionData.get();
+            }
+        }
+        return null;
+    }
+
+    // The region shutdown thread bypasses all tick thread checks, which will allow us to execute global saves
+    // it will not however let us perform arbitrary sync loads, arbitrary world state lookups simply because
+    // the data required to do that is regionised, and we can only access it when we OWN the region, and we do not.
+    // Thus, the only operation that the shutdown thread will perform
+
+    private void saveLevelData(final ServerLevel world) {
+        try {
+            world.saveLevelData(true);
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save level data for " + world.getWorld().getName(), thr);
+        }
+    }
+
+    private void finishTeleportations(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region,
+                                      final ServerLevel world) {
+        try {
+            this.shuttingDown = region;
+            final List<ServerLevel.PendingTeleport> pendingTeleports = world.removeAllRegionTeleports();
+            if (pendingTeleports.isEmpty()) {
+                return;
+            }
+            final ChunkPos center = region.getCenterChunk();
+            LOGGER.info("Completing " + pendingTeleports.size() + " pending teleports in region around chunk " + center + " in world '" + region.regioniser.world.getWorld().getName() + "'");
+            for (final ServerLevel.PendingTeleport pendingTeleport : pendingTeleports) {
+                LOGGER.info("Completing teleportation to target position " + pendingTeleport.to());
+
+                // first, add entities to entity chunk so that they will be saved
+                for (final Entity.EntityTreeNode node : pendingTeleport.rootVehicle().getFullTree()) {
+                    // assume that world and position are set to destination here
+                    node.root.setLevel(world); // in case the pending teleport is from a portal before it finds the exact destination
+                    world.moonrise$getEntityLookup().addEntityForShutdownTeleportComplete(node.root);
+                }
+
+                // then, rebuild the passenger tree so that when saving only the root vehicle will be written - and if
+                // there are any player passengers, that the later player saving will save the tree
+                pendingTeleport.rootVehicle().restore();
+
+                // now we are finished
+                LOGGER.info("Completed teleportation to target position " + pendingTeleport.to());
+            }
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to complete pending teleports", thr);
+        } finally {
+            this.shuttingDown = null;
+        }
+    }
+
+    private void saveRegionChunks(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region,
+                                  final boolean last) {
+        ChunkPos center = null;
+        try {
+            this.shuttingDown = region;
+            center = region.getCenterChunk();
+            LOGGER.info("Saving chunks around region around chunk " + center + " in world '" + region.regioniser.world.getWorld().getName() + "'");
+            region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, true, false, last, false);
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to save chunks for region around chunk " + center + " in world '" + region.regioniser.world.getWorld().getName() + "'", thr);
+        } finally {
+            this.shuttingDown = null;
+        }
+    }
+
+    private void haltChunkSystem(final ServerLevel world) {
+        try {
+            world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(false, true, true, false, false);
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to halt chunk system for world '" + world.getWorld().getName() + "'", thr);
+        }
+    }
+
+    private void closePlayerInventories(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
+        ChunkPos center = null;
+        try {
+            this.shuttingDown = region;
+            center = region.getCenterChunk();
+
+            final RegionizedWorldData worldData = region.regioniser.world.worldRegionData.get();
+
+            for (final ServerPlayer player : worldData.getLocalPlayers()) {
+                try {
+                    // close inventory
+                    if (player.containerMenu != player.inventoryMenu) {
+                        player.closeContainer(InventoryCloseEvent.Reason.DISCONNECT);
+                    }
+
+                    // drop carried item
+                    if (!player.containerMenu.getCarried().isEmpty()) {
+                        ItemStack carried = player.containerMenu.getCarried();
+                        player.containerMenu.setCarried(ItemStack.EMPTY);
+                        player.drop(carried, false);
+                    }
+                } catch (final Throwable thr) {
+                    LOGGER.error("Failed to close player inventory for player: " + player, thr);
+                }
+            }
+        } catch (final Throwable thr) {
+            LOGGER.error("Failed to close player inventories for region around chunk " + center + " in world '" + region.regioniser.world.getWorld().getName() + "'", thr);
+        } finally {
+            this.shuttingDown = null;
+        }
+    }
+
+    @Override
+    public final void run() {
+        // await scheduler termination
+        LOGGER.info("Awaiting scheduler termination for 60s...");
+        if (TickRegions.getScheduler().halt(true, TimeUnit.SECONDS.toNanos(60L))) {
+            LOGGER.info("Scheduler halted");
+        } else {
+            LOGGER.warn("Scheduler did not terminate within 60s, proceeding with shutdown anyways");
+            TickRegions.getScheduler().dumpAliveThreadTraces("Did not shut down in time");
+        }
+
+        MinecraftServer.getServer().stopServer(); // stop part 1: most logic, kicking players, plugins, etc
+        // halt all chunk systems first so that any in-progress chunk generation stops
+        LOGGER.info("Halting chunk systems...");
+        for (final ServerLevel world : MinecraftServer.getServer().getAllLevels()) {
+            try {
+                world.moonrise$getChunkTaskScheduler().halt(false, 0L);
+            } catch (final Throwable throwable) {
+                LOGGER.error("Failed to soft halt chunk system for world '" + world.getWorld().getName() + "'", throwable);
+            }
+        }
+        for (final ServerLevel world : MinecraftServer.getServer().getAllLevels()) {
+            this.haltChunkSystem(world);
+        }
+        LOGGER.info("Halted chunk systems");
+
+        LOGGER.info("Finishing pending teleports...");
+        for (final ServerLevel world : MinecraftServer.getServer().getAllLevels()) {
+            final List<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>>
+                regions = new ArrayList<>();
+            world.regioniser.computeForAllRegionsUnsynchronised(regions::add);
+
+            for (int i = 0, len = regions.size(); i < len; ++i) {
+                this.finishTeleportations(regions.get(i), world);
+            }
+        }
+        LOGGER.info("Finished pending teleports");
+
+        LOGGER.info("Saving all worlds");
+        for (final ServerLevel world : MinecraftServer.getServer().getAllLevels()) {
+            LOGGER.info("Saving world data for world '" + WorldUtil.getWorldName(world) + "'");
+
+            final List<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>>
+                regions = new ArrayList<>();
+            world.regioniser.computeForAllRegionsUnsynchronised(regions::add);
+
+            LOGGER.info("Closing player inventories...");
+            for (int i = 0, len = regions.size(); i < len; ++i) {
+                this.closePlayerInventories(regions.get(i));
+            }
+            LOGGER.info("Closed player inventories");
+
+            LOGGER.info("Saving chunks...");
+            for (int i = 0, len = regions.size(); i < len; ++i) {
+                this.saveRegionChunks(regions.get(i), (i + 1) == len);
+            }
+            LOGGER.info("Saved chunks");
+
+            LOGGER.info("Saving level data...");
+            this.saveLevelData(world);
+            LOGGER.info("Saved level data");
+
+            LOGGER.info("Saved world data for world '" + WorldUtil.getWorldName(world) + "'");
+        }
+        LOGGER.info("Saved all worlds");
+
+        // Note: only save after world data and pending teleportations
+        LOGGER.info("Saving all player data...");
+        MinecraftServer.getServer().getPlayerList().saveAll();
+        LOGGER.info("Saved all player data");
+
+        MinecraftServer.getServer().stopPart2(); // stop part 2: close other resources (io thread, etc)
+        // done, part 2 should call exit()
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/RegionizedData.java b/io/papermc/paper/threadedregions/RegionizedData.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e25ab1c8ae026e51ce4d711c9084fdfbede9856
--- /dev/null
+++ b/io/papermc/paper/threadedregions/RegionizedData.java
@@ -0,0 +1,235 @@
+package io.papermc.paper.threadedregions;
+
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.server.level.ServerLevel;
+import javax.annotation.Nullable;
+import java.util.Objects;
+import java.util.function.Function;
+
+/**
+ * Use to manage data that needs to be regionised.
+ * <p>
+ *     <b>Note:</b> that unlike {@link ThreadLocal}, regionised data is not deleted once the {@code RegionizedData} object is GC'd.
+ *     The data is held in reference to the world it resides in.
+ * </p>
+ * <P>
+ *     <b>Note:</b> Keep in mind that when regionised ticking is disabled, the entire server is considered a single region.
+ *     That is, the data may or may not cross worlds. As such, the {@code RegionizedData} object must be instanced
+ *     per world when appropriate, as it is no longer guaranteed that separate worlds contain separate regions.
+ *     See below for more details on instancing per world.
+ * </P>
+ * <p>
+ *     Regionised data may be <b>world-checked</b>. That is, {@link #get()} may throw an exception if the current
+ *     region's world does not match the {@code RegionizedData}'s world. Consider the usages of {@code RegionizedData} below
+ *     see why the behavior may or may not be desirable:
+ *     <pre>
+ *         {@code
+ *         public class EntityTickList {
+ *             private final List<Entity> entities = new ArrayList<>();
+ *
+ *             public void addEntity(Entity e) {
+ *                 this.entities.add(e);
+ *             }
+ *
+ *             public void removeEntity(Entity e) {
+ *                 this.entities.remove(e);
+ *             }
+ *         }
+ *
+ *         public class World {
+ *
+ *             // callback is left out of this example
+ *             // note: world != null here
+ *             public final RegionizedData<EntityTickList> entityTickLists =
+ *                 new RegionizedData<>(this, () -> new EntityTickList(), ...);
+ *
+ *             public void addTickingEntity(Entity e) {
+ *                 // What we expect here is that this world is the
+ *                 // current ticking region's world.
+ *                 // If that is true, then calling this.entityTickLists.get()
+ *                 // will retrieve the current region's EntityTickList
+ *                 // for this world, which is fine since the current
+ *                 // region is contained within this world.
+ *
+ *                 // But if the current region's world is not this world,
+ *                 // and if the world check is disabled, then we will actually
+ *                 // retrieve _this_ world's EntityTickList for the region,
+ *                 // and NOT the EntityTickList for the region's world.
+ *                 // This is because the RegionizedData object is instantiated
+ *                 // per world.
+ *                 this.entityTickLists.get().addEntity(e);
+ *             }
+ *         }
+ *
+ *         public class TickTimes {
+ *
+ *             private final List<Long> tickTimesNS = new ArrayList<>();
+ *
+ *             public void completeTick(long timeNS) {
+ *                 this.tickTimesNS.add(timeNS);
+ *             }
+ *
+ *             public double getAverageTickLengthMS() {
+ *                 double sum = 0.0;
+ *                 for (long time : tickTimesNS) {
+ *                     sum += (double)time;
+ *                 }
+ *                 return (sum / this.tickTimesNS.size()) / 1.0E6; // 1ms = 1 million ns
+ *             }
+ *         }
+ *
+ *         public class Server {
+ *             public final List<World> worlds = ...;
+ *
+ *             // callback is left out of this example
+ *             // note: world == null here, because this RegionizedData object
+ *             // is not instantiated per world, but rather globally.
+ *             public final RegionizedData<TickTimes> tickTimes =
+ *                  new RegionizedData<>(null, () -> new TickTimes(), ...);
+ *         }
+ *         }
+ *     </pre>
+ *     In general, it is advised that if a RegionizedData object is instantiated <i>per world</i>, that world checking
+ *     is enabled for it by passing the world to the constructor.
+ * </p>
+ */
+public final class RegionizedData<T> {
+
+    private final ServerLevel world;
+    private final Function<TickRegions.TickRegionData, T> initialValueSupplier;
+    private final RegioniserCallback<T> callback;
+
+    /**
+     * Creates a regionised data holder. The provided initial value supplier may not be null, and it must
+     * never produce {@code null} values.
+     * <p>
+     *     Note that the supplier or regioniser callback may be used while the region lock is held, so any blocking
+     *     operations may deadlock the entire server and as such the function should be completely non-blocking
+     *     and must complete in a timely manner.
+     * </p>
+     * <p>
+     *     If the provided world is {@code null}, then the world checks are disabled. The world should only ever
+     *     be {@code null} if the data is specifically not specific to worlds. For example, using {@code null}
+     *     for an entity tick list is invalid since the entities are tied to a world <b>and</b> region,
+     *     however using {@code null} for tasks to run at the end of a tick is valid since the tasks are tied to
+     *     region <b>only</b>.
+     * </p>
+     * @param world The world in which the region data resides.
+     * @param supplier Initial value supplier used to lazy initialise region data.
+     * @param callback Region callback to manage this regionised data.
+     */
+    public RegionizedData(final ServerLevel world, final Function<TickRegions.TickRegionData, T> supplier, final RegioniserCallback<T> callback) {
+        this.world = world;
+        this.initialValueSupplier = Objects.requireNonNull(supplier, "Supplier may not be null.");
+        this.callback = Objects.requireNonNull(callback, "Regioniser callback may not be null.");
+    }
+
+    T createNewValue(final TickRegions.TickRegionData regionData) {
+        return Objects.requireNonNull(this.initialValueSupplier.apply(regionData), "Initial value supplier may not return null");
+    }
+
+    RegioniserCallback<T> getCallback() {
+        return this.callback;
+    }
+
+    /**
+     * Returns the current data type for the current ticking region. If there is no region, returns {@code null}.
+     * @return the current data type for the current ticking region. If there is no region, returns {@code null}.
+     * @throws IllegalStateException If the following are true: The server is in region ticking mode,
+     *                               this {@code RegionizedData}'s world is not {@code null},
+     *                               and the current ticking region's world does not match this {@code RegionizedData}'s world.
+     */
+    public @Nullable T get() {
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+
+        if (region == null) {
+            return null;
+        }
+
+        if (this.world != null && this.world != region.getData().world) {
+            throw new IllegalStateException("World check failed: expected world: " + this.world.getWorld().getKey() + ", region world: " + region.getData().world.getWorld().getKey());
+        }
+
+        return region.getData().getOrCreateRegionizedData(this);
+    }
+
+    /**
+     * Class responsible for handling merge / split requests from the regioniser.
+     * <p>
+     *     It is critical to note that each function is called while holding the region lock.
+     * </p>
+     */
+    public static interface RegioniserCallback<T> {
+
+        /**
+         * Completely merges the data in {@code from} to {@code into}.
+         * <p>
+         *     <b>Calculating Tick Offsets:</b>
+         *     Sometimes data stores absolute tick deadlines, and since regions tick independently, absolute deadlines
+         *     are not comparable across regions. Consider absolute deadlines {@code deadlineFrom, deadlineTo} in
+         *     regions {@code from} and {@code into} respectively. We can calculate the relative deadline for the from
+         *     region with {@code relFrom = deadlineFrom - currentTickFrom}. Then, we can use the same equation for
+         *     computing the absolute deadline in region {@code into} that has the same relative deadline as {@code from}
+         *     as {@code deadlineTo = relFrom + currentTickTo}. By substituting {@code relFrom} as {@code deadlineFrom - currentTickFrom},
+         *     we finally have that {@code deadlineTo = deadlineFrom + (currentTickTo - currentTickFrom)} and
+         *     that we can use an offset {@code fromTickOffset = currentTickTo - currentTickFrom} to calculate
+         *     {@code deadlineTo} as {@code deadlineTo = deadlineFrom + fromTickOffset}.
+         * </p>
+         * <p>
+         *     <b>Critical Notes:</b>
+         *     <li>
+         *         <ul>
+         *             This function is called while the region lock is held, so any blocking operations may
+         *             deadlock the entire server and as such the function should be completely non-blocking and must complete
+         *             in a timely manner.
+         *         </ul>
+         *         <ul>
+         *             This function may not throw any exceptions, or the server will be left in an unrecoverable state.
+         *         </ul>
+         *     </li>
+         * </p>
+         *
+         * @param from The data to merge from.
+         * @param into The data to merge into.
+         * @param fromTickOffset The addend to absolute tick deadlines stored in the {@code from} region to adjust to the into region.
+         */
+        public void merge(final T from, final T into, final long fromTickOffset);
+
+        /**
+         * Splits the data in {@code from} into {@code dataSet}.
+         * <p>
+         *     The chunk coordinate to region section coordinate bit shift amount is provided in {@code chunkToRegionShift}.
+         *     To convert from chunk coordinates to region coordinates and keys, see the code below:
+         *     <pre>
+         *         {@code
+         *         int chunkX = ...;
+         *         int chunkZ = ...;
+         *
+         *         int regionSectionX = chunkX >> chunkToRegionShift;
+         *         int regionSectionZ = chunkZ >> chunkToRegionShift;
+         *         long regionSectionKey = io.papermc.paper.util.CoordinateUtils.getChunkKey(regionSectionX, regionSectionZ);
+         *         }
+         *     </pre>
+         * </p>
+         * <p>
+         *     The {@code regionToData} hashtable provides a lookup from {@code regionSectionKey} (see above) to the
+         *     data that is owned by the region which occupies the region section.
+         * </p>
+         * <p>
+         *     Unlike {@link #merge(Object, Object, long)}, there is no absolute tick offset provided. This is because
+         *     the new regions formed from the split will start at the same tick number, and so no adjustment is required.
+         * </p>
+         *
+         * @param from The data to split from.
+         * @param chunkToRegionShift The signed right-shift value used to convert chunk coordinates into region section coordinates.
+         * @param regionToData Lookup hash table from region section key to .
+         * @param dataSet The data set to split into.
+         */
+        public void split(
+            final T from, final int chunkToRegionShift,
+            final Long2ReferenceOpenHashMap<T> regionToData, final ReferenceOpenHashSet<T> dataSet
+        );
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/RegionizedServer.java b/io/papermc/paper/threadedregions/RegionizedServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3bc39ebe8d2f48d976de9cd4fcae46095523514
--- /dev/null
+++ b/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -0,0 +1,502 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.completable.Completable;
+import ca.spottedleaf.concurrentutil.util.TimeUtil;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketListener;
+import net.minecraft.network.PacketProcessor;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.level.gamerules.GameRules;
+import org.bukkit.Bukkit;
+import org.slf4j.Logger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.BooleanSupplier;
+
+public final class RegionizedServer {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final RegionizedServer INSTANCE = new RegionizedServer();
+
+    public final RegionizedTaskQueue taskQueue = new RegionizedTaskQueue();
+
+    private final CopyOnWriteArrayList<ServerLevel> worlds = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Connection> connections = new CopyOnWriteArrayList<>();
+
+    private final MultiThreadedQueue<Runnable> globalTickQueue = new MultiThreadedQueue<>();
+
+    private final GlobalTickTickHandle tickHandle = new GlobalTickTickHandle(this);
+
+    public final PacketProcessor packetProcessor = new PacketProcessor(null);
+
+    public static RegionizedServer getInstance() {
+        return INSTANCE;
+    }
+
+    public void addConnection(final Connection conn) {
+        this.connections.add(conn);
+    }
+
+    public boolean removeConnection(final Connection conn) {
+        return this.connections.remove(conn);
+    }
+
+    public void addWorld(final ServerLevel world) {
+        this.worlds.add(world);
+    }
+
+    public void init() {
+        // call init event _before_ scheduling anything
+        new RegionizedServerInitEvent().callEvent();
+
+        // now we can schedule
+        this.tickHandle.setInitialStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
+        TickRegions.getScheduler().scheduleRegion(this.tickHandle);
+        TickRegions.start();
+    }
+
+    public void invalidateStatus() {
+        this.lastServerStatus = 0L;
+    }
+
+    public void addTaskWithoutNotify(final Runnable run) {
+        this.globalTickQueue.add(run);
+    }
+
+    public void addTask(final Runnable run) {
+        this.addTaskWithoutNotify(run);
+        this.notifyTasks();
+    }
+
+    public void notifyTasks() {
+        TickRegions.getScheduler().setHasTasks(this.tickHandle);
+    }
+
+    private boolean hasAnyGlobalChunkTasks() {
+        for (final ServerLevel world : this.worlds) {
+            if (world.taskQueueRegionData.hasGlobalChunkTasks()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public <T extends PacketListener> void schedulePacket(final T packetListener, final Packet<T> packet) {
+        if (this.packetProcessor.scheduleIfPossible(packetListener, packet)) {
+            this.notifyTasks();
+        }
+    }
+
+    public void blockOn(final Runnable run) {
+        if (isGlobalTickThread()) {
+            run.run();
+            return;
+        }
+        Completable.suppliedAsync(() -> {
+            run.run();
+            return null;
+        }, this::addTask).join();
+        return;
+    }
+
+    /**
+     * Returns the current tick of the region ticking.
+     * @throws IllegalStateException If there is no current region.
+     */
+    public static long getCurrentTick() throws IllegalStateException {
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            if (TickThread.isShutdownThread()) {
+                return 0L;
+            }
+            throw new IllegalStateException("No currently ticking region");
+        }
+        return region.getData().getCurrentTick();
+    }
+
+    public static boolean isGlobalTickThread() {
+        return INSTANCE.tickHandle == TickRegionScheduler.getCurrentTickingTask();
+    }
+
+    public static void ensureGlobalTickThread(final String reason) {
+        if (!isGlobalTickThread()) {
+            throw new IllegalStateException(reason);
+        }
+    }
+
+    public static TickRegionScheduler.RegionScheduleHandle getGlobalTickData() {
+        return INSTANCE.tickHandle;
+    }
+
+    private static final class GlobalTickTickHandle extends TickRegionScheduler.RegionScheduleHandle {
+
+        private final RegionizedServer server;
+
+        private final AtomicBoolean scheduled = new AtomicBoolean();
+        private final AtomicBoolean ticking = new AtomicBoolean();
+
+        public GlobalTickTickHandle(final RegionizedServer server) {
+            super(null, TimeUtil.DEADLINE_NOT_SET);
+            this.server = server;
+        }
+
+        /**
+         * Only valid to call BEFORE scheduled!!!!
+         */
+        final void setInitialStart(final long start) {
+            if (this.scheduled.getAndSet(true)) {
+                throw new IllegalStateException("Double scheduling global tick");
+            }
+            this.updateScheduledStart(start);
+        }
+
+        @Override
+        protected boolean tryMarkTicking() {
+            return !this.ticking.getAndSet(true);
+        }
+
+        @Override
+        protected boolean markNotTicking() {
+            return this.ticking.getAndSet(false);
+        }
+
+        @Override
+        protected void tickRegion(final int tickCount, final long startTime, final long scheduledEnd) {
+            this.drainTasks();
+            this.server.globalTick(tickCount);
+        }
+
+        private void drainTasks() {
+            while (this.runOneTask() || this.runOnePacketTask());
+        }
+
+        private boolean runOneTask() {
+            final Runnable run = this.server.globalTickQueue.poll();
+            if (run == null) {
+                return false;
+            }
+
+            // TODO try catch?
+            run.run();
+
+            return true;
+        }
+
+        private boolean runOnePacketTask() {
+            return this.server.packetProcessor.executeSinglePacket();
+        }
+
+        private boolean runGlobalTask() {
+            boolean ret = false;
+            for (final ServerLevel world : this.server.worlds) {
+                ret |= world.taskQueueRegionData.executeGlobalChunkTask();
+            }
+            return ret;
+        }
+
+        @Override
+        protected void runRegionTasks(final BooleanSupplier canContinue) {
+            do {
+                if (!this.runOneTask() && !this.runOnePacketTask() && !this.runGlobalTask()) {
+                    return;
+                }
+            } while (canContinue.getAsBoolean());
+        }
+
+        @Override
+        protected boolean hasIntermediateTasks() {
+            return !this.server.globalTickQueue.isEmpty() || this.server.packetProcessor.hasPackets() || this.server.hasAnyGlobalChunkTasks();
+        }
+    }
+
+    private long lastServerStatus;
+    private long tickCount;
+
+    /*
+    private final java.util.Random random = new java.util.Random(4L);
+    private final List<io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.SingleUserAreaMap<Void>> walkers =
+        new java.util.ArrayList<>();
+    static final int PLAYERS = 500;
+    static final int RAD_BLOCKS = 1000;
+    static final int RAD = RAD_BLOCKS >> 4;
+    static final int RAD_BIG_BLOCKS = 100_000;
+    static final int RAD_BIG = RAD_BIG_BLOCKS >> 4;
+    static final int VD = 4 + 12;
+    static final int BIG_PLAYERS = 250;
+    static final double WALK_CHANCE = 0.3;
+    static final double TP_CHANCE = 0.2;
+    static final double TASK_CHANCE = 0.2;
+
+    private ServerLevel getWorld() {
+        return this.worlds.get(0);
+    }
+
+    private void init2() {
+        for (int i = 0; i < PLAYERS; ++i) {
+            int rad = i < BIG_PLAYERS ? RAD_BIG : RAD;
+            int posX = this.random.nextInt(-rad, rad + 1);
+            int posZ = this.random.nextInt(-rad, rad + 1);
+
+            io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.SingleUserAreaMap<Void> map = new io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.SingleUserAreaMap<>(null) {
+                @Override
+                protected void addCallback(Void parameter, int chunkX, int chunkZ) {
+                    ServerLevel world = RegionizedServer.this.getWorld();
+                    if (RegionizedServer.this.random.nextDouble() <= TASK_CHANCE) {
+                        RegionizedServer.this.taskQueue.queueChunkTask(world, chunkX, chunkZ, () -> {
+                            RegionizedServer.this.taskQueue.queueChunkTask(world, chunkX, chunkZ, () -> {});
+                        });
+                    }
+                    world.chunkTaskScheduler.chunkHolderManager.addTicketAtLevel(
+                        net.minecraft.server.level.TicketType.PLAYER, chunkX, chunkZ, io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, new net.minecraft.world.level.ChunkPos(posX, posZ)
+                    );
+                }
+
+                @Override
+                protected void removeCallback(Void parameter, int chunkX, int chunkZ) {
+                    ServerLevel world = RegionizedServer.this.getWorld();
+                    if (RegionizedServer.this.random.nextDouble() <= TASK_CHANCE) {
+                        RegionizedServer.this.taskQueue.queueChunkTask(world, chunkX, chunkZ, () -> {
+                            RegionizedServer.this.taskQueue.queueChunkTask(world, chunkX, chunkZ, () -> {});
+                        });
+                    }
+                    world.chunkTaskScheduler.chunkHolderManager.removeTicketAtLevel(
+                        net.minecraft.server.level.TicketType.PLAYER, chunkX, chunkZ, io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, new net.minecraft.world.level.ChunkPos(posX, posZ)
+                    );
+                }
+            };
+
+            map.add(posX, posZ, VD);
+
+            walkers.add(map);
+        }
+    }
+
+    private void randomWalk() {
+        if (this.walkers.isEmpty()) {
+            this.init2();
+            return;
+        }
+
+        for (int i = 0; i < PLAYERS; ++i) {
+            if (this.random.nextDouble() > WALK_CHANCE) {
+                continue;
+            }
+
+            io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.SingleUserAreaMap<Void> map = this.walkers.get(i);
+
+            int updateX = this.random.nextInt(-1, 2);
+            int updateZ = this.random.nextInt(-1, 2);
+
+            map.update(map.lastChunkX + updateX, map.lastChunkZ + updateZ, VD);
+        }
+
+        for (int i = 0; i < PLAYERS; ++i) {
+            if (random.nextDouble() >= TP_CHANCE) {
+                continue;
+            }
+
+            int rad = i < BIG_PLAYERS ? RAD_BIG : RAD;
+            int posX = random.nextInt(-rad, rad + 1);
+            int posZ = random.nextInt(-rad, rad + 1);
+
+            io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader.SingleUserAreaMap<Void> map = walkers.get(i);
+
+            map.update(posX, posZ, VD);
+        }
+    }
+     */
+
+    private void globalTick(final int tickCount) {
+        /*
+        if (false) {
+            io.papermc.paper.threadedregions.ThreadedTicketLevelPropagator.main(null);
+        }
+        this.randomWalk();
+         */
+        ++this.tickCount;
+        // expire invalid click command callbacks
+        io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.ADVENTURE_CLICK_MANAGER.handleQueue((int)this.tickCount); // Paper // Folia - region threading - moved to global tick
+        io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue((int)this.tickCount); // Paper // Folia - region threading - moved to global tick
+
+        // scheduler
+        ((FoliaGlobalRegionScheduler)Bukkit.getGlobalRegionScheduler()).tick();
+
+        // commands
+        ((DedicatedServer)MinecraftServer.getServer()).handleConsoleInputs();
+
+        // needs
+        // player ping sample
+        // world global tick
+        // connection tick
+
+        // tick player ping sample
+        this.tickPlayerSample();
+
+        // tick worlds
+        for (final ServerLevel world : this.worlds) {
+            this.globalTick(world, tickCount);
+        }
+
+        // tick connections
+        this.tickConnections();
+
+        // player list
+        MinecraftServer.getServer().getPlayerList().tick();
+    }
+
+    private void tickPlayerSample() {
+        final MinecraftServer mcServer = MinecraftServer.getServer();
+
+        final long currtime = System.nanoTime();
+
+        // player ping sample
+        // copied from MinecraftServer#tickServer
+        // note: we need to reorder setPlayers to be the last operation it does, rather than the first to avoid publishing
+        // an uncomplete status
+        if (currtime - this.lastServerStatus >= MinecraftServer.STATUS_EXPIRE_TIME_NANOS) {
+            this.lastServerStatus = currtime;
+            mcServer.rebuildServerStatus();
+        }
+    }
+
+    public static boolean isNotOwnedByGlobalRegion(final Connection conn) {
+        final PacketListener packetListener = conn.getPacketListener();
+
+        if (packetListener instanceof ServerGamePacketListenerImpl gamePacketListener) {
+            return !gamePacketListener.waitingForSwitchToConfig;
+        }
+
+        if (conn.getPacketListener() instanceof net.minecraft.server.network.ServerConfigurationPacketListenerImpl configurationPacketListener) {
+            return configurationPacketListener.switchToMain != null;
+        }
+
+        return false;
+    }
+
+    private void tickConnections() {
+        final List<Connection> connections = new ArrayList<>(this.connections);
+        Collections.shuffle(connections); // shuffle to prevent people from "gaming" the server by re-logging
+        for (final Connection conn : connections) {
+            if (!conn.becomeActive()) {
+                continue;
+            }
+
+            if (isNotOwnedByGlobalRegion(conn)) {
+                // we actually require that the owning regions remove the connection for us, as it is possible
+                // that ownership is transferred back to us
+                continue;
+            }
+
+            if (!conn.isConnected()) {
+                this.removeConnection(conn);
+                conn.handleDisconnection();
+                continue;
+            }
+
+            try {
+                conn.tick();
+            } catch (final Exception exception) {
+                if (conn.isMemoryConnection()) {
+                    throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                }
+
+                LOGGER.warn("Failed to handle packet for {}", conn.getLoggableAddress(MinecraftServer.getServer().logIPs()), exception);
+                MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                conn.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                    conn.disconnect(ichatmutablecomponent);
+                }));
+                conn.setReadOnly();
+                continue;
+            }
+        }
+    }
+
+    // A global tick only updates things like weather / worldborder, basically anything in the world that is
+    // NOT tied to a specific region, but rather shared amongst all of them.
+    private void globalTick(final ServerLevel world, final int tickCount) {
+        // needs
+        // worldborder tick
+        // advancing the weather cycle
+        // sleep status thing
+        // updating sky brightness
+        // time ticking (game time + daylight), plus PrimayLevelDat#getScheduledEvents ticking
+
+        // Typically, we expect there to be a running region to drain a world's global chunk tasks. However,
+        // this may not be the case - and thus, only the global tick thread can do anything.
+        world.taskQueueRegionData.drainGlobalChunkTasks();
+
+        // worldborder tick
+        this.tickWorldBorder(world);
+
+        // weather cycle
+        this.advanceWeatherCycle(world);
+
+        // sleep status
+        this.checkNightSkip(world);
+
+        // update raids
+        this.updateRaids(world);
+
+        // sky brightness
+        this.updateSkyBrightness(world);
+
+        // time ticking (TODO API synchronisation?)
+        this.tickTime(world, tickCount);
+
+        world.updateTickData();
+
+        world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // required to eventually process ticket updates
+    }
+
+    private void updateRaids(final ServerLevel world) {
+        world.getRaids().globalTick();
+    }
+
+    private void checkNightSkip(final ServerLevel world) {
+        world.tickSleep();
+    }
+
+    private void advanceWeatherCycle(final ServerLevel world) {
+        world.advanceWeatherCycle();
+    }
+
+    private void updateSkyBrightness(final ServerLevel world) {
+        world.updateSkyBrightness();
+    }
+
+    private void tickWorldBorder(final ServerLevel world) {
+        world.getWorldBorder().tick();
+    }
+
+    private void tickTime(final ServerLevel world, final int tickCount) {
+        if (world.tickTime) {
+            if (world.getGameRules().get(GameRules.ADVANCE_TIME)) {
+                world.setDayTime(world.levelData.getDayTime() + (long)tickCount);
+            }
+            world.serverLevelData.setGameTime(world.serverLevelData.getGameTime() + (long)tickCount);
+        }
+    }
+
+    public static final record WorldLevelData(ServerLevel world, long nonRedstoneGameTime, long dayTime) {
+
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/RegionizedTaskQueue.java b/io/papermc/paper/threadedregions/RegionizedTaskQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..40ee051e2267cc497232ea4103e06616995a2f10
--- /dev/null
+++ b/io/papermc/paper/threadedregions/RegionizedTaskQueue.java
@@ -0,0 +1,847 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import ca.spottedleaf.concurrentutil.executor.PrioritisedExecutor;
+import ca.spottedleaf.concurrentutil.executor.PrioritisedExecutor.PriorityState;
+import ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.util.Priority;
+import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
+import ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceMap;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayDeque;
+import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicLong;
+
+public final class RegionizedTaskQueue {
+
+    private static final TicketType<Long> TASK_QUEUE_TICKET = ChunkSystemTicketType.create("task_queue_ticket", Long::compareTo);
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                               final Runnable run) {
+        return this.createChunkTask(world, chunkX, chunkZ, run, Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createChunkTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                               final Runnable run, final Priority priority) {
+        return new PrioritisedQueue.ChunkBasedPriorityTask(world.taskQueueRegionData, chunkX, chunkZ, true, run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createTickTaskQueue(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                                   final Runnable run) {
+        return this.createTickTaskQueue(world, chunkX, chunkZ, run, Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask createTickTaskQueue(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                                   final Runnable run, final Priority priority) {
+        return new PrioritisedQueue.ChunkBasedPriorityTask(world.taskQueueRegionData, chunkX, chunkZ, false, run, priority);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask queueChunkTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                              final Runnable run) {
+        return this.queueChunkTask(world, chunkX, chunkZ, run, Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask queueChunkTask(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                              final Runnable run, final Priority priority) {
+        final PrioritisedExecutor.PrioritisedTask ret = this.createChunkTask(world, chunkX, chunkZ, run, priority);
+
+        ret.queue();
+
+        return ret;
+    }
+
+    public PrioritisedExecutor.PrioritisedTask queueTickTaskQueue(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                                  final Runnable run) {
+        return this.queueTickTaskQueue(world, chunkX, chunkZ, run, Priority.NORMAL);
+    }
+
+    public PrioritisedExecutor.PrioritisedTask queueTickTaskQueue(final ServerLevel world, final int chunkX, final int chunkZ,
+                                                                  final Runnable run, final Priority priority) {
+        final PrioritisedExecutor.PrioritisedTask ret = this.createTickTaskQueue(world, chunkX, chunkZ, run, priority);
+
+        ret.queue();
+
+        return ret;
+    }
+
+    public static final class WorldRegionTaskData {
+        private final ServerLevel world;
+        private final MultiThreadedQueue<Runnable> globalChunkTask = new MultiThreadedQueue<>();
+        private final ConcurrentLong2ReferenceChainedHashTable<ReferenceCountData> referenceCounters = new ConcurrentLong2ReferenceChainedHashTable<>();
+
+        public WorldRegionTaskData(final ServerLevel world) {
+            this.world = world;
+        }
+
+        public boolean hasGlobalChunkTasks() {
+            return !this.globalChunkTask.isEmpty();
+        }
+
+        public boolean executeGlobalChunkTask() {
+            final Runnable run = this.globalChunkTask.poll();
+            if (run != null) {
+                run.run();
+                return true;
+            }
+            return false;
+        }
+
+        public void drainGlobalChunkTasks() {
+            while (this.executeGlobalChunkTask());
+        }
+
+        public void pushGlobalChunkTask(final Runnable run) {
+            this.globalChunkTask.add(run);
+            RegionizedServer.getInstance().notifyTasks();
+        }
+
+        private PrioritisedQueue getQueue(final boolean synchronise, final int chunkX, final int chunkZ, final boolean isChunkTask) {
+            final ThreadedRegionizer<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> regioniser = this.world.regioniser;
+            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region
+                = synchronise ? regioniser.getRegionAtSynchronised(chunkX, chunkZ) : regioniser.getRegionAtUnsynchronised(chunkX, chunkZ);
+            if (region == null) {
+                return null;
+            }
+            final RegionTaskQueueData taskQueueData = region.getData().getTaskQueueData();
+            return (isChunkTask ? taskQueueData.chunkQueue : taskQueueData.tickTaskQueue);
+        }
+
+        private void removeTicket(final long coord, final long id) {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                TASK_QUEUE_TICKET, coord, ChunkHolderManager.MAX_TICKET_LEVEL, Long.valueOf(id)
+            );
+        }
+
+        private void addTicket(final long coord, final long id) {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                TASK_QUEUE_TICKET, coord, ChunkHolderManager.MAX_TICKET_LEVEL, Long.valueOf(id)
+            );
+        }
+
+        private void processTicketUpdates(final long coord) {
+            this.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(CoordinateUtils.getChunkX(coord), CoordinateUtils.getChunkZ(coord));
+        }
+
+        // note: only call on acquired referenceCountData
+        private void ensureTicketAdded(final long coord, final ReferenceCountData referenceCountData) {
+            if (!referenceCountData.addedTicket) {
+                // fine if multiple threads do this, no removeTicket may be called for this coord due to reference count inc
+                this.addTicket(coord, referenceCountData.id);
+                this.processTicketUpdates(coord);
+                referenceCountData.addedTicket = true;
+            }
+        }
+
+        private void decrementReference(final ReferenceCountData referenceCountData, final long coord) {
+            if (!referenceCountData.decreaseReferenceCount()) {
+                return;
+            } // else: need to remove ticket
+
+            final ReferenceCountData[] toRemoveTicket = new ReferenceCountData[1];
+
+            // note: it is possible that another thread increments and then removes the reference before we can, so
+            //       use ifPresent
+            this.referenceCounters.computeIfPresent(coord, (final long keyInMap, final ReferenceCountData valueInMap) -> {
+                if (valueInMap.referenceCount.get() != 0L) {
+                    return valueInMap;
+                }
+
+                // note: valueInMap may not be referenceCountData
+                toRemoveTicket[0] = valueInMap;
+
+                return null;
+            });
+
+            if (toRemoveTicket[0] != null) {
+                this.removeTicket(coord, toRemoveTicket[0].id);
+            }
+        }
+
+        private ReferenceCountData incrementReference(final long coord) {
+            ReferenceCountData referenceCountData = this.referenceCounters.get(coord);
+
+            if (referenceCountData != null && referenceCountData.addCount()) {
+                this.ensureTicketAdded(coord, referenceCountData);
+                return referenceCountData;
+            }
+
+            referenceCountData = this.referenceCounters.compute(coord, (final long keyInMap, final ReferenceCountData valueInMap) -> {
+                if (valueInMap == null) {
+                    // sets reference count to 1
+                    return new ReferenceCountData();
+                }
+                // OK if we add from 0, the remove call will use compute() and catch this race condition
+                valueInMap.referenceCount.getAndIncrement();
+
+                return valueInMap;
+            });
+
+            this.ensureTicketAdded(coord, referenceCountData);
+
+            return referenceCountData;
+        }
+    }
+
+    private static final class ReferenceCountData {
+
+        private static final AtomicLong ID_GENERATOR = new AtomicLong();
+
+        private final long id = ID_GENERATOR.getAndIncrement();
+
+        public final AtomicLong referenceCount = new AtomicLong(1L);
+        public volatile boolean addedTicket;
+
+        // returns false if reference count is 0, otherwise increments ref count
+        public boolean addCount() {
+            int failures = 0;
+            for (long curr = this.referenceCount.get();;) {
+                for (int i = 0; i < failures; ++i) {
+                    Thread.onSpinWait();
+                }
+
+                if (curr == 0L) {
+                    return false;
+                }
+
+                if (curr == (curr = this.referenceCount.compareAndExchange(curr, curr + 1L))) {
+                    return true;
+                }
+
+                ++failures;
+            }
+        }
+
+        // returns true if new reference count is 0
+        public boolean decreaseReferenceCount() {
+            final long res = this.referenceCount.decrementAndGet();
+            if (res >= 0L) {
+                return res == 0L;
+            } else {
+                throw new IllegalStateException("Negative reference count");
+            }
+        }
+    }
+
+    public static final class RegionTaskQueueData {
+        private final PrioritisedQueue tickTaskQueue = new PrioritisedQueue(this);
+        private final PrioritisedQueue chunkQueue = new PrioritisedQueue(this);
+        private final WorldRegionTaskData worldRegionTaskData;
+        private final TickRegions.TickRegionData regionData;
+
+        public RegionTaskQueueData(final WorldRegionTaskData worldRegionTaskData, final TickRegions.TickRegionData regionData) {
+            this.worldRegionTaskData = worldRegionTaskData;
+            this.regionData = regionData;
+        }
+
+        void mergeInto(final RegionTaskQueueData into) {
+            this.tickTaskQueue.mergeInto(into.tickTaskQueue);
+            this.chunkQueue.mergeInto(into.chunkQueue);
+        }
+
+        public boolean executeTickTask() {
+            return this.tickTaskQueue.executeTask();
+        }
+
+        public boolean executeChunkTask() {
+            return this.worldRegionTaskData.executeGlobalChunkTask() || this.chunkQueue.executeTask();
+        }
+
+        void split(final ThreadedRegionizer<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> regioniser,
+                   final Long2ReferenceOpenHashMap<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> into) {
+            this.tickTaskQueue.split(
+                false, regioniser, into
+            );
+            this.chunkQueue.split(
+                true, regioniser, into
+            );
+        }
+
+        public void drainTasks() {
+            final PrioritisedQueue tickTaskQueue = this.tickTaskQueue;
+            final PrioritisedQueue chunkTaskQueue = this.chunkQueue;
+
+            int allowedTickTasks = tickTaskQueue.getScheduledTasks();
+            int allowedChunkTasks = chunkTaskQueue.getScheduledTasks();
+
+            boolean executeTickTasks = allowedTickTasks > 0;
+            boolean executeChunkTasks = allowedChunkTasks > 0;
+            boolean executeGlobalTasks = true;
+
+            do {
+                executeTickTasks = executeTickTasks && allowedTickTasks-- > 0 && tickTaskQueue.executeTask();
+                executeChunkTasks = executeChunkTasks && allowedChunkTasks-- > 0 && chunkTaskQueue.executeTask();
+                executeGlobalTasks = executeGlobalTasks && this.worldRegionTaskData.executeGlobalChunkTask();
+            } while (executeTickTasks | executeChunkTasks | executeGlobalTasks);
+
+            if (allowedChunkTasks > 0) {
+                // if we executed chunk tasks, we should try to process ticket updates for full status changes
+                this.worldRegionTaskData.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
+            }
+        }
+
+        public boolean hasTasks() {
+            return !this.tickTaskQueue.isEmpty() || !this.chunkQueue.isEmpty();
+        }
+    }
+
+    static final class PrioritisedQueue {
+        private final ArrayDeque<ChunkBasedPriorityTask>[] queues = new ArrayDeque[Priority.TOTAL_SCHEDULABLE_PRIORITIES]; {
+            for (int i = 0; i < Priority.TOTAL_SCHEDULABLE_PRIORITIES; ++i) {
+                this.queues[i] = new ArrayDeque<>();
+            }
+        }
+
+        private final RegionTaskQueueData queue;
+
+        private PrioritisedQueue(final RegionTaskQueueData queue) {
+            this.queue = queue;
+        }
+
+        private boolean isDestroyed;
+
+        public int getScheduledTasks() {
+            synchronized (this) {
+                int ret = 0;
+
+                for (final ArrayDeque<ChunkBasedPriorityTask> queue : this.queues) {
+                    ret += queue.size();
+                }
+
+                return ret;
+            }
+        }
+
+        public boolean isEmpty() {
+            final ArrayDeque<ChunkBasedPriorityTask>[] queues = this.queues;
+            final int max = Priority.IDLE.priority;
+            synchronized (this) {
+                for (int i = 0; i <= max; ++i) {
+                    if (!queues[i].isEmpty()) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        }
+
+        public void mergeInto(final PrioritisedQueue target) {
+            synchronized (this) {
+                this.isDestroyed = true;
+                mergeInto(target, this.queues);
+            }
+        }
+
+        private static void mergeInto(final PrioritisedQueue target, final ArrayDeque<ChunkBasedPriorityTask>[] thisQueues) {
+            synchronized (target) {
+                final ArrayDeque<ChunkBasedPriorityTask>[] otherQueues = target.queues;
+                for (int i = 0; i < thisQueues.length; ++i) {
+                    final ArrayDeque<ChunkBasedPriorityTask> fromQ = thisQueues[i];
+                    final ArrayDeque<ChunkBasedPriorityTask> intoQ = otherQueues[i];
+
+                    // it is possible for another thread to queue tasks into the target queue before we do
+                    // since only the ticking region can poll, we don't have to worry about it when they are being queued -
+                    // but when we are merging, we need to ensure order is maintained (notwithstanding priority changes)
+                    // we can ensure order is maintained by adding all of the tasks from the fromQ into the intoQ at the
+                    // front of the queue, but we need to use descending iterator to ensure we do not reverse
+                    // the order of elements from fromQ
+                    for (final Iterator<ChunkBasedPriorityTask> iterator = fromQ.descendingIterator(); iterator.hasNext();) {
+                        intoQ.addFirst(iterator.next());
+                    }
+                }
+            }
+        }
+
+        // into is a map of section coordinate to region
+        public void split(final boolean isChunkData,
+                          final ThreadedRegionizer<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> regioniser,
+                          final Long2ReferenceOpenHashMap<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> into) {
+            final Reference2ReferenceOpenHashMap<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, ArrayDeque<ChunkBasedPriorityTask>[]>
+                split = new Reference2ReferenceOpenHashMap<>();
+            final int shift = regioniser.sectionChunkShift;
+            synchronized (this) {
+                this.isDestroyed = true;
+                // like mergeTarget, we need to be careful about insertion order so we can maintain order when splitting
+
+                // first, build the targets
+                final ArrayDeque<ChunkBasedPriorityTask>[] thisQueues = this.queues;
+                for (int i = 0; i < thisQueues.length; ++i) {
+                    final ArrayDeque<ChunkBasedPriorityTask> fromQ = thisQueues[i];
+
+                    for (final ChunkBasedPriorityTask task : fromQ) {
+                        final int sectionX = task.chunkX >> shift;
+                        final int sectionZ = task.chunkZ >> shift;
+                        final long sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+                        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
+                            region = into.get(sectionKey);
+                        if (region == null) {
+                            throw new IllegalStateException();
+                        }
+
+                        split.computeIfAbsent(region, (keyInMap) -> {
+                            final ArrayDeque<ChunkBasedPriorityTask>[] ret = new ArrayDeque[Priority.TOTAL_SCHEDULABLE_PRIORITIES];
+
+                            for (int k = 0; k < ret.length; ++k) {
+                                ret[k] = new ArrayDeque<>();
+                            }
+
+                            return ret;
+                        })[i].add(task);
+                    }
+                }
+
+                // merge the targets into their queues
+                for (final Iterator<Reference2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, ArrayDeque<ChunkBasedPriorityTask>[]>>
+                     iterator = split.reference2ReferenceEntrySet().fastIterator();
+                     iterator.hasNext();) {
+                    final Reference2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, ArrayDeque<ChunkBasedPriorityTask>[]>
+                        entry = iterator.next();
+                    final RegionTaskQueueData taskQueueData = entry.getKey().getData().getTaskQueueData();
+                    mergeInto(isChunkData ? taskQueueData.chunkQueue : taskQueueData.tickTaskQueue, entry.getValue());
+                }
+            }
+        }
+
+        /**
+         * returns null if the task cannot be scheduled, returns false if this task queue is dead, and returns true
+         * if the task was added
+         */
+        private Boolean tryPush(final ChunkBasedPriorityTask task) {
+            final ArrayDeque<ChunkBasedPriorityTask>[] queues = this.queues;
+            synchronized (this) {
+                final Priority priority = task.getPriority();
+                if (priority == Priority.COMPLETING) {
+                    return null;
+                }
+                if (this.isDestroyed) {
+                    return Boolean.FALSE;
+                }
+                queues[priority.priority].addLast(task);
+                return Boolean.TRUE;
+            }
+        }
+
+        private boolean executeTask() {
+            final ArrayDeque<ChunkBasedPriorityTask>[] queues = this.queues;
+            final int max = Priority.IDLE.priority;
+            ChunkBasedPriorityTask task = null;
+            ReferenceCountData referenceCounter = null;
+            synchronized (this) {
+                if (this.isDestroyed) {
+                    throw new IllegalStateException("Attempting to poll from dead queue");
+                }
+
+                search_loop:
+                for (int i = 0; i <= max; ++i) {
+                    final ArrayDeque<ChunkBasedPriorityTask> queue = queues[i];
+                    while ((task = queue.pollFirst()) != null) {
+                        if ((referenceCounter = task.trySetCompleting(i)) != null) {
+                            break search_loop;
+                        }
+                    }
+                }
+            }
+
+            if (task == null) {
+                return false;
+            }
+
+            try {
+                task.executeInternal();
+            } finally {
+                task.world.decrementReference(referenceCounter, task.sectionLowerLeftCoord);
+            }
+
+            return true;
+        }
+
+        private static final class ChunkBasedPriorityTask implements PrioritisedExecutor.PrioritisedTask {
+
+            private static final ReferenceCountData REFERENCE_COUNTER_NOT_SET = new ReferenceCountData();
+            static {
+                REFERENCE_COUNTER_NOT_SET.referenceCount.set((long)Integer.MIN_VALUE);
+            }
+
+            private final WorldRegionTaskData world;
+            private final int chunkX;
+            private final int chunkZ;
+            private final long sectionLowerLeftCoord; // chunk coordinate
+            private final boolean isChunkTask;
+
+            private volatile ReferenceCountData referenceCounter;
+            private static final VarHandle REFERENCE_COUNTER_HANDLE = ConcurrentUtil.getVarHandle(ChunkBasedPriorityTask.class, "referenceCounter", ReferenceCountData.class);
+            private Runnable run;
+            private volatile Priority priority;
+            private static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(ChunkBasedPriorityTask.class, "priority", Priority.class);
+
+            ChunkBasedPriorityTask(final WorldRegionTaskData world, final int chunkX, final int chunkZ, final boolean isChunkTask,
+                                   final Runnable run, final Priority priority) {
+                this.world = world;
+                this.chunkX = chunkX;
+                this.chunkZ = chunkZ;
+                this.isChunkTask = isChunkTask;
+                this.run = run;
+                this.setReferenceCounterPlain(REFERENCE_COUNTER_NOT_SET);
+                this.setPriorityPlain(priority);
+
+                final int regionShift = world.world.regioniser.sectionChunkShift;
+                final int regionMask = (1 << regionShift) - 1;
+
+                this.sectionLowerLeftCoord = CoordinateUtils.getChunkKey(chunkX & ~regionMask, chunkZ & ~regionMask);
+            }
+
+            private Priority getPriorityVolatile() {
+                return (Priority)PRIORITY_HANDLE.getVolatile(this);
+            }
+
+            private void setPriorityPlain(final Priority priority) {
+                PRIORITY_HANDLE.set(this, priority);
+            }
+
+            private void setPriorityVolatile(final Priority priority) {
+                PRIORITY_HANDLE.setVolatile(this, priority);
+            }
+
+            private Priority compareAndExchangePriority(final Priority expect, final Priority update) {
+                return (Priority)PRIORITY_HANDLE.compareAndExchange(this, expect, update);
+            }
+
+            private void setReferenceCounterPlain(final ReferenceCountData value) {
+                REFERENCE_COUNTER_HANDLE.set(this, value);
+            }
+
+            private ReferenceCountData getReferenceCounterVolatile() {
+                return (ReferenceCountData)REFERENCE_COUNTER_HANDLE.get(this);
+            }
+
+            private ReferenceCountData compareAndExchangeReferenceCounter(final ReferenceCountData expect, final ReferenceCountData update) {
+                return (ReferenceCountData)REFERENCE_COUNTER_HANDLE.compareAndExchange(this, expect, update);
+            }
+
+            private void executeInternal() {
+                try {
+                    this.run.run();
+                } finally {
+                    this.run = null;
+                }
+            }
+
+            private void cancelInternal() {
+                this.run = null;
+            }
+
+            private boolean tryComplete(final boolean cancel) {
+                int failures = 0;
+                for (ReferenceCountData curr = this.getReferenceCounterVolatile();;) {
+                    if (curr == null) {
+                        return false;
+                    }
+
+                    for (int i = 0; i < failures; ++i) {
+                        ConcurrentUtil.backoff();
+                    }
+
+                    if (curr != (curr = this.compareAndExchangeReferenceCounter(curr, null))) {
+                        ++failures;
+                        continue;
+                    }
+
+                    // we have the reference count, we win no matter what.
+                    this.setPriorityVolatile(Priority.COMPLETING);
+
+                    try {
+                        if (cancel) {
+                            this.cancelInternal();
+                        } else {
+                            this.executeInternal();
+                        }
+                    } finally {
+                        if (curr != REFERENCE_COUNTER_NOT_SET) {
+                            this.world.decrementReference(curr, this.sectionLowerLeftCoord);
+                        }
+                    }
+
+                    return true;
+                }
+            }
+
+            @Override
+            public PrioritisedExecutor getExecutor() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isQueued() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean queue() {
+                if (this.getReferenceCounterVolatile() != REFERENCE_COUNTER_NOT_SET) {
+                    return false;
+                }
+
+                final ReferenceCountData referenceCounter = this.world.incrementReference(this.sectionLowerLeftCoord);
+                if (this.compareAndExchangeReferenceCounter(REFERENCE_COUNTER_NOT_SET, referenceCounter) != REFERENCE_COUNTER_NOT_SET) {
+                    // we don't expect race conditions here, so it is OK if we have to needlessly reference count
+                    this.world.decrementReference(referenceCounter, this.sectionLowerLeftCoord);
+                    return false;
+                }
+
+                boolean synchronise = false;
+                for (;;) {
+                    // we need to synchronise for repeated operations so that we guarantee that we do not retrieve
+                    // the same queue again, as the region lock will be given to us only when the merge/split operation
+                    // is done
+                    final PrioritisedQueue queue = this.world.getQueue(synchronise, this.chunkX, this.chunkZ, this.isChunkTask);
+
+                    if (queue == null) {
+                        if (!synchronise) {
+                            // may be incorrectly null when unsynchronised
+                            synchronise = true;
+                            continue;
+                        }
+                        // may have been cancelled before we got to the queue
+                        if (this.getReferenceCounterVolatile() != null) {
+                            throw new IllegalStateException("Expected null ref count when queue does not exist");
+                        }
+                        // the task never could be polled from the queue, so we return false
+                        // don't decrement reference count, as we were certainly cancelled by another thread, which
+                        // will decrement the reference count
+                        return false;
+                    }
+
+                    synchronise = true;
+
+                    final Boolean res = queue.tryPush(this);
+                    if (res == null) {
+                        // we were cancelled
+                        // don't decrement reference count, as we were certainly cancelled by another thread, which
+                        // will decrement the reference count
+                        return false;
+                    }
+
+                    if (!res.booleanValue()) {
+                        // failed, try again
+                        continue;
+                    }
+
+                    queue.queue.regionData.setHasTasks();
+
+                    // successfully queued
+                    return true;
+                }
+            }
+
+            private ReferenceCountData trySetCompleting(final int minPriority) {
+                // first, try to set priority to EXECUTING
+                for (Priority curr = this.getPriorityVolatile();;) {
+                    if (curr.isLowerPriority(minPriority)) {
+                        return null;
+                    }
+
+                    if (curr == (curr = this.compareAndExchangePriority(curr, Priority.COMPLETING))) {
+                        break;
+                    } // else: continue
+                }
+
+                for (ReferenceCountData curr = this.getReferenceCounterVolatile();;) {
+                    if (curr == null) {
+                        // something acquired before us
+                        return null;
+                    }
+
+                    if (curr == REFERENCE_COUNTER_NOT_SET) {
+                        throw new IllegalStateException();
+                    }
+
+                    if (curr != (curr = this.compareAndExchangeReferenceCounter(curr, null))) {
+                        continue;
+                    }
+
+                    return curr;
+                }
+            }
+
+            private void updatePriorityInQueue() {
+                boolean synchronise = false;
+                for (;;) {
+                    final ReferenceCountData referenceCount = this.getReferenceCounterVolatile();
+                    if (referenceCount == REFERENCE_COUNTER_NOT_SET || referenceCount == null) {
+                        // cancelled or not queued
+                        return;
+                    }
+
+                    if (this.getPriorityVolatile() == Priority.COMPLETING) {
+                        // cancelled
+                        return;
+                    }
+
+                    // we need to synchronise for repeated operations so that we guarantee that we do not retrieve
+                    // the same queue again, as the region lock will be given to us only when the merge/split operation
+                    // is done
+                    final PrioritisedQueue queue = this.world.getQueue(synchronise, this.chunkX, this.chunkZ, this.isChunkTask);
+
+                    if (queue == null) {
+                        if (!synchronise) {
+                            // may be incorrectly null when unsynchronised
+                            synchronise = true;
+                            continue;
+                        }
+                        // must have been removed
+                        return;
+                    }
+
+                    synchronise = true;
+
+                    final Boolean res = queue.tryPush(this);
+                    if (res == null) {
+                        // we were cancelled
+                        return;
+                    }
+
+                    if (!res.booleanValue()) {
+                        // failed, try again
+                        continue;
+                    }
+
+                    // successfully queued
+                    return;
+                }
+            }
+
+            @Override
+            public Priority getPriority() {
+                return this.getPriorityVolatile();
+            }
+
+            @Override
+            public boolean lowerPriority(final Priority priority) {
+                int failures = 0;
+                for (Priority curr = this.getPriorityVolatile();;) {
+                    if (curr == Priority.COMPLETING) {
+                        return false;
+                    }
+
+                    if (curr.isLowerOrEqualPriority(priority)) {
+                        return false;
+                    }
+
+                    for (int i = 0; i < failures; ++i) {
+                        ConcurrentUtil.backoff();
+                    }
+
+                    if (curr == (curr = this.compareAndExchangePriority(curr, priority))) {
+                        this.updatePriorityInQueue();
+                        return true;
+                    }
+                    ++failures;
+                }
+            }
+
+            @Override
+            public long getSubOrder() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean setSubOrder(final long subOrder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean raiseSubOrder(final long subOrder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean lowerSubOrder(final long subOrder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long getStream() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean setStream(final long stream) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean setPrioritySubOrderStream(final Priority priority, final long subOrder, final long stream) {
+                return this.setPriority(priority);
+            }
+
+            @Override
+            public PriorityState getPriorityState() {
+                return new PriorityState(this.getPriority(), 0L, 0L);
+            }
+
+            @Override
+            public boolean setPriority(final Priority priority) {
+                int failures = 0;
+                for (Priority curr = this.getPriorityVolatile();;) {
+                    if (curr == Priority.COMPLETING) {
+                        return false;
+                    }
+
+                    if (curr == priority) {
+                        return false;
+                    }
+
+                    for (int i = 0; i < failures; ++i) {
+                        ConcurrentUtil.backoff();
+                    }
+
+                    if (curr == (curr = this.compareAndExchangePriority(curr, priority))) {
+                        this.updatePriorityInQueue();
+                        return true;
+                    }
+                    ++failures;
+                }
+            }
+
+            @Override
+            public boolean raisePriority(final Priority priority) {
+                int failures = 0;
+                for (Priority curr = this.getPriorityVolatile();;) {
+                    if (curr == Priority.COMPLETING) {
+                        return false;
+                    }
+
+                    if (curr.isHigherOrEqualPriority(priority)) {
+                        return false;
+                    }
+
+                    for (int i = 0; i < failures; ++i) {
+                        ConcurrentUtil.backoff();
+                    }
+
+                    if (curr == (curr = this.compareAndExchangePriority(curr, priority))) {
+                        this.updatePriorityInQueue();
+                        return true;
+                    }
+                    ++failures;
+                }
+            }
+
+            @Override
+            public boolean execute() {
+                return this.tryComplete(false);
+            }
+
+            @Override
+            public boolean cancel() {
+                return this.tryComplete(true);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/RegionizedWorldData.java b/io/papermc/paper/threadedregions/RegionizedWorldData.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f49d787ecee4ba9dce087036a4e3cbce2228c17
--- /dev/null
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -0,0 +1,777 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet;
+import ca.spottedleaf.moonrise.common.list.ReferenceList;
+import ca.spottedleaf.moonrise.common.misc.NearbyPlayers;
+import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceMap;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.util.VisibleForDebug;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.village.VillageSiege;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.level.BlockEventData;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.NaturalSpawner;
+import net.minecraft.world.level.ServerExplosion;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.RedStoneWireBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TickingBlockEntity;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.pathfinder.PathTypeCache;
+import net.minecraft.world.level.redstone.CollectingNeighborUpdater;
+import net.minecraft.world.ticks.LevelTicks;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.slf4j.Logger;
+import javax.annotation.Nullable;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+public final class RegionizedWorldData {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final Entity[] EMPTY_ENTITY_ARRAY = new Entity[0];
+
+    public static final RegionizedData.RegioniserCallback<RegionizedWorldData> REGION_CALLBACK = new RegionizedData.RegioniserCallback<>() {
+        @Override
+        public void merge(final RegionizedWorldData from, final RegionizedWorldData into, final long fromTickOffset) {
+            // connections
+            for (final Connection conn : from.connections) {
+                into.connections.add(conn);
+            }
+            // time
+            final long fromRedstoneTimeOffset = into.redstoneTime - from.redstoneTime;
+            // entities
+            for (final ServerPlayer player : from.localPlayers) {
+                into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into);
+                into.nearbyPlayers.addPlayer(player);
+            }
+            for (final Entity entity : from.allEntities) {
+                into.allEntities.add(entity);
+                entity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+                entity.getBukkitEntity().taskScheduler.registerTo(into.entitySchedulerTickList);
+            }
+            for (final Entity entity : from.loadedEntities) {
+                into.loadedEntities.add(entity);
+            }
+            for (final Iterator<Entity> iterator = from.entityTickList.unsafeIterator(); iterator.hasNext();) {
+                into.entityTickList.add(iterator.next());
+            }
+            for (final Iterator<Mob> iterator = from.navigatingMobs.unsafeIterator(); iterator.hasNext();) {
+                into.navigatingMobs.add(iterator.next());
+            }
+            for (final Iterator<Entity> iterator = from.trackerEntities.iterator(); iterator.hasNext();) {
+                into.trackerEntities.add(iterator.next());
+            }
+            for (final Iterator<Entity> iterator = from.trackerUnloadedEntities.iterator(); iterator.hasNext();) {
+                into.trackerUnloadedEntities.add(iterator.next());
+            }
+            // block ticking
+            into.blockEvents.addAll(from.blockEvents);
+            // ticklists use game time
+            from.blockLevelTicks.merge(into.blockLevelTicks, fromRedstoneTimeOffset);
+            from.fluidLevelTicks.merge(into.fluidLevelTicks, fromRedstoneTimeOffset);
+
+            // tile entity ticking
+            for (final TickingBlockEntity tileEntityWrapped : from.pendingBlockEntityTickers) {
+                into.pendingBlockEntityTickers.add(tileEntityWrapped);
+                final BlockEntity tileEntity = tileEntityWrapped.getTileEntity();
+                if (tileEntity != null) {
+                    tileEntity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+                }
+            }
+            for (final TickingBlockEntity tileEntityWrapped : from.blockEntityTickers) {
+                into.blockEntityTickers.add(tileEntityWrapped);
+                final BlockEntity tileEntity = tileEntityWrapped.getTileEntity();
+                if (tileEntity != null) {
+                    tileEntity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+                }
+            }
+
+            // ticking chunks
+            for (final Iterator<LevelChunk> iterator = from.entityTickingChunks.iterator(); iterator.hasNext();) {
+                into.entityTickingChunks.add(iterator.next());
+            }
+            for (final Iterator<LevelChunk> iterator = from.tickingChunks.iterator(); iterator.hasNext();) {
+                into.tickingChunks.add(iterator.next());
+            }
+            for (final Iterator<LevelChunk> iterator = from.chunks.iterator(); iterator.hasNext();) {
+                into.chunks.add(iterator.next());
+            }
+            // redstone torches
+            if (from.redstoneUpdateInfos != null && !from.redstoneUpdateInfos.isEmpty()) {
+                if (into.redstoneUpdateInfos == null) {
+                    into.redstoneUpdateInfos = new ArrayDeque<>();
+                }
+                for (final net.minecraft.world.level.block.RedstoneTorchBlock.Toggle info : from.redstoneUpdateInfos) {
+                    info.offsetTime(fromRedstoneTimeOffset);
+                    into.redstoneUpdateInfos.add(info);
+                }
+            }
+            // mob spawning
+            into.catSpawnerNextTick = Math.max(from.catSpawnerNextTick, into.catSpawnerNextTick);
+            into.patrolSpawnerNextTick = Math.max(from.patrolSpawnerNextTick, into.patrolSpawnerNextTick);
+            into.phantomSpawnerNextTick = Math.max(from.phantomSpawnerNextTick, into.phantomSpawnerNextTick);
+            if (from.wanderingTraderTickDelay != Integer.MIN_VALUE && into.wanderingTraderTickDelay != Integer.MIN_VALUE) {
+                into.wanderingTraderTickDelay = Math.max(from.wanderingTraderTickDelay, into.wanderingTraderTickDelay);
+                into.wanderingTraderSpawnDelay = Math.max(from.wanderingTraderSpawnDelay, into.wanderingTraderSpawnDelay);
+                into.wanderingTraderSpawnChance = Math.max(from.wanderingTraderSpawnChance, into.wanderingTraderSpawnChance);
+            }
+            // chunkHoldersToBroadcast
+            for (final ChunkHolder chunkHolder : from.chunkHoldersToBroadcast) {
+                into.chunkHoldersToBroadcast.add(chunkHolder);
+            }
+        }
+
+        @Override
+        public void split(final RegionizedWorldData from, final int chunkToRegionShift,
+                          final Long2ReferenceOpenHashMap<RegionizedWorldData> regionToData,
+                          final ReferenceOpenHashSet<RegionizedWorldData> dataSet) {
+            // connections
+            for (final Connection conn : from.connections) {
+                final ServerPlayer player = conn.getPlayer();
+                final ChunkPos pos = player.chunkPosition();
+                // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
+                // the chunk holder must _exist_, and so the region section exists.
+                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
+                    .connections.add(conn);
+            }
+            // entities
+            for (final ServerPlayer player : from.localPlayers) {
+                final ChunkPos pos = player.chunkPosition();
+                // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
+                // the chunk holder must _exist_, and so the region section exists.
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into);
+                into.nearbyPlayers.addPlayer(player);
+            }
+            for (final Entity entity : from.allEntities) {
+                final ChunkPos pos = entity.chunkPosition();
+                // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
+                // the chunk holder must _exist_, and so the region section exists.
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                into.allEntities.add(entity);
+                // Note: entityTickList is a subset of allEntities
+                if (from.entityTickList.contains(entity)) {
+                    into.entityTickList.add(entity);
+                }
+                // Note: loadedEntities is a subset of allEntities
+                if (from.loadedEntities.contains(entity)) {
+                    into.loadedEntities.add(entity);
+                }
+                // Note: navigatingMobs is a subset of allEntities
+                if (entity instanceof Mob mob && from.navigatingMobs.contains(mob)) {
+                    into.navigatingMobs.add(mob);
+                }
+                if (from.trackerEntities.contains(entity)) {
+                    into.trackerEntities.add(entity);
+                }
+                if (from.trackerUnloadedEntities.contains(entity)) {
+                    into.trackerUnloadedEntities.add(entity);
+                }
+                entity.getBukkitEntity().taskScheduler.registerTo(into.entitySchedulerTickList);
+            }
+            // block ticking
+            for (final BlockEventData blockEventData : from.blockEvents) {
+                final BlockPos pos = blockEventData.pos();
+                final int chunkX = pos.getX() >> 4;
+                final int chunkZ = pos.getZ() >> 4;
+
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift));
+                // Unlike entities, the chunk holder is not guaranteed to exist for block events, because the block events
+                // is just some list. So if it unloads, I guess it's just lost.
+                if (into != null) {
+                    into.blockEvents.add(blockEventData);
+                }
+            }
+
+            final Long2ReferenceOpenHashMap<LevelTicks<Block>> levelTicksBlockRegionData = new Long2ReferenceOpenHashMap<>(regionToData.size(), 0.75f);
+            final Long2ReferenceOpenHashMap<LevelTicks<Fluid>> levelTicksFluidRegionData = new Long2ReferenceOpenHashMap<>(regionToData.size(), 0.75f);
+
+            for (final Iterator<Long2ReferenceMap.Entry<RegionizedWorldData>> iterator = regionToData.long2ReferenceEntrySet().fastIterator();
+                 iterator.hasNext();) {
+                final Long2ReferenceMap.Entry<RegionizedWorldData> entry = iterator.next();
+                final long key = entry.getLongKey();
+                final RegionizedWorldData worldData = entry.getValue();
+
+                levelTicksBlockRegionData.put(key, worldData.blockLevelTicks);
+                levelTicksFluidRegionData.put(key, worldData.fluidLevelTicks);
+            }
+
+            from.blockLevelTicks.split(chunkToRegionShift, levelTicksBlockRegionData);
+            from.fluidLevelTicks.split(chunkToRegionShift, levelTicksFluidRegionData);
+
+            // tile entity ticking
+            for (final TickingBlockEntity tileEntity : from.pendingBlockEntityTickers) {
+                final BlockPos pos = tileEntity.getPos();
+                final int chunkX = pos.getX() >> 4;
+                final int chunkZ = pos.getZ() >> 4;
+
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift));
+                if (into != null) {
+                    into.pendingBlockEntityTickers.add(tileEntity);
+                } // else: when a chunk unloads, it does not actually _remove_ the tile entity from the list, it just gets
+                  //       marked as removed. So if there is no section, it's probably removed!
+            }
+            for (final TickingBlockEntity tileEntity : from.blockEntityTickers) {
+                final BlockPos pos = tileEntity.getPos();
+                final int chunkX = pos.getX() >> 4;
+                final int chunkZ = pos.getZ() >> 4;
+
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift));
+                if (into != null) {
+                    into.blockEntityTickers.add(tileEntity);
+                } // else: when a chunk unloads, it does not actually _remove_ the tile entity from the list, it just gets
+                  //       marked as removed. So if there is no section, it's probably removed!
+            }
+            // time
+            for (final RegionizedWorldData regionizedWorldData : dataSet) {
+                regionizedWorldData.redstoneTime = from.redstoneTime;
+            }
+            // ticking chunks
+            for (final Iterator<LevelChunk> iterator = from.entityTickingChunks.iterator(); iterator.hasNext();) {
+                final LevelChunk chunk = iterator.next();
+                final ChunkPos pos = chunk.getPos();
+
+                // Impossible for get() to return null, as the chunk is entity ticking - thus the chunk holder is loaded
+                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
+                    .entityTickingChunks.add(chunk);
+            }
+            for (final Iterator<LevelChunk> iterator = from.tickingChunks.iterator(); iterator.hasNext();) {
+                final LevelChunk chunk = iterator.next();
+                final ChunkPos pos = chunk.getPos();
+
+                // Impossible for get() to return null, as the chunk is entity ticking - thus the chunk holder is loaded
+                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
+                    .tickingChunks.add(chunk);
+            }
+            for (final Iterator<LevelChunk> iterator = from.chunks.iterator(); iterator.hasNext();) {
+                final LevelChunk chunk = iterator.next();
+                final ChunkPos pos = chunk.getPos();
+
+                // Impossible for get() to return null, as the chunk is entity ticking - thus the chunk holder is loaded
+                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
+                    .chunks.add(chunk);
+            }
+
+            // redstone torches
+            if (from.redstoneUpdateInfos != null && !from.redstoneUpdateInfos.isEmpty()) {
+                for (final net.minecraft.world.level.block.RedstoneTorchBlock.Toggle info : from.redstoneUpdateInfos) {
+                    final BlockPos pos = info.pos;
+
+                    final RegionizedWorldData worldData = regionToData.get(CoordinateUtils.getChunkKey((pos.getX() >> 4) >> chunkToRegionShift, (pos.getZ() >> 4) >> chunkToRegionShift));
+                    if (worldData != null) {
+                        if (worldData.redstoneUpdateInfos == null) {
+                            worldData.redstoneUpdateInfos = new ArrayDeque<>();
+                        }
+                        worldData.redstoneUpdateInfos.add(info);
+                    } // else: chunk unloaded
+                }
+            }
+            // mob spawning
+            for (final RegionizedWorldData regionizedWorldData : dataSet) {
+                regionizedWorldData.catSpawnerNextTick = from.catSpawnerNextTick;
+                regionizedWorldData.patrolSpawnerNextTick = from.patrolSpawnerNextTick;
+                regionizedWorldData.phantomSpawnerNextTick = from.phantomSpawnerNextTick;
+                regionizedWorldData.wanderingTraderTickDelay = from.wanderingTraderTickDelay;
+                regionizedWorldData.wanderingTraderSpawnChance = from.wanderingTraderSpawnChance;
+                regionizedWorldData.wanderingTraderSpawnDelay = from.wanderingTraderSpawnDelay;
+                regionizedWorldData.villageSiegeState = new VillageSiegeState(); // just re set it, as the spawn pos will be invalid
+            }
+            // chunkHoldersToBroadcast
+            for (final ChunkHolder chunkHolder : from.chunkHoldersToBroadcast) {
+                final ChunkPos pos = chunkHolder.getPos();
+
+                // Possible for get() to return null, as the chunk holder is not removed during unload
+                final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                if (into != null) {
+                    into.chunkHoldersToBroadcast.add(chunkHolder);
+                }
+            }
+        }
+    };
+
+    public final ServerLevel world;
+
+    private RegionizedServer.WorldLevelData tickData;
+
+    // connections
+    public final List<Connection> connections = new ArrayList<>();
+
+    // misc. fields
+    private boolean isHandlingTick;
+
+    public void setHandlingTick(final boolean to) {
+        this.isHandlingTick = to;
+    }
+
+    public boolean isHandlingTick() {
+        return this.isHandlingTick;
+    }
+
+    // entities
+    // this is copy on write to allow packet processing to iterate safely
+    private final CopyOnWriteArrayList<ServerPlayer> localPlayers = new CopyOnWriteArrayList<>();
+    private final NearbyPlayers nearbyPlayers;
+    public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
+    private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
+    private final ReferenceList<Entity> loadedEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
+    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();
+    private final IteratorSafeOrderedReferenceSet<Mob> navigatingMobs = new IteratorSafeOrderedReferenceSet<>();
+    public final ReferenceList<Entity> trackerEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY); // Moonrise - entity tracker
+    public final ReferenceList<Entity> trackerUnloadedEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY); // Moonrise - entity tracker
+
+    // block ticking
+    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
+    private final LevelTicks<Block> blockLevelTicks;
+    private final LevelTicks<Fluid> fluidLevelTicks;
+
+    // tile entity ticking
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private boolean tickingBlockEntities;
+
+    // time
+    private long redstoneTime = 1L;
+
+    public long getRedstoneGameTime() {
+        return this.redstoneTime;
+    }
+
+    public void setRedstoneGameTime(final long to) {
+        this.redstoneTime = to;
+    }
+
+    // ticking chunks
+    private static final LevelChunk[] EMPTY_CHUNK_ARRAY = new LevelChunk[0];
+    private final ReferenceList<LevelChunk> entityTickingChunks = new ReferenceList<>(EMPTY_CHUNK_ARRAY);
+    private final ReferenceList<LevelChunk> tickingChunks = new ReferenceList<>(EMPTY_CHUNK_ARRAY);
+    private final ReferenceList<LevelChunk> chunks = new ReferenceList<>(EMPTY_CHUNK_ARRAY);
+
+    // Paper/CB api hook misc
+    // don't bother to merge/split these, no point
+    // From ServerLevel
+    public boolean hasPhysicsEvent = true; // Paper
+    public boolean hasEntityMoveEvent = false; // Paper
+    // Paper start - Optimize Hoppers
+    public boolean skipPullModeEventFire = false;
+    public boolean skipPushModeEventFire = false;
+    public boolean skipHopperEvents = false;
+    // Paper end - Optimize Hoppers
+    public long lastMidTickExecute;
+    public long lastMidTickExecuteFailure;
+    // From Level
+    public boolean populating;
+    public final CollectingNeighborUpdater neighborUpdater;
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public List<ItemEntity> captureDrops;
+    // Paper start
+    public int wakeupInactiveRemainingAnimals;
+    public int wakeupInactiveRemainingFlying;
+    public int wakeupInactiveRemainingMonsters;
+    public int wakeupInactiveRemainingVillagers;
+    // Paper end
+    public int currentPrimedTnt = 0; // Spigot
+    @Nullable
+    @VisibleForDebug
+    public NaturalSpawner.SpawnState lastSpawnState;
+    public boolean shouldSignal = true;
+    public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(64, 0.25f);
+    public final PathTypeCache pathTypesByPosCache = new PathTypeCache();
+    public final List<LevelChunk> temporaryChunkTickList = new java.util.ArrayList<>();
+    public final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceLinkedOpenHashSet<>();
+
+    // not transient
+    public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
+
+    // Mob spawning
+    public final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
+    public int catSpawnerNextTick = 0;
+    public int patrolSpawnerNextTick = 0;
+    public int phantomSpawnerNextTick = 0;
+    public int wanderingTraderTickDelay = Integer.MIN_VALUE;
+    public int wanderingTraderSpawnDelay;
+    public int wanderingTraderSpawnChance;
+    public VillageSiegeState villageSiegeState = new VillageSiegeState();
+
+    public static final class VillageSiegeState {
+        public boolean hasSetupSiege;
+        public VillageSiege.State siegeState = VillageSiege.State.SIEGE_DONE;
+        public int zombiesToSpawn;
+        public int nextSpawnTime;
+        public int spawnX;
+        public int spawnY;
+        public int spawnZ;
+    }
+    // Redstone
+    public final alternate.current.wire.WireHandler wireHandler;
+    public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
+
+    public final TickRegions.TickRegionData regionData;
+
+    public RegionizedWorldData(final ServerLevel world, final TickRegions.TickRegionData regionData) {
+        this.world = world;
+        this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
+        this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
+        this.neighborUpdater = new CollectingNeighborUpdater(world, world.neighbourUpdateMax);
+        this.nearbyPlayers = new NearbyPlayers(world);
+        this.wireHandler = new alternate.current.wire.WireHandler(world);
+        this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData;
+
+        // tasks may be drained before the region ticks, so we must set up the tick data early just in case
+        this.updateTickData();
+    }
+
+    public void checkWorld(final Level against) {
+        if (this.world != against) {
+            throw new IllegalStateException("World mismatch: expected " + this.world.getWorld().getName() + " but got " + (against == null ? "null" : against.getWorld().getName()));
+        }
+    }
+
+    public RegionizedServer.WorldLevelData getTickData() {
+        return this.tickData;
+    }
+
+    private long lagCompensationTick;
+
+    public long getLagCompensationTick() {
+        return this.lagCompensationTick;
+    }
+
+    public void updateTickData() {
+        this.tickData = this.world.tickData;
+        this.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
+        this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
+        this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+        // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
+        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.TIME_BETWEEN_TICKS;
+    }
+
+    public NearbyPlayers getNearbyPlayers() {
+        return this.nearbyPlayers;
+    }
+
+    private static void cleanUpConnection(final Connection conn) {
+        // note: ALL connections HERE have a player
+        final ServerPlayer player = conn.getPlayer();
+        // now that the connection is removed, we can allow this region to die
+        player.level().moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+            ServerGamePacketListenerImpl.DISCONNECT_TICKET, player.connection.disconnectPos,
+            ChunkHolderManager.MAX_TICKET_LEVEL,
+            player.connection.disconnectTicketId
+        );
+    }
+
+    // connections
+    public void tickConnections() {
+        final List<Connection> connections = new ArrayList<>(this.connections);
+        Collections.shuffle(connections);
+        for (final Connection conn : connections) {
+            if (!conn.isConnected()) {
+                conn.handleDisconnection();
+                // global tick thread will not remove connections not owned by it, so we need to
+                RegionizedServer.getInstance().removeConnection(conn);
+                this.connections.remove(conn);
+                cleanUpConnection(conn);
+                continue;
+            }
+            if (!this.connections.contains(conn)) {
+                // removed by connection tick?
+                continue;
+            }
+
+            try {
+                conn.tick();
+            } catch (final Exception exception) {
+                if (conn.isMemoryConnection()) {
+                    throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                }
+
+                LOGGER.warn("Failed to handle packet for {}", conn.getLoggableAddress(MinecraftServer.getServer().logIPs()), exception);
+                MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                conn.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                    conn.disconnect(ichatmutablecomponent);
+                }));
+                conn.setReadOnly();
+                continue;
+            }
+        }
+    }
+
+    // entities hooks
+    public int getEntityCount() {
+        return this.allEntities.size();
+    }
+
+    public int getPlayerCount() {
+        return this.localPlayers.size();
+    }
+
+    public Iterable<Entity> getLocalEntities() {
+        return this.allEntities;
+    }
+
+    public Entity[] getLocalEntitiesCopy() {
+        return Arrays.copyOf(this.allEntities.getRawData(), this.allEntities.size(), Entity[].class);
+    }
+
+    public List<ServerPlayer> getLocalPlayers() {
+        return this.localPlayers;
+    }
+
+    public void addLoadedEntity(final Entity entity) {
+        this.loadedEntities.add(entity);
+    }
+
+    public boolean hasLoadedEntity(final Entity entity) {
+        return this.loadedEntities.contains(entity);
+    }
+
+    public void removeLoadedEntity(final Entity entity) {
+        this.loadedEntities.remove(entity);
+    }
+
+    public Iterable<Entity> getLoadedEntities() {
+        return this.loadedEntities;
+    }
+
+    public void addEntityTickingEntity(final Entity entity) {
+        if (!TickThread.isTickThreadFor(entity)) {
+            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+        }
+        this.entityTickList.add(entity);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public boolean hasEntityTickingEntity(final Entity entity) {
+        return this.entityTickList.contains(entity);
+    }
+
+    public void removeEntityTickingEntity(final Entity entity) {
+        if (!TickThread.isTickThreadFor(entity)) {
+            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+        }
+        this.entityTickList.remove(entity);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public void forEachTickingEntity(final Consumer<Entity> action) {
+        final IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entityTickList.iterator();
+        try {
+            while (iterator.hasNext()) {
+                action.accept(iterator.next());
+            }
+        } finally {
+            iterator.finishedIterating();
+        }
+    }
+
+    public void addEntity(final Entity entity) {
+        if (!TickThread.isTickThreadFor(this.world, entity.chunkPosition())) {
+            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+        }
+        if (this.allEntities.add(entity)) {
+            if (entity instanceof ServerPlayer player) {
+                this.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(this);
+            }
+            TickRegions.RegionStats.updateCurrentRegion();
+        }
+    }
+
+    public boolean hasEntity(final Entity entity) {
+        return this.allEntities.contains(entity);
+    }
+
+    public void removeEntity(final Entity entity) {
+        if (!TickThread.isTickThreadFor(entity)) {
+            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+        }
+        if (this.allEntities.remove(entity)) {
+            if (entity instanceof ServerPlayer player) {
+                this.localPlayers.remove(player);
+                player.getBukkitEntity().updateRegion(null);
+            }
+            TickRegions.RegionStats.updateCurrentRegion();
+        }
+    }
+
+    public void addNavigatingMob(final Mob mob) {
+        if (!TickThread.isTickThreadFor(mob)) {
+            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
+        }
+        this.navigatingMobs.add(mob);
+    }
+
+    public void removeNavigatingMob(final Mob mob) {
+        if (!TickThread.isTickThreadFor(mob)) {
+            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
+        }
+        this.navigatingMobs.remove(mob);
+    }
+
+    public Iterator<Mob> getNavigatingMobs() {
+        return this.navigatingMobs.unsafeIterator();
+    }
+
+    // block ticking hooks
+    // Since block event data does not require chunk holders to be created for the chunk they reside in,
+    // it's not actually guaranteed that when merging / splitting data that we actually own the data...
+    // Note that we can only ever not own the event data when the chunk unloads, and so I've decided to
+    // make the code easier by simply discarding it in such an event
+    public void pushBlockEvent(final BlockEventData blockEventData) {
+        TickThread.ensureTickThread(this.world, blockEventData.pos(), "Cannot queue block even data async");
+        this.blockEvents.add(blockEventData);
+    }
+
+    public void pushBlockEvents(final Collection<? extends BlockEventData> blockEvents) {
+        for (final BlockEventData blockEventData : blockEvents) {
+            this.pushBlockEvent(blockEventData);
+        }
+    }
+
+    public void removeIfBlockEvents(final Predicate<? super BlockEventData> predicate) {
+        for (final Iterator<BlockEventData> iterator = this.blockEvents.iterator(); iterator.hasNext();) {
+            final BlockEventData blockEventData = iterator.next();
+            if (predicate.test(blockEventData)) {
+                iterator.remove();
+            }
+        }
+    }
+
+    public BlockEventData removeFirstBlockEvent() {
+        BlockEventData ret;
+        while (!this.blockEvents.isEmpty()) {
+            ret = this.blockEvents.removeFirst();
+            if (TickThread.isTickThreadFor(this.world, ret.pos())) {
+                return ret;
+            } // else: chunk must have been unloaded
+        }
+
+        return null;
+    }
+
+    public LevelTicks<Block> getBlockLevelTicks() {
+        return this.blockLevelTicks;
+    }
+
+    public LevelTicks<Fluid> getFluidLevelTicks() {
+        return this.fluidLevelTicks;
+    }
+
+    // tile entity ticking
+    public void addBlockEntityTicker(final TickingBlockEntity ticker) {
+        TickThread.ensureTickThread(this.world, ticker.getPos(), "Tile entity must be owned by current region");
+
+        (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
+    }
+
+    public void seTtickingBlockEntities(final boolean to) {
+        this.tickingBlockEntities = true;
+    }
+
+    public List<TickingBlockEntity> getBlockEntityTickers() {
+        return this.blockEntityTickers;
+    }
+
+    public void pushPendingTickingBlockEntities() {
+        if (!this.pendingBlockEntityTickers.isEmpty()) {
+            this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
+            this.pendingBlockEntityTickers.clear();
+        }
+    }
+
+    // ticking chunks
+    public void addEntityTickingChunk(final LevelChunk chunk) {
+        this.entityTickingChunks.add(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public void removeEntityTickingChunk(final LevelChunk chunk) {
+        this.entityTickingChunks.remove(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public ReferenceList<LevelChunk> getEntityTickingChunks() {
+        return this.entityTickingChunks;
+    }
+
+    public void addTickingChunk(final LevelChunk chunk) {
+        this.tickingChunks.add(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public void removeTickingChunk(final LevelChunk chunk) {
+        this.tickingChunks.remove(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public ReferenceList<LevelChunk> getTickingChunks() {
+        return this.tickingChunks;
+    }
+
+    public void addChunk(final LevelChunk chunk) {
+        this.chunks.add(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public void removeChunk(final LevelChunk chunk) {
+        this.chunks.remove(chunk);
+        TickRegions.RegionStats.updateCurrentRegion();
+    }
+
+    public ReferenceList<LevelChunk> getChunks() {
+        return this.chunks;
+    }
+
+    public int getEntityTickingChunkCount() {
+        return this.entityTickingChunks.size();
+    }
+
+    public int getChunkCount() {
+        return this.chunks.size();
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/Schedule.java b/io/papermc/paper/threadedregions/Schedule.java
new file mode 100644
index 0000000000000000000000000000000000000000..820b1c4dc1b19ee8602333295f2034362f885a37
--- /dev/null
+++ b/io/papermc/paper/threadedregions/Schedule.java
@@ -0,0 +1,91 @@
+package io.papermc.paper.threadedregions;
+
+/**
+ * A Schedule is an object that can be used to maintain a periodic schedule for an event of interest.
+ */
+public final class Schedule {
+
+    private long lastPeriod;
+
+    /**
+     * Initialises a schedule with the provided period.
+     * @param firstPeriod The last time an event of interest occurred.
+     * @see #setLastPeriod(long)
+     */
+    public Schedule(final long firstPeriod) {
+        this.lastPeriod = firstPeriod;
+    }
+
+    /**
+     * Updates the last period to the specified value. This call sets the last "time" the event
+     * of interest took place at. Thus, the value returned by {@link #getDeadline(long)} is
+     * the provided time plus the period length provided to {@code getDeadline}.
+     * @param value The value to set the last period to.
+     */
+    public void setLastPeriod(final long value) {
+        this.lastPeriod = value;
+    }
+
+    /**
+     * Returns the last time the event of interest should have taken place.
+     */
+    public long getLastPeriod() {
+        return this.lastPeriod;
+    }
+
+    /**
+     * Returns the number of times the event of interest should have taken place between the last
+     * period and the provided time given the period between each event.
+     * @param periodLength The length of the period between events in ns.
+     * @param time The provided time.
+     */
+    public int getPeriodsAhead(final long periodLength, final long time) {
+        final long difference = time - this.lastPeriod;
+        final int ret = (int)(Math.abs(difference) / periodLength);
+        return difference >= 0 ? ret : -ret;
+    }
+
+    /**
+     * Returns the next starting deadline for the event of interest to take place,
+     * given the provided period length.
+     * @param periodLength The provided period length.
+     */
+    public long getDeadline(final long periodLength) {
+        return this.lastPeriod + periodLength;
+    }
+
+    /**
+     * Adjusts the last period so that the next starting deadline returned is the next period specified,
+     * given the provided period length.
+     * @param nextPeriod The specified next starting deadline.
+     * @param periodLength The specified period length.
+     */
+    public void setNextPeriod(final long nextPeriod, final long periodLength) {
+        this.lastPeriod = nextPeriod - periodLength;
+    }
+
+    /**
+     * Increases the last period by the specified number of periods and period length.
+     * The specified number of periods may be < 0, in which case the last period
+     * will decrease.
+     * @param periods The specified number of periods.
+     * @param periodLength The specified period length.
+     */
+    public void advanceBy(final int periods, final long periodLength) {
+        this.lastPeriod += (long)periods * periodLength;
+    }
+
+    /**
+     * Sets the last period so that it is the specified number of periods ahead
+     * given the specified time and period length.
+     * @param periodsToBeAhead Specified number of periods to be ahead by.
+     * @param periodLength The specified period length.
+     * @param time The specified time.
+     */
+    public void setPeriodsAhead(final int periodsToBeAhead, final long periodLength, final long time) {
+        final int periodsAhead = this.getPeriodsAhead(periodLength, time);
+        final int periodsToAdd = periodsToBeAhead - periodsAhead;
+
+        this.lastPeriod -= (long)periodsToAdd * periodLength;
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/TeleportUtils.java b/io/papermc/paper/threadedregions/TeleportUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a64a5b2cf049661fe3f5a22ddfa39979624f5ec
--- /dev/null
+++ b/io/papermc/paper/threadedregions/TeleportUtils.java
@@ -0,0 +1,82 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.concurrentutil.completable.CallbackCompletable;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import java.util.function.Consumer;
+
+public final class TeleportUtils {
+
+    public static <T extends Entity> void teleport(final T from, final boolean useFromRootVehicle, final Entity to, final Float yaw, final Float pitch,
+                                                   final long teleportFlags, final PlayerTeleportEvent.TeleportCause cause, final Consumer<Entity> onComplete) {
+        teleport(from, useFromRootVehicle, to, yaw, pitch, teleportFlags, cause, onComplete, null);
+    }
+
+    public static <T extends Entity> void teleport(final T from, final boolean useFromRootVehicle, final Entity to, final Float yaw, final Float pitch,
+                                                   final long teleportFlags, final PlayerTeleportEvent.TeleportCause cause, final Consumer<Entity> onComplete,
+                                                   final java.util.function.Predicate<T> preTeleport) {
+        // retrieve coordinates
+        final CallbackCompletable<Location> positionCompletable = new CallbackCompletable<>();
+
+        positionCompletable.addWaiter(
+            (final Location loc, final Throwable thr) -> {
+                if (loc == null) {
+                    if (onComplete != null) {
+                        onComplete.accept(null);
+                    }
+                    return;
+                }
+                final boolean scheduled = from.getBukkitEntity().taskScheduler.schedule(
+                    (final T realFrom) -> {
+                        final Vec3 pos = new Vec3(
+                            loc.getX(), loc.getY(), loc.getZ()
+                        );
+                        if (preTeleport != null && !preTeleport.test(realFrom)) {
+                            if (onComplete != null) {
+                                onComplete.accept(null);
+                            }
+                            return;
+                        }
+                        (useFromRootVehicle ? realFrom.getRootVehicle() : realFrom).teleportAsync(
+                            ((CraftWorld)loc.getWorld()).getHandle(), pos, null, null, null,
+                            cause, teleportFlags, onComplete
+                        );
+                    },
+                    (final Entity retired) -> {
+                        if (onComplete != null) {
+                            onComplete.accept(null);
+                        }
+                    },
+                    1L
+                );
+                if (!scheduled) {
+                    if (onComplete != null) {
+                        onComplete.accept(null);
+                    }
+                }
+            }
+        );
+
+        final boolean scheduled = to.getBukkitEntity().taskScheduler.schedule(
+            (final Entity target) -> {
+                positionCompletable.complete(target.getBukkitEntity().getLocation());
+            },
+            (final Entity retired) -> {
+                if (onComplete != null) {
+                    onComplete.accept(null);
+                }
+            },
+            1L
+        );
+        if (!scheduled) {
+            if (onComplete != null) {
+                onComplete.accept(null);
+            }
+        }
+    }
+
+    private TeleportUtils() {}
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/ThreadedRegionizer.java b/io/papermc/paper/threadedregions/ThreadedRegionizer.java
new file mode 100644
index 0000000000000000000000000000000000000000..604385af903845d966382ad0a4168798e4ed4a0e
--- /dev/null
+++ b/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -0,0 +1,1405 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.concurrentutil.map.SWMRLong2ObjectHashTable;
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import com.destroystokyo.paper.util.SneakyThrow;
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongComparator;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import org.slf4j.Logger;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.StampedLock;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+
+public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegionData<R, S>, S extends ThreadedRegionizer.ThreadedRegionSectionData> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    public final int regionSectionChunkSize;
+    public final int sectionChunkShift;
+    public final int minSectionRecalcCount;
+    public final int emptySectionCreateRadius;
+    public final int regionSectionMergeRadius;
+    public final double maxDeadRegionPercent;
+    public final ServerLevel world;
+
+    private final SWMRLong2ObjectHashTable<ThreadedRegionSection<R, S>> sections = new SWMRLong2ObjectHashTable<>();
+    private final SWMRLong2ObjectHashTable<ThreadedRegion<R, S>> regionsById = new SWMRLong2ObjectHashTable<>();
+    private final RegionCallbacks<R, S> callbacks;
+    private final StampedLock regionLock = new StampedLock();
+    private Thread writeLockOwner;
+
+    /*
+    static final record Operation(String type, int chunkX, int chunkZ) {}
+    private final MultiThreadedQueue<Operation> ops = new MultiThreadedQueue<>();
+     */
+
+    /*
+     * See REGION_LOGIC.md for complete details on what this class is doing
+     */
+
+    public ThreadedRegionizer(final int minSectionRecalcCount, final double maxDeadRegionPercent,
+                              final int emptySectionCreateRadius, final int regionSectionMergeRadius,
+                              final int regionSectionChunkShift, final ServerLevel world,
+                              final RegionCallbacks<R, S> callbacks) {
+        if (emptySectionCreateRadius <= 0) {
+            throw new IllegalStateException("Region section create radius must be > 0");
+        }
+        if (regionSectionMergeRadius <= 0) {
+            throw new IllegalStateException("Region section merge radius must be > 0");
+        }
+        this.regionSectionChunkSize = 1 << regionSectionChunkShift;
+        this.sectionChunkShift = regionSectionChunkShift;
+        this.minSectionRecalcCount = Math.max(2, minSectionRecalcCount);
+        this.maxDeadRegionPercent = maxDeadRegionPercent;
+        this.emptySectionCreateRadius = emptySectionCreateRadius;
+        this.regionSectionMergeRadius = regionSectionMergeRadius;
+        this.world = world;
+        this.callbacks = callbacks;
+        //this.loadTestData();
+    }
+
+    /*
+    private static String substr(String val, String prefix, int from) {
+        int idx = val.indexOf(prefix, from) + prefix.length();
+        int idx2 = val.indexOf(',', idx);
+        if (idx2 == -1) {
+            idx2 = val.indexOf(']', idx);
+        }
+        return val.substring(idx, idx2);
+    }
+
+    private void loadTestData() {
+        if (true) {
+            return;
+        }
+        try {
+            final JsonArray arr = JsonParser.parseReader(new FileReader("test.json")).getAsJsonArray();
+
+            List<Operation> ops = new ArrayList<>();
+
+            for (JsonElement elem : arr) {
+                JsonObject obj = elem.getAsJsonObject();
+                String val = obj.get("value").getAsString();
+
+                String type = substr(val, "type=", 0);
+                String x = substr(val, "chunkX=", 0);
+                String z = substr(val, "chunkZ=", 0);
+
+                ops.add(new Operation(type, Integer.parseInt(x), Integer.parseInt(z)));
+            }
+
+            for (Operation op : ops) {
+                switch (op.type) {
+                    case "add": {
+                        this.addChunk(op.chunkX, op.chunkZ);
+                        break;
+                    }
+                    case "remove": {
+                        this.removeChunk(op.chunkX, op.chunkZ);
+                        break;
+                    }
+                    case "mark_ticking": {
+                        this.sections.get(CoordinateUtils.getChunkKey(op.chunkX, op.chunkZ)).region.tryMarkTicking();
+                        break;
+                    }
+                    case "rel_region": {
+                        if (this.sections.get(CoordinateUtils.getChunkKey(op.chunkX, op.chunkZ)).region.state == ThreadedRegion.STATE_TICKING) {
+                            this.sections.get(CoordinateUtils.getChunkKey(op.chunkX, op.chunkZ)).region.markNotTicking();
+                        }
+                        break;
+                    }
+                }
+            }
+
+        } catch (final Exception ex) {
+            throw new IllegalStateException(ex);
+        }
+    }
+     */
+
+    public void acquireReadLock() {
+        this.regionLock.readLock();
+    }
+
+    public void releaseReadLock() {
+        this.regionLock.tryUnlockRead();
+    }
+
+    private void acquireWriteLock() {
+        final Thread currentThread = Thread.currentThread();
+        if (this.writeLockOwner == currentThread) {
+            throw new IllegalStateException("Cannot recursively operate in the regioniser");
+        }
+        this.regionLock.writeLock();
+        this.writeLockOwner = currentThread;
+    }
+
+    private void releaseWriteLock() {
+        this.writeLockOwner = null;
+        this.regionLock.tryUnlockWrite();
+    }
+
+    private void onRegionCreate(final ThreadedRegion<R, S> region) {
+        final ThreadedRegion<R, S> conflict;
+        if ((conflict = this.regionsById.putIfAbsent(region.id, region)) != null) {
+            throw new IllegalStateException("Region " + region + " is already mapped to " + conflict);
+        }
+    }
+
+    private void onRegionDestroy(final ThreadedRegion<R, S> region) {
+        final ThreadedRegion<R, S> removed = this.regionsById.remove(region.id);
+        if (removed != region) {
+            throw new IllegalStateException("Expected to remove " + region + ", but removed " + removed);
+        }
+    }
+
+    public int getSectionCoordinate(final int chunkCoordinate) {
+        return chunkCoordinate >> this.sectionChunkShift;
+    }
+
+    public long getSectionKey(final BlockPos pos) {
+        return CoordinateUtils.getChunkKey((pos.getX() >> 4) >> this.sectionChunkShift, (pos.getZ() >> 4) >> this.sectionChunkShift);
+    }
+
+    public long getSectionKey(final ChunkPos pos) {
+        return CoordinateUtils.getChunkKey(pos.x >> this.sectionChunkShift, pos.z >> this.sectionChunkShift);
+    }
+
+    public long getSectionKey(final Entity entity) {
+        final ChunkPos pos = entity.chunkPosition();
+        return CoordinateUtils.getChunkKey(pos.x >> this.sectionChunkShift, pos.z >> this.sectionChunkShift);
+    }
+
+    public void computeForAllRegions(final Consumer<? super ThreadedRegion<R, S>> consumer) {
+        this.regionLock.readLock();
+        try {
+            this.regionsById.forEachValue(consumer);
+        } finally {
+            this.regionLock.tryUnlockRead();
+        }
+    }
+
+    public void computeForAllRegionsUnsynchronised(final Consumer<? super ThreadedRegion<R, S>> consumer) {
+        this.regionsById.forEachValue(consumer);
+    }
+
+    public int computeForRegions(final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ,
+                                  final Consumer<Set<ThreadedRegion<R, S>>> consumer) {
+        final int shift = this.sectionChunkShift;
+        final int fromSectionX = fromChunkX >> shift;
+        final int fromSectionZ = fromChunkZ >> shift;
+        final int toSectionX = toChunkX >> shift;
+        final int toSectionZ = toChunkZ >> shift;
+        this.acquireWriteLock();
+        try {
+            final ReferenceOpenHashSet<ThreadedRegion<R, S>> set = new ReferenceOpenHashSet<>();
+
+            for (int currZ = fromSectionZ; currZ <= toSectionZ; ++currZ) {
+                for (int currX = fromSectionX; currX <= toSectionX; ++currX) {
+                    final ThreadedRegionSection<R, S> section = this.sections.get(CoordinateUtils.getChunkKey(currX, currZ));
+                    if (section != null) {
+                        set.add(section.getRegionPlain());
+                    }
+                }
+            }
+
+            consumer.accept(set);
+
+            return set.size();
+        } finally {
+            this.releaseWriteLock();
+        }
+    }
+
+    public ThreadedRegion<R, S> getRegionAtUnsynchronised(final int chunkX, final int chunkZ) {
+        final int sectionX = chunkX >> this.sectionChunkShift;
+        final int sectionZ = chunkZ >> this.sectionChunkShift;
+        final long sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+
+        final ThreadedRegionSection<R, S> section = this.sections.get(sectionKey);
+
+        return section == null ? null : section.getRegion();
+    }
+
+    public ThreadedRegion<R, S> getRegionAtSynchronised(final int chunkX, final int chunkZ) {
+        final int sectionX = chunkX >> this.sectionChunkShift;
+        final int sectionZ = chunkZ >> this.sectionChunkShift;
+        final long sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+
+        // try an optimistic read
+        {
+            final long readAttempt = this.regionLock.tryOptimisticRead();
+            final ThreadedRegionSection<R, S> optimisticSection = this.sections.get(sectionKey);
+            final ThreadedRegion<R, S> optimisticRet =
+                optimisticSection == null ? null : optimisticSection.getRegionPlain();
+            if (this.regionLock.validate(readAttempt)) {
+                return optimisticRet;
+            }
+        }
+
+        // failed, fall back to acquiring the lock
+        this.regionLock.readLock();
+        try {
+            final ThreadedRegionSection<R, S> section = this.sections.get(sectionKey);
+
+            return section == null ? null : section.getRegionPlain();
+        } finally {
+            this.regionLock.tryUnlockRead();
+        }
+    }
+
+    /**
+     * Adds a chunk to the regioniser. Note that it is illegal to add a chunk unless
+     * addChunk has not been called for it or removeChunk has been previously called.
+     *
+     * <p>
+     * Note that it is illegal to additionally call addChunk or removeChunk for the same
+     * region section in parallel.
+     * </p>
+     */
+    public void addChunk(final int chunkX, final int chunkZ) {
+        final int sectionX = chunkX >> this.sectionChunkShift;
+        final int sectionZ = chunkZ >> this.sectionChunkShift;
+        final long sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+
+        // Given that for each section, no addChunk/removeChunk can occur in parallel,
+        // we can avoid the lock IF the section exists AND it has a non-zero chunk count.
+        {
+            final ThreadedRegionSection<R, S> existing = this.sections.get(sectionKey);
+            if (existing != null && !existing.isEmpty()) {
+                existing.addChunk(chunkX, chunkZ);
+                return;
+            } // else: just acquire the write lock
+        }
+
+        this.acquireWriteLock();
+        try {
+            ThreadedRegionSection<R, S> section = this.sections.get(sectionKey);
+
+            List<ThreadedRegionSection<R, S>> newSections = new ArrayList<>();
+
+            if (section == null) {
+                // no section at all
+                section = new ThreadedRegionSection<>(sectionX, sectionZ, this, chunkX, chunkZ);
+                this.sections.put(sectionKey, section);
+                newSections.add(section);
+            } else {
+                section.addChunk(chunkX, chunkZ);
+            }
+            // due to the fast check from above, we know the section is empty whether we needed to create it or not
+
+            // enforce the adjacency invariant by creating / updating neighbour sections
+            final int createRadius = this.emptySectionCreateRadius;
+            final int searchRadius = createRadius + this.regionSectionMergeRadius;
+            ReferenceOpenHashSet<ThreadedRegion<R, S>> nearbyRegions = null;
+            for (int dx = -searchRadius; dx <= searchRadius; ++dx) {
+                for (int dz = -searchRadius; dz <= searchRadius; ++dz) {
+                    if ((dx | dz) == 0) {
+                        continue;
+                    }
+                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                    final boolean inCreateRange = squareDistance <= createRadius;
+
+                    final int neighbourX = dx + sectionX;
+                    final int neighbourZ = dz + sectionZ;
+                    final long neighbourKey = CoordinateUtils.getChunkKey(neighbourX, neighbourZ);
+
+                    ThreadedRegionSection<R, S> neighbourSection = this.sections.get(neighbourKey);
+
+                    if (neighbourSection != null) {
+                        if (nearbyRegions == null) {
+                            nearbyRegions = new ReferenceOpenHashSet<>(((searchRadius * 2 + 1) * (searchRadius * 2 + 1)) >> 1);
+                        }
+                        nearbyRegions.add(neighbourSection.getRegionPlain());
+                    }
+
+                    if (!inCreateRange) {
+                        continue;
+                    }
+
+                    // we need to ensure the section exists
+                    if (neighbourSection != null) {
+                        // nothing else to do
+                        neighbourSection.incrementNonEmptyNeighbours();
+                        continue;
+                    }
+                    neighbourSection = new ThreadedRegionSection<>(neighbourX, neighbourZ, this, 1);
+                    if (null != this.sections.put(neighbourKey, neighbourSection)) {
+                        throw new IllegalStateException("Failed to insert new section");
+                    }
+                    newSections.add(neighbourSection);
+                }
+            }
+
+            if (newSections.isEmpty()) {
+                // if we didn't add any sections, then we don't need to merge any regions or create a region
+                return;
+            }
+
+            final ThreadedRegion<R, S> regionOfInterest;
+            final boolean regionOfInterestAlive;
+            if (nearbyRegions == null) {
+                // we can simply create a new region, don't have neighbours to worry about merging into
+                regionOfInterest = new ThreadedRegion<>(this);
+                regionOfInterestAlive = true;
+
+                for (int i = 0, len = newSections.size(); i < len; ++i) {
+                    regionOfInterest.addSection(newSections.get(i));
+                }
+
+                // only call create callback after adding sections
+                regionOfInterest.onCreate();
+            } else {
+                // need to merge the regions
+                ThreadedRegion<R, S> firstUnlockedRegion = null;
+
+                for (final ThreadedRegion<R, S> region : nearbyRegions) {
+                    if (region.isTicking()) {
+                        continue;
+                    }
+                    firstUnlockedRegion = region;
+                    if (firstUnlockedRegion.state == ThreadedRegion.STATE_READY && (!firstUnlockedRegion.mergeIntoLater.isEmpty() || !firstUnlockedRegion.expectingMergeFrom.isEmpty())) {
+                        throw new IllegalStateException("Illegal state for unlocked region " + firstUnlockedRegion);
+                    }
+                    break;
+                }
+
+                if (firstUnlockedRegion != null) {
+                    regionOfInterest = firstUnlockedRegion;
+                } else {
+                    regionOfInterest = new ThreadedRegion<>(this);
+                }
+
+                for (int i = 0, len = newSections.size(); i < len; ++i) {
+                    regionOfInterest.addSection(newSections.get(i));
+                }
+
+                // only call create callback after adding sections
+                if (firstUnlockedRegion == null) {
+                    regionOfInterest.onCreate();
+                }
+
+                if (firstUnlockedRegion != null && nearbyRegions.size() == 1) {
+                    // nothing to do further, no need to merge anything
+                    return;
+                }
+
+                // we need to now tell all the other regions to merge into the region we just created,
+                // and to merge all the ones we can immediately
+
+                for (final ThreadedRegion<R, S> region : nearbyRegions) {
+                    if (region == regionOfInterest) {
+                        continue;
+                    }
+
+                    if (!region.killAndMergeInto(regionOfInterest)) {
+                        // note: the region may already be a merge target
+                        regionOfInterest.mergeIntoLater(region);
+                    }
+                }
+
+                if (firstUnlockedRegion != null && firstUnlockedRegion.state == ThreadedRegion.STATE_READY) {
+                    // we need to retire this region if the merges added other pending merges
+                    if (!firstUnlockedRegion.mergeIntoLater.isEmpty() || !firstUnlockedRegion.expectingMergeFrom.isEmpty()) {
+                        firstUnlockedRegion.state = ThreadedRegion.STATE_TRANSIENT;
+                        this.callbacks.onRegionInactive(firstUnlockedRegion);
+                    }
+                }
+
+                // need to set alive if we created it and there are no pending merges
+                regionOfInterestAlive = firstUnlockedRegion == null && regionOfInterest.mergeIntoLater.isEmpty() && regionOfInterest.expectingMergeFrom.isEmpty();
+            }
+
+            if (regionOfInterestAlive) {
+                regionOfInterest.state = ThreadedRegion.STATE_READY;
+                if (!regionOfInterest.mergeIntoLater.isEmpty() || !regionOfInterest.expectingMergeFrom.isEmpty()) {
+                    throw new IllegalStateException("Should not happen on region " + this);
+                }
+                this.callbacks.onRegionActive(regionOfInterest);
+            }
+
+            if (regionOfInterest.state == ThreadedRegion.STATE_READY) {
+                if (!regionOfInterest.mergeIntoLater.isEmpty() || !regionOfInterest.expectingMergeFrom.isEmpty()) {
+                    throw new IllegalStateException("Should not happen on region " + this);
+                }
+            }
+        } catch (final Throwable throwable) {
+            LOGGER.error("Failed to add chunk (" + chunkX + "," + chunkZ + ")", throwable);
+            SneakyThrow.sneaky(throwable);
+            return; // unreachable
+        } finally {
+            this.releaseWriteLock();
+        }
+    }
+
+    public void removeChunk(final int chunkX, final int chunkZ) {
+        final int sectionX = chunkX >> this.sectionChunkShift;
+        final int sectionZ = chunkZ >> this.sectionChunkShift;
+        final long sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+
+        // Given that for each section, no addChunk/removeChunk can occur in parallel,
+        // we can avoid the lock IF the section exists AND it has a chunk count > 1
+        final ThreadedRegionSection<R, S> section = this.sections.get(sectionKey);
+        if (section == null) {
+            throw new IllegalStateException("Chunk (" + chunkX + "," + chunkZ + ") has no section");
+        }
+        if (!section.hasOnlyOneChunk()) {
+            // chunk will not go empty, so we don't need to acquire the lock
+            section.removeChunk(chunkX, chunkZ);
+            return;
+        }
+
+        this.acquireWriteLock();
+        try {
+            section.removeChunk(chunkX, chunkZ);
+
+            final int searchRadius = this.emptySectionCreateRadius;
+            for (int dx = -searchRadius; dx <= searchRadius; ++dx) {
+                for (int dz = -searchRadius; dz <= searchRadius; ++dz) {
+                    if ((dx | dz) == 0) {
+                        continue;
+                    }
+
+                    final int neighbourX = dx + sectionX;
+                    final int neighbourZ = dz + sectionZ;
+                    final long neighbourKey = CoordinateUtils.getChunkKey(neighbourX, neighbourZ);
+
+                    final ThreadedRegionSection<R, S> neighbourSection = this.sections.get(neighbourKey);
+
+                    // should be non-null here always
+                    neighbourSection.decrementNonEmptyNeighbours();
+                }
+            }
+        } catch (final Throwable throwable) {
+            LOGGER.error("Failed to add chunk (" + chunkX + "," + chunkZ + ")", throwable);
+            SneakyThrow.sneaky(throwable);
+            return; // unreachable
+        } finally {
+            this.releaseWriteLock();
+        }
+    }
+
+    // must hold regionLock
+    private void onRegionRelease(final ThreadedRegion<R, S> region) {
+        if (!region.mergeIntoLater.isEmpty()) {
+            throw new IllegalStateException("Region " + region + " should not have any regions to merge into!");
+        }
+
+        final boolean hasExpectingMerges = !region.expectingMergeFrom.isEmpty();
+
+        // is this region supposed to merge into any other region?
+        if (hasExpectingMerges) {
+            // merge the regions into this one
+            final ReferenceOpenHashSet<ThreadedRegion<R, S>> expectingMergeFrom = region.expectingMergeFrom.clone();
+            for (final ThreadedRegion<R, S> mergeFrom : expectingMergeFrom) {
+                if (!mergeFrom.killAndMergeInto(region)) {
+                    throw new IllegalStateException("Merge from region " + mergeFrom + " should be killable! Trying to merge into " + region);
+                }
+            }
+
+            if (!region.expectingMergeFrom.isEmpty()) {
+                throw new IllegalStateException("Region " + region + " should no longer have merge requests after mering from " + expectingMergeFrom);
+            }
+
+            if (!region.mergeIntoLater.isEmpty()) {
+                // There is another nearby ticking region that we need to merge into
+                region.state = ThreadedRegion.STATE_TRANSIENT;
+                this.callbacks.onRegionInactive(region);
+                // return to avoid removing dead sections or splitting, these actions will be performed
+                // by the region we merge into
+                return;
+            }
+        }
+
+        // now check whether we need to recalculate regions
+        final boolean removeDeadSections = hasExpectingMerges || region.hasNoAliveSections()
+            || (region.sectionByKey.size() >= this.minSectionRecalcCount && region.getDeadSectionPercent() >= this.maxDeadRegionPercent);
+        final boolean removedDeadSections = removeDeadSections && !region.deadSections.isEmpty();
+        if (removeDeadSections) {
+            // kill dead sections
+            for (final ThreadedRegionSection<R, S> deadSection : region.deadSections) {
+                final long key = CoordinateUtils.getChunkKey(deadSection.sectionX, deadSection.sectionZ);
+
+                if (!deadSection.isEmpty()) {
+                    throw new IllegalStateException("Dead section '" + deadSection.toStringWithRegion() + "' is marked dead but has chunks!");
+                }
+                if (deadSection.hasNonEmptyNeighbours()) {
+                    throw new IllegalStateException("Dead section '" + deadSection.toStringWithRegion() + "' is marked dead but has non-empty neighbours!");
+                }
+                if (!region.sectionByKey.remove(key, deadSection)) {
+                    throw new IllegalStateException("Region " + region + " has inconsistent state, it should contain section " + deadSection);
+                }
+                if (this.sections.remove(key) != deadSection) {
+                    throw new IllegalStateException("Cannot remove dead section '" +
+                        deadSection.toStringWithRegion() + "' from section state! State at section coordinate: " + this.sections.get(key));
+                }
+            }
+            region.deadSections.clear();
+        }
+
+        // if we removed dead sections, we should check if the region can be split into smaller ones
+        // otherwise, the region remains alive
+        if (!removedDeadSections) {
+            // didn't remove dead sections, don't check for split
+            region.state = ThreadedRegion.STATE_READY;
+            if (!region.expectingMergeFrom.isEmpty() || !region.mergeIntoLater.isEmpty()) {
+                throw new IllegalStateException("Illegal state " + region);
+            }
+            return;
+        }
+
+        // first, we need to build copy of coordinate->section map of all sections in recalculate
+        final Long2ReferenceOpenHashMap<ThreadedRegionSection<R, S>> recalculateSections = region.sectionByKey.clone();
+
+        if (recalculateSections.isEmpty()) {
+            // looks like the region's sections were all dead, and now there is no region at all
+            region.state = ThreadedRegion.STATE_DEAD;
+            region.onRemove(true);
+            return;
+        }
+
+        // merge radius is max, since recalculateSections includes the dead or empty sections
+        final int mergeRadius = Math.max(this.regionSectionMergeRadius, this.emptySectionCreateRadius);
+
+        final List<List<ThreadedRegionSection<R, S>>> newRegions = new ArrayList<>();
+        while (!recalculateSections.isEmpty()) {
+            // select any section, then BFS around it to find all of its neighbours to form a region
+            // once no more neighbours are found, the region is complete
+            final List<ThreadedRegionSection<R, S>> currRegion = new ArrayList<>();
+            final Iterator<ThreadedRegionSection<R, S>> firstIterator = recalculateSections.values().iterator();
+
+            currRegion.add(firstIterator.next());
+            firstIterator.remove();
+            search_loop:
+            for (int idx = 0; idx < currRegion.size(); ++idx) {
+                final ThreadedRegionSection<R, S> curr = currRegion.get(idx);
+                final int centerX = curr.sectionX;
+                final int centerZ = curr.sectionZ;
+
+                // find neighbours in radius
+                for (int dz = -mergeRadius; dz <= mergeRadius; ++dz) {
+                    for (int dx = -mergeRadius; dx <= mergeRadius; ++dx) {
+                        if ((dx | dz) == 0) {
+                            continue;
+                        }
+
+                        final ThreadedRegionSection<R, S> section = recalculateSections.remove(CoordinateUtils.getChunkKey(dx + centerX, dz + centerZ));
+                        if (section == null) {
+                            continue;
+                        }
+
+                        currRegion.add(section);
+
+                        if (recalculateSections.isEmpty()) {
+                            // no point in searching further
+                            break search_loop;
+                        }
+                    }
+                }
+            }
+
+            newRegions.add(currRegion);
+        }
+
+        // now we have split the regions into separate parts, we can split recalculate
+
+        if (newRegions.size() == 1) {
+            // no need to split anything, we're done here
+            region.state = ThreadedRegion.STATE_READY;
+            if (!region.expectingMergeFrom.isEmpty() || !region.mergeIntoLater.isEmpty()) {
+                throw new IllegalStateException("Illegal state " + region);
+            }
+            return;
+        }
+
+        final List<ThreadedRegion<R, S>> newRegionObjects = new ArrayList<>(newRegions.size());
+        for (int i = 0, len = newRegions.size(); i < len; ++i) {
+            newRegionObjects.add(new ThreadedRegion<>(this));
+        }
+
+        this.callbacks.preSplit(region, newRegionObjects);
+
+        // need to split the region, so we need to kill the old one first
+        region.state = ThreadedRegion.STATE_DEAD;
+        region.onRemove(true);
+
+        // create new regions
+        final Long2ReferenceOpenHashMap<ThreadedRegion<R, S>> newRegionsMap = new Long2ReferenceOpenHashMap<>();
+        final ReferenceOpenHashSet<ThreadedRegion<R, S>> newRegionsSet = new ReferenceOpenHashSet<>(newRegionObjects);
+
+        for (int i = 0, len = newRegions.size(); i < len; i++) {
+            final List<ThreadedRegionSection<R, S>> sections = newRegions.get(i);
+            final ThreadedRegion<R, S> newRegion = newRegionObjects.get(i);
+
+            for (final ThreadedRegionSection<R, S> section : sections) {
+                section.setRegionRelease(null);
+                newRegion.addSection(section);
+                final ThreadedRegion<R, S> curr = newRegionsMap.putIfAbsent(section.sectionKey, newRegion);
+                if (curr != null) {
+                    throw new IllegalStateException("Expected no region at " + section + ", but got " + curr + ", should have put " + newRegion);
+                }
+            }
+        }
+
+        region.split(newRegionsMap, newRegionsSet);
+
+        // only after invoking data callbacks
+
+        for (final ThreadedRegion<R, S> newRegion : newRegionsSet) {
+            newRegion.state = ThreadedRegion.STATE_READY;
+            if (!newRegion.expectingMergeFrom.isEmpty() || !newRegion.mergeIntoLater.isEmpty()) {
+                throw new IllegalStateException("Illegal state " + newRegion);
+            }
+            newRegion.onCreate();
+            this.callbacks.onRegionActive(newRegion);
+        }
+    }
+
+    public static final class ThreadedRegion<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> {
+
+        private static final AtomicLong REGION_ID_GENERATOR = new AtomicLong();
+
+        private static final int STATE_TRANSIENT     = 0;
+        private static final int STATE_READY         = 1;
+        private static final int STATE_TICKING       = 2;
+        private static final int STATE_DEAD          = 3;
+
+        public final long id;
+
+        private int state;
+
+        private final Long2ReferenceOpenHashMap<ThreadedRegionSection<R, S>> sectionByKey = new Long2ReferenceOpenHashMap<>();
+        private final ReferenceOpenHashSet<ThreadedRegionSection<R, S>> deadSections = new ReferenceOpenHashSet<>();
+
+        public final ThreadedRegionizer<R, S> regioniser;
+
+        private final R data;
+
+        private final ReferenceOpenHashSet<ThreadedRegion<R, S>> mergeIntoLater = new ReferenceOpenHashSet<>();
+        private final ReferenceOpenHashSet<ThreadedRegion<R, S>> expectingMergeFrom = new ReferenceOpenHashSet<>();
+
+        public ThreadedRegion(final ThreadedRegionizer<R, S> regioniser) {
+            this.regioniser = regioniser;
+            this.id = REGION_ID_GENERATOR.getAndIncrement();
+            this.state = STATE_TRANSIENT;
+            this.data = regioniser.callbacks.createNewData(this);
+        }
+
+        public LongArrayList getOwnedSections() {
+            final boolean lock = this.regioniser.writeLockOwner != Thread.currentThread();
+            if (lock) {
+                this.regioniser.regionLock.readLock();
+            }
+            try {
+                final LongArrayList ret = new LongArrayList(this.sectionByKey.size());
+                ret.addAll(this.sectionByKey.keySet());
+
+                return ret;
+            } finally {
+                if (lock) {
+                    this.regioniser.regionLock.tryUnlockRead();
+                }
+            }
+        }
+
+        /**
+         * returns an iterator directly over the sections map. This is only to be used by a thread which is _ticking_
+         * 'this' region.
+         */
+        public LongIterator getOwnedSectionsUnsynchronised() {
+            return this.sectionByKey.keySet().iterator();
+        }
+
+        public LongArrayList getOwnedChunks() {
+            final boolean lock = this.regioniser.writeLockOwner != Thread.currentThread();
+            if (lock) {
+                this.regioniser.regionLock.readLock();
+            }
+            try {
+                final LongArrayList ret = new LongArrayList();
+                for (final ThreadedRegionSection<R, S> section : this.sectionByKey.values()) {
+                    ret.addAll(section.getChunks());
+                }
+
+                return ret;
+            } finally {
+                if (lock) {
+                    this.regioniser.regionLock.tryUnlockRead();
+                }
+            }
+        }
+
+        public Long getCenterSection() {
+            final LongArrayList sections = this.getOwnedSections();
+
+            final LongComparator comparator = (final long k1, final long k2) -> {
+                final int x1 = CoordinateUtils.getChunkX(k1);
+                final int x2 = CoordinateUtils.getChunkX(k2);
+
+                final int z1 = CoordinateUtils.getChunkZ(x1);
+                final int z2 = CoordinateUtils.getChunkZ(x2);
+
+                final int zCompare = Integer.compare(z1, z2);
+                if (zCompare != 0) {
+                    return zCompare;
+                }
+
+                return Integer.compare(x1, x2);
+            };
+
+            // note: regions don't always have a chunk section at this point, because the region may have been killed
+            if (sections.isEmpty()) {
+                return null;
+            }
+
+            sections.sort(comparator);
+
+            return Long.valueOf(sections.getLong(sections.size() >> 1));
+        }
+
+        public ChunkPos getCenterChunk() {
+            final LongArrayList chunks = this.getOwnedChunks();
+
+            final LongComparator comparator = (final long k1, final long k2) -> {
+                final int x1 = CoordinateUtils.getChunkX(k1);
+                final int x2 = CoordinateUtils.getChunkX(k2);
+
+                final int z1 = CoordinateUtils.getChunkZ(k1);
+                final int z2 = CoordinateUtils.getChunkZ(k2);
+
+                final int zCompare = Integer.compare(z1, z2);
+                if (zCompare != 0) {
+                    return zCompare;
+                }
+
+                return Integer.compare(x1, x2);
+            };
+            chunks.sort(comparator);
+
+            // note: regions don't always have a chunk at this point, because the region may have been killed
+            if (chunks.isEmpty()) {
+                return null;
+            }
+
+            final long middle = chunks.getLong(chunks.size() >> 1);
+
+            return new ChunkPos(CoordinateUtils.getChunkX(middle), CoordinateUtils.getChunkZ(middle));
+        }
+
+        private void onCreate() {
+            this.regioniser.onRegionCreate(this);
+            this.regioniser.callbacks.onRegionCreate(this);
+        }
+
+        private void onRemove(final boolean wasActive) {
+            if (wasActive) {
+                this.regioniser.callbacks.onRegionInactive(this);
+            }
+            this.regioniser.callbacks.onRegionDestroy(this);
+            this.regioniser.onRegionDestroy(this);
+        }
+
+        private final boolean hasNoAliveSections() {
+            return this.deadSections.size() == this.sectionByKey.size();
+        }
+
+        private final double getDeadSectionPercent() {
+            return (double)this.deadSections.size() / (double)this.sectionByKey.size();
+        }
+
+        private void split(final Long2ReferenceOpenHashMap<ThreadedRegion<R, S>> into, final ReferenceOpenHashSet<ThreadedRegion<R, S>> regions) {
+            if (this.data != null) {
+                this.data.split(this.regioniser, into, regions);
+            }
+        }
+
+        boolean killAndMergeInto(final ThreadedRegion<R, S> mergeTarget) {
+            if (this.state == STATE_TICKING) {
+                return false;
+            }
+
+            this.regioniser.callbacks.preMerge(this, mergeTarget);
+
+            this.tryKill();
+
+            this.mergeInto(mergeTarget);
+
+            return true;
+        }
+
+        private void mergeInto(final ThreadedRegion<R, S> mergeTarget) {
+            if (this == mergeTarget) {
+                throw new IllegalStateException("Cannot merge a region onto itself");
+            }
+            if (!this.isDead()) {
+                throw new IllegalStateException("Source region is not dead! Source " + this + ", target " + mergeTarget);
+            } else if (mergeTarget.isDead()) {
+                throw new IllegalStateException("Target region is dead! Source " + this + ", target " + mergeTarget);
+            }
+
+            for (final ThreadedRegionSection<R, S> section : this.sectionByKey.values()) {
+                section.setRegionRelease(null);
+                mergeTarget.addSection(section);
+            }
+            for (final ThreadedRegionSection<R, S> deadSection : this.deadSections) {
+                if (this.sectionByKey.get(deadSection.sectionKey) != deadSection) {
+                    throw new IllegalStateException("Source region does not even contain its own dead sections! Missing " + deadSection + " from region " + this);
+                }
+                if (!mergeTarget.deadSections.add(deadSection)) {
+                    throw new IllegalStateException("Merge target contains dead section from source! Has " + deadSection + " from region " + this);
+                }
+            }
+
+            // forward merge expectations
+            for (final ThreadedRegion<R, S> region : this.expectingMergeFrom) {
+                if (!region.mergeIntoLater.remove(this)) {
+                    throw new IllegalStateException("Region " + region + " was not supposed to merge into " + this + "?");
+                }
+                if (region != mergeTarget) {
+                    region.mergeIntoLater(mergeTarget);
+                }
+            }
+
+            // forward merge into
+            for (final ThreadedRegion<R, S> region : this.mergeIntoLater) {
+                if (!region.expectingMergeFrom.remove(this)) {
+                    throw new IllegalStateException("Region " + this + " was not supposed to merge into " + region + "?");
+                }
+                if (region != mergeTarget) {
+                    mergeTarget.mergeIntoLater(region);
+                }
+            }
+
+            // finally, merge data
+            if (this.data != null) {
+                this.data.mergeInto(mergeTarget);
+            }
+        }
+
+        private void mergeIntoLater(final ThreadedRegion<R, S> region) {
+            if (region.isDead()) {
+                throw new IllegalStateException("Trying to merge later into a dead region: " + region);
+            }
+            final boolean add1, add2;
+            if ((add1 = this.mergeIntoLater.add(region)) != (add2 = region.expectingMergeFrom.add(this))) {
+                throw new IllegalStateException("Inconsistent state between target merge " + region + " and this " + this + ": add1,add2:" + add1 + "," + add2);
+            }
+        }
+
+        private boolean tryKill() {
+            switch (this.state) {
+                case STATE_TRANSIENT: {
+                    this.state = STATE_DEAD;
+                    this.onRemove(false);
+                    return true;
+                }
+                case STATE_READY: {
+                    this.state = STATE_DEAD;
+                    this.onRemove(true);
+                    return true;
+                }
+                case STATE_TICKING: {
+                    return false;
+                }
+                case STATE_DEAD: {
+                    throw new IllegalStateException("Already dead");
+                }
+                default: {
+                    throw new IllegalStateException("Unknown state: " + this.state);
+                }
+            }
+        }
+
+        private boolean isDead() {
+            return this.state == STATE_DEAD;
+        }
+
+        private boolean isTicking() {
+            return this.state == STATE_TICKING;
+        }
+
+        private void removeDeadSection(final ThreadedRegionSection<R, S> section) {
+            this.deadSections.remove(section);
+        }
+
+        private void addDeadSection(final ThreadedRegionSection<R, S> section) {
+            this.deadSections.add(section);
+        }
+
+        private void addSection(final ThreadedRegionSection<R, S> section) {
+            if (section.getRegionPlain() != null) {
+                throw new IllegalStateException("Section already has region");
+            }
+            if (this.sectionByKey.putIfAbsent(section.sectionKey, section) != null) {
+                throw new IllegalStateException("Already have section " + section + ", mapped to " + this.sectionByKey.get(section.sectionKey));
+            }
+            section.setRegionRelease(this);
+        }
+
+        public R getData() {
+            return this.data;
+        }
+
+        public boolean tryMarkTicking(final BooleanSupplier abort) {
+            this.regioniser.acquireWriteLock();
+            try {
+                if (this.state != STATE_READY || abort.getAsBoolean()) {
+                    return false;
+                }
+
+                if (!this.mergeIntoLater.isEmpty() || !this.expectingMergeFrom.isEmpty()) {
+                    throw new IllegalStateException("Region " + this + " should not be ready");
+                }
+
+                this.state = STATE_TICKING;
+                return true;
+            } finally {
+                this.regioniser.releaseWriteLock();
+            }
+        }
+
+        public boolean markNotTicking() {
+            this.regioniser.acquireWriteLock();
+            try {
+                if (this.state != STATE_TICKING) {
+                    throw new IllegalStateException("Attempting to release non-locked state");
+                }
+
+                this.regioniser.onRegionRelease(this);
+
+                return this.state == STATE_READY;
+            } catch (final Throwable throwable) {
+                LOGGER.error("Failed to release region " + this, throwable);
+                SneakyThrow.sneaky(throwable);
+                return false; // unreachable
+            } finally {
+                this.regioniser.releaseWriteLock();
+            }
+        }
+
+        @Override
+        public String toString() {
+            final StringBuilder ret = new StringBuilder(128);
+
+            ret.append("ThreadedRegion{");
+            ret.append("state=").append(this.state).append(',');
+            // To avoid recursion in toString, maybe fix later?
+            //ret.append("mergeIntoLater=").append(this.mergeIntoLater).append(',');
+            //ret.append("expectingMergeFrom=").append(this.expectingMergeFrom).append(',');
+
+            ret.append("sectionCount=").append(this.sectionByKey.size()).append(',');
+            ret.append("sections=[");
+            for (final Iterator<ThreadedRegionSection<R, S>> iterator = this.sectionByKey.values().iterator(); iterator.hasNext();) {
+                final ThreadedRegionSection<R, S> section = iterator.next();
+
+                ret.append(section.toString());
+                if (iterator.hasNext()) {
+                    ret.append(',');
+                }
+            }
+            ret.append(']');
+
+            ret.append('}');
+            return ret.toString();
+        }
+    }
+
+    public static final class ThreadedRegionSection<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> {
+
+        public final int sectionX;
+        public final int sectionZ;
+        public final long sectionKey;
+        private final long[] chunksBitset;
+        private int chunkCount;
+        private int nonEmptyNeighbours;
+
+        private ThreadedRegion<R, S> region;
+        private static final VarHandle REGION_HANDLE = ConcurrentUtil.getVarHandle(ThreadedRegionSection.class, "region", ThreadedRegion.class);
+
+        public final ThreadedRegionizer<R, S> regioniser;
+
+        private final int regionChunkShift;
+        private final int regionChunkMask;
+
+        private final S data;
+
+        private ThreadedRegion<R, S> getRegionPlain() {
+            return (ThreadedRegion<R, S>)REGION_HANDLE.get(this);
+        }
+
+        private ThreadedRegion<R, S> getRegionAcquire() {
+            return (ThreadedRegion<R, S>)REGION_HANDLE.getAcquire(this);
+        }
+
+        private void setRegionRelease(final ThreadedRegion<R, S> value) {
+            REGION_HANDLE.setRelease(this, value);
+        }
+
+        // creates an empty section with zero non-empty neighbours
+        private ThreadedRegionSection(final int sectionX, final int sectionZ, final ThreadedRegionizer<R, S> regioniser) {
+            this.sectionX = sectionX;
+            this.sectionZ = sectionZ;
+            this.sectionKey = CoordinateUtils.getChunkKey(sectionX, sectionZ);
+            this.chunksBitset = new long[Math.max(1, regioniser.regionSectionChunkSize * regioniser.regionSectionChunkSize / Long.SIZE)];
+            this.regioniser = regioniser;
+            this.regionChunkShift = regioniser.sectionChunkShift;
+            this.regionChunkMask = regioniser.regionSectionChunkSize - 1;
+            this.data = regioniser.callbacks
+                .createNewSectionData(sectionX, sectionZ, this.regionChunkShift);
+        }
+
+        // creates a section with an initial chunk with zero non-empty neighbours
+        private ThreadedRegionSection(final int sectionX, final int sectionZ, final ThreadedRegionizer<R, S> regioniser,
+                                      final int chunkXInit, final int chunkZInit) {
+            this(sectionX, sectionZ, regioniser);
+
+            final int initIndex = this.getChunkIndex(chunkXInit, chunkZInit);
+            this.chunkCount = 1;
+            this.chunksBitset[initIndex >>> 6] = 1L << (initIndex & (Long.SIZE - 1)); // index / Long.SIZE
+        }
+
+        // creates an empty section with the specified number of non-empty neighbours
+        private ThreadedRegionSection(final int sectionX, final int sectionZ, final ThreadedRegionizer<R, S> regioniser,
+                                      final int nonEmptyNeighbours) {
+            this(sectionX, sectionZ, regioniser);
+
+            this.nonEmptyNeighbours = nonEmptyNeighbours;
+        }
+
+        public LongArrayList getChunks() {
+            final LongArrayList ret = new LongArrayList();
+
+            if (this.chunkCount == 0) {
+                return ret;
+            }
+
+            final int shift = this.regionChunkShift;
+            final int mask = this.regionChunkMask;
+            final int offsetX = this.sectionX << shift;
+            final int offsetZ = this.sectionZ << shift;
+
+            final long[] bitset = this.chunksBitset;
+            for (int arrIdx = 0, arrLen = bitset.length; arrIdx < arrLen; ++arrIdx) {
+                long value = bitset[arrIdx];
+
+                for (int i = 0, bits = Long.bitCount(value); i < bits; ++i) {
+                    final int valueIdx = Long.numberOfTrailingZeros(value);
+                    value ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(value);
+
+                    final int idx = valueIdx | (arrIdx << 6);
+
+                    final int localX = idx & mask;
+                    final int localZ = (idx >>> shift) & mask;
+
+                    ret.add(CoordinateUtils.getChunkKey(localX | offsetX, localZ | offsetZ));
+                }
+            }
+
+            return ret;
+        }
+
+        private boolean isEmpty() {
+            return this.chunkCount == 0;
+        }
+
+        private boolean hasOnlyOneChunk() {
+            return this.chunkCount == 1;
+        }
+
+        public boolean hasNonEmptyNeighbours() {
+            return this.nonEmptyNeighbours != 0;
+        }
+
+        /**
+         * Returns the section data associated with this region section. May be {@code null}.
+         */
+        public S getData() {
+            return this.data;
+        }
+
+        /**
+         * Returns the region that owns this section. Unsynchronised access may produce outdateed or transient results.
+         */
+        public ThreadedRegion<R, S> getRegion() {
+            return this.getRegionAcquire();
+        }
+
+        private int getChunkIndex(final int chunkX, final int chunkZ) {
+            return (chunkX & this.regionChunkMask) | ((chunkZ & this.regionChunkMask) << this.regionChunkShift);
+        }
+
+        private void markAlive() {
+            this.getRegionPlain().removeDeadSection(this);
+        }
+
+        private void markDead() {
+            this.getRegionPlain().addDeadSection(this);
+        }
+
+        private void incrementNonEmptyNeighbours() {
+            if (++this.nonEmptyNeighbours == 1 && this.chunkCount == 0) {
+                this.markAlive();
+            }
+            final int createRadius = this.regioniser.emptySectionCreateRadius;
+            if (this.nonEmptyNeighbours >= ((createRadius * 2 + 1) * (createRadius * 2 + 1))) {
+                throw new IllegalStateException("Non empty neighbours exceeded max value for radius " + createRadius);
+            }
+        }
+
+        private void decrementNonEmptyNeighbours() {
+            if (--this.nonEmptyNeighbours == 0 && this.chunkCount == 0) {
+                this.markDead();
+            }
+            if (this.nonEmptyNeighbours < 0) {
+                throw new IllegalStateException("Non empty neighbours reached zero");
+            }
+        }
+
+        /**
+         * Returns whether the chunk was zero. Effectively returns whether the caller needs to create
+         * dead sections / increase non-empty neighbour count for neighbouring sections.
+         */
+        private boolean addChunk(final int chunkX, final int chunkZ) {
+            final int index = this.getChunkIndex(chunkX, chunkZ);
+            final long bitset = this.chunksBitset[index >>> 6]; // index / Long.SIZE
+            final long after = this.chunksBitset[index >>> 6] = bitset | (1L << (index & (Long.SIZE - 1)));
+            if (after == bitset) {
+                throw new IllegalStateException("Cannot add a chunk to a section which already has the chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ).toString());
+            }
+            final boolean notEmpty = ++this.chunkCount == 1;
+            if (notEmpty && this.nonEmptyNeighbours == 0) {
+                this.markAlive();
+            }
+            return notEmpty;
+        }
+
+        /**
+         * Returns whether the chunk count is now zero. Effectively returns whether
+         * the caller needs to decrement the neighbour count for neighbouring sections.
+         */
+        private boolean removeChunk(final int chunkX, final int chunkZ) {
+            final int index = this.getChunkIndex(chunkX, chunkZ);
+            final long before = this.chunksBitset[index >>> 6]; // index / Long.SIZE
+            final long bitset = this.chunksBitset[index >>> 6] = before & ~(1L << (index & (Long.SIZE - 1)));
+            if (before == bitset) {
+                throw new IllegalStateException("Cannot remove a chunk from a section which does not have that chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ).toString());
+            }
+            final boolean empty = --this.chunkCount == 0;
+            if (empty && this.nonEmptyNeighbours == 0) {
+                this.markDead();
+            }
+            return empty;
+        }
+
+        @Override
+        public String toString() {
+            return "RegionSection{" +
+                "sectionCoordinate=" + new ChunkPos(this.sectionX, this.sectionZ).toString() + "," +
+                "chunkCount=" + this.chunkCount + "," +
+                "chunksBitset=" + toString(this.chunksBitset) + "," +
+                "nonEmptyNeighbours=" + this.nonEmptyNeighbours + "," +
+                "hash=" + this.hashCode() +
+                "}";
+        }
+
+        public String toStringWithRegion() {
+            return "RegionSection{" +
+                "sectionCoordinate=" + new ChunkPos(this.sectionX, this.sectionZ).toString() + "," +
+                "chunkCount=" + this.chunkCount + "," +
+                "chunksBitset=" + toString(this.chunksBitset) + "," +
+                "hash=" + this.hashCode() + "," +
+                "nonEmptyNeighbours=" + this.nonEmptyNeighbours + "," +
+                "region=" + this.getRegionAcquire() +
+                "}";
+        }
+
+        private static String toString(final long[] array) {
+            final StringBuilder ret = new StringBuilder();
+            final char[] zeros = new char[Long.SIZE / 4];
+            for (final long value : array) {
+                // zero pad the hex string
+                Arrays.fill(zeros, '0');
+                final String string = Long.toHexString(value);
+                System.arraycopy(string.toCharArray(), 0, zeros, zeros.length - string.length(), string.length());
+
+                ret.append(zeros);
+            }
+
+            return ret.toString();
+        }
+    }
+
+    public static interface ThreadedRegionData<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> {
+
+        /**
+         * Splits this region data into the specified regions set.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param regioniser Regioniser for which the regions reside in.
+         * @param into A map of region section coordinate key to the region that owns the section.
+         * @param regions The set of regions to split into.
+         */
+        public void split(final ThreadedRegionizer<R, S> regioniser, final Long2ReferenceOpenHashMap<ThreadedRegion<R, S>> into,
+                          final ReferenceOpenHashSet<ThreadedRegion<R, S>> regions);
+
+        /**
+         * Callback to merge {@code this} region data into the specified region. The state of the region is undefined
+         * except that its region data is already created.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param into Specified region.
+         */
+        public void mergeInto(final ThreadedRegion<R, S> into);
+    }
+
+    public static interface ThreadedRegionSectionData {}
+
+    public static interface RegionCallbacks<R extends ThreadedRegionData<R, S>, S extends ThreadedRegionSectionData> {
+
+        /**
+         * Creates new section data for the specified section x and section z.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param sectionX x coordinate of the section.
+         * @param sectionZ z coordinate of the section.
+         * @param sectionShift The signed right shift value that can be applied to any chunk coordinate that
+         *                     produces a section coordinate.
+         * @return New section data, may be {@code null}.
+         */
+        public S createNewSectionData(final int sectionX, final int sectionZ, final int sectionShift);
+
+        /**
+         * Creates new region data for the specified region.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param forRegion The region to create the data for.
+         * @return New region data, may be {@code null}.
+         */
+        public R createNewData(final ThreadedRegion<R, S> forRegion);
+
+        /**
+         * Callback for when a region is created. This is invoked after the region is completely set up,
+         * so its data and owned sections are reliable to inspect.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param region The region that was created.
+         */
+        public void onRegionCreate(final ThreadedRegion<R, S> region);
+
+        /**
+         * Callback for when a region is destroyed. This is invoked before the region is actually destroyed; so
+         * its data and owned sections are reliable to inspect.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param region The region that is about to be destroyed.
+         */
+        public void onRegionDestroy(final ThreadedRegion<R, S> region);
+
+        /**
+         * Callback for when a region is considered "active." An active region x is a non-destroyed region which
+         * is not scheduled to merge into another region y and there are no non-destroyed regions z which are
+         * scheduled to merge into the region x. Equivalently, an active region is not directly adjacent to any
+         * other region considering the regioniser's empty section radius.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param region The region that is now active.
+         */
+        public void onRegionActive(final ThreadedRegion<R, S> region);
+
+        /**
+         * Callback for when a region transistions becomes inactive. An inactive region is non-destroyed, but
+         * has neighbouring adjacent regions considering the regioniser's empty section radius. Effectively,
+         * an inactive region may not tick and needs to be merged into its neighbouring regions.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param region The region that is now inactive.
+         */
+        public void onRegionInactive(final ThreadedRegion<R, S> region);
+
+        /**
+         * Callback for when a region (from) is about to be merged into a target region (into). Note that
+         * {@code from} is still alive and is a distinct region.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param from The region that will be merged into the target.
+         * @param into The target of the merge.
+         */
+        public void preMerge(final ThreadedRegion<R, S> from, final ThreadedRegion<R, S> into);
+
+        /**
+         * Callback for when a region (from) is about to be split into a list of target region (into). Note that
+         * {@code from} is still alive, while the list of target regions are not initialised.
+         * <p>
+         * <b>Note:</b>
+         * </p>
+         * <p>
+         * This function is always called while holding critical locks and as such should not attempt to block on anything, and
+         * should NOT retrieve or modify ANY world state.
+         * </p>
+         * @param from The region that will be merged into the target.
+         * @param into The list of regions to split into.
+         */
+        public void preSplit(final ThreadedRegion<R, S> from, final List<ThreadedRegion<R, S>> into);
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/TickRegionScheduler.java b/io/papermc/paper/threadedregions/TickRegionScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..ffb6d2ef658bc658eaf7d26d9d20590fc94432e2
--- /dev/null
+++ b/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -0,0 +1,561 @@
+package io.papermc.paper.threadedregions;
+
+import ca.spottedleaf.concurrentutil.numa.OSNuma;
+import ca.spottedleaf.concurrentutil.scheduler.EDFSchedulerThreadPool;
+import ca.spottedleaf.concurrentutil.scheduler.SchedulableTick;
+import ca.spottedleaf.concurrentutil.scheduler.Scheduler;
+import ca.spottedleaf.concurrentutil.scheduler.StealingScheduledThreadPool;
+import ca.spottedleaf.concurrentutil.util.TimeUtil;
+import ca.spottedleaf.moonrise.common.time.TickData;
+import ca.spottedleaf.moonrise.common.time.TickTime;
+import ca.spottedleaf.moonrise.common.util.MoonriseConstants;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TraceUtil;
+import it.unimi.dsi.fastutil.ints.Int2IntLinkedOpenHashMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.slf4j.Logger;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BooleanSupplier;
+
+public final class TickRegionScheduler {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final ThreadMXBean THREAD_MX_BEAN = ManagementFactory.getThreadMXBean();
+    private static final boolean MEASURE_CPU_TIME;
+    static {
+        MEASURE_CPU_TIME = THREAD_MX_BEAN.isThreadCpuTimeSupported();
+        if (MEASURE_CPU_TIME) {
+            THREAD_MX_BEAN.setThreadCpuTimeEnabled(true);
+        } else {
+            LOGGER.warn("TickRegionScheduler CPU time measurement is not available");
+        }
+    }
+
+    public static final int TICK_RATE = 20;
+    public static final long TIME_BETWEEN_TICKS = 1_000_000_000L / TICK_RATE; // ns
+
+    private final Scheduler scheduler;
+
+    public static enum SchedulerType {
+        EDF,
+        WORK_STEALING;
+    }
+
+    public TickRegionScheduler(final SchedulerType schedulerType, final int initialThreads) {
+        final ThreadFactory threadFactory = new ThreadFactory() {
+            private final AtomicInteger idGenerator = new AtomicInteger();
+            // on Linux, thread affinity is copied from the parent thread - but we do not want that, so we need
+            // to adjust the thread affinity of child threads
+            // the group allows the numa instance to accurately collect the child threads
+            private final ThreadGroup threadGroup = new ThreadGroup("Folia Region Scheduler ThreadGroup");
+
+            @Override
+            public Thread newThread(final Runnable run) {
+                final Thread ret = new TickThreadRunner(this.threadGroup, run, "Folia Region Scheduler Thread #" + this.idGenerator.getAndIncrement());
+                ret.setUncaughtExceptionHandler(TickRegionScheduler.this::uncaughtException);
+                return ret;
+            }
+        };
+
+        switch (schedulerType) {
+            case EDF: {
+                this.scheduler = new EDFSchedulerThreadPool(initialThreads, threadFactory);
+                break;
+            }
+            case WORK_STEALING: {
+                this.scheduler = new StealingScheduledThreadPool(
+                        threadFactory, MoonriseConstants.NUMA_ENABLE ? OSNuma.getNativeInstance() : OSNuma.NoOp.INSTANCE
+                );
+                ((StealingScheduledThreadPool)this.scheduler).setFlags(StealingScheduledThreadPool.FLAG_SCHEDULE_EVENLY);
+                break;
+            }
+            default: {
+                throw new IllegalStateException("Unknown scheduler type: " + schedulerType);
+            }
+        }
+    }
+
+    public void start() {
+        if (this.scheduler instanceof EDFSchedulerThreadPool edfSchedulerThreadPool) {
+            edfSchedulerThreadPool.start();
+        }
+    }
+
+    public void setThreads(final int threads) {
+        if (this.scheduler instanceof StealingScheduledThreadPool stealingScheduledThreadPool) {
+            final Int2IntLinkedOpenHashMap threadAllocation;
+            final long stealThresholdNS = TimeUnit.MILLISECONDS.toNanos(3L);
+            final long taskTimeSliceNS = TimeUnit.MILLISECONDS.toNanos(2L);
+
+            if (!MoonriseConstants.NUMA_ENABLE) {
+                threadAllocation = new Int2IntLinkedOpenHashMap();
+                threadAllocation.put(0, threads);
+
+                LOGGER.info("Folia is using " + threads + " tick threads");
+            } else {
+                final int nodes = stealingScheduledThreadPool.getNuma().getTotalNumaNodes();
+
+                final int threadsPerNode = Math.max(1, threads / nodes);
+
+                threadAllocation = new Int2IntLinkedOpenHashMap(nodes);
+                for (int i = 0; i < nodes; ++i) {
+                    threadAllocation.put(i, threadsPerNode);
+                }
+
+                LOGGER.info("Folia is using " + threadsPerNode + " tick threads per NUMA node, with " + nodes + " NUMA nodes detected");
+            }
+
+            stealingScheduledThreadPool.setThreadAllocation(threadAllocation, stealThresholdNS, taskTimeSliceNS);
+        }
+    }
+
+    public int getTotalThreadCount() {
+        return this.scheduler.getAliveThreads().length;
+    }
+
+    private static void setTickingRegion(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            throw new IllegalStateException("Must be tick thread runner");
+        }
+        if (region != null && tickThreadRunner.currentTickingRegion != null) {
+            throw new IllegalStateException("Trying to double set ticking region!");
+        }
+        if (region == null && tickThreadRunner.currentTickingRegion == null) {
+            throw new IllegalStateException("Trying to double unset ticking region!");
+        }
+        tickThreadRunner.currentTickingRegion = region;
+        if (region != null) {
+            tickThreadRunner.currentTickingWorldRegionizedData = region.regioniser.world.worldRegionData.get();
+        } else {
+            tickThreadRunner.currentTickingWorldRegionizedData = null;
+        }
+    }
+
+    private static void setTickTask(final SchedulableTick task) {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            throw new IllegalStateException("Must be tick thread runner");
+        }
+        if (task != null && tickThreadRunner.currentTickingTask != null) {
+            throw new IllegalStateException("Trying to double set ticking task!");
+        }
+        if (task == null && tickThreadRunner.currentTickingTask == null) {
+            throw new IllegalStateException("Trying to double unset ticking task!");
+        }
+        tickThreadRunner.currentTickingTask = task;
+    }
+
+    /**
+     * Returns the current ticking region, or {@code null} if there is no ticking region.
+     * If this thread is not a TickThread, then returns {@code null}.
+     */
+    public static ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> getCurrentRegion() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return RegionShutdownThread.getRegion();
+        }
+        return tickThreadRunner.currentTickingRegion;
+    }
+
+    /**
+     * Returns the current ticking region's world regionised data, or {@code null} if there is no ticking region.
+     * This is a faster alternative to calling the {@link RegionizedData#get()} method.
+     * If this thread is not a TickThread, then returns {@code null}.
+     */
+    public static RegionizedWorldData getCurrentRegionizedWorldData() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return RegionShutdownThread.getWorldData();
+        }
+        return tickThreadRunner.currentTickingWorldRegionizedData;
+    }
+
+    /**
+     * Returns the current ticking task, or {@code null} if there is no ticking region.
+     * If this thread is not a TickThread, then returns {@code null}.
+     */
+    public static SchedulableTick getCurrentTickingTask() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return null;
+        }
+        return tickThreadRunner.currentTickingTask;
+    }
+
+    /**
+     * Schedules the given region
+     * @throws IllegalStateException If the region is already scheduled or is ticking
+     */
+    public void scheduleRegion(final RegionScheduleHandle region) {
+        region.scheduler = this;
+        this.scheduler.schedule(region);
+    }
+
+    /**
+     * Attempts to de-schedule the provided region. If the current region cannot be cancelled for its next tick or task
+     * execution, then it will be cancelled after.
+     */
+    public void descheduleRegion(final RegionScheduleHandle region) {
+        // To avoid acquiring any of the locks the scheduler may be using, we
+        // simply cancel the next action.
+        region.markNonSchedulable();
+    }
+
+    public boolean halt(final boolean sync, final long maxWaitNS) {
+        this.scheduler.halt();
+        if (!sync) {
+            return this.scheduler.getAliveThreads().length == 0;
+        }
+
+        return this.scheduler.join(maxWaitNS == 0L ? 0L : Math.max(1L, TimeUnit.NANOSECONDS.toMillis(maxWaitNS)));
+    }
+
+    void dumpAliveThreadTraces(final String reason) {
+        for (final Thread thread : this.scheduler.getAliveThreads()) {
+            if (thread.isAlive()) {
+                TraceUtil.dumpTraceForThread(thread, reason);
+            }
+        }
+    }
+
+    public void setHasTasks(final RegionScheduleHandle region) {
+        this.scheduler.notifyTasks(region);
+    }
+
+    private void uncaughtException(final Thread thread, final Throwable thr) {
+        LOGGER.error("Uncaught exception in tick thread \"" + thread.getName() + "\"", thr);
+
+        // prevent further ticks from occurring
+        // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
+        this.scheduler.halt();
+
+        MinecraftServer.getServer().stopServer();
+    }
+
+    private void regionFailed(final RegionScheduleHandle handle, final boolean executingTasks, final Throwable thr) {
+        // when a region fails, we need to shut down the server gracefully
+
+        // prevent further ticks from occurring
+        // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
+        this.scheduler.halt();
+
+        final ChunkPos center = handle.region == null ? null : handle.region.region.getCenterChunk();
+        final ServerLevel world = handle.region == null ? null : handle.region.world;
+
+        LOGGER.error("Region #" + (handle.region == null ? -1L : handle.region.id) + " centered at chunk " + center + " in world '" + (world == null ? "null" : world.getWorld().getName()) + "' failed to " + (executingTasks ? "execute tasks" : "tick") + ":", thr);
+
+        MinecraftServer.getServer().stopServer();
+    }
+
+    // By using our own thread object, we can use a field for the current region rather than a ThreadLocal.
+    // This is much faster than a thread local, since the thread local has to use a map lookup.
+    private static final class TickThreadRunner extends TickThread {
+
+        private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
+        private RegionizedWorldData currentTickingWorldRegionizedData;
+        private SchedulableTick currentTickingTask;
+
+        public TickThreadRunner(final ThreadGroup group, final Runnable run, final String name) {
+            super(group, run, name);
+        }
+    }
+
+    public static abstract class RegionScheduleHandle extends SchedulableTick {
+
+        protected long currentTick;
+        protected long lastTickStart;
+
+        protected final TickData tickTimes5s;
+        protected final TickData tickTimes15s;
+        protected final TickData tickTimes1m;
+        protected final TickData tickTimes5m;
+        protected final TickData tickTimes15m;
+        protected TickTime currentTickData;
+        protected long intermediateTaskTime = 0L;
+        protected long intermediateTaskTimeCPU = 0L;
+        protected Thread currentTickingThread;
+
+        public final TickRegions.TickRegionData region;
+        private final AtomicBoolean cancelled = new AtomicBoolean();
+
+        protected final Schedule tickSchedule;
+
+        private TickRegionScheduler scheduler;
+
+        public RegionScheduleHandle(final TickRegions.TickRegionData region, final long firstStart) {
+            this.currentTick = 0L;
+            this.lastTickStart = TimeUtil.DEADLINE_NOT_SET;
+            this.tickTimes5s = new TickData(TimeUnit.SECONDS.toNanos(5L));
+            this.tickTimes15s = new TickData(TimeUnit.SECONDS.toNanos(15L));
+            this.tickTimes1m = new TickData(TimeUnit.MINUTES.toNanos(1L));
+            this.tickTimes5m = new TickData(TimeUnit.MINUTES.toNanos(5L));
+            this.tickTimes15m = new TickData(TimeUnit.MINUTES.toNanos(15L));
+            this.region = region;
+
+            this.setScheduledStart(firstStart);
+            this.tickSchedule = new Schedule(firstStart == TimeUtil.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
+        }
+
+        /**
+         * Subclasses should call this instead of {@link #setScheduledStart(long)}
+         * so that the tick schedule and scheduled start remain synchronised
+         */
+        protected final void updateScheduledStart(final long to) {
+            this.setScheduledStart(to);
+            this.tickSchedule.setLastPeriod(to == TimeUtil.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS);
+        }
+
+        public final void markNonSchedulable() {
+            this.cancelled.set(true);
+        }
+
+        public final boolean isMarkedAsNonSchedulable() {
+            return this.cancelled.get();
+        }
+
+        protected abstract boolean tryMarkTicking();
+
+        protected abstract boolean markNotTicking();
+
+        protected abstract void tickRegion(final int tickCount, final long startTime, final long scheduledEnd);
+
+        protected abstract void runRegionTasks(final BooleanSupplier canContinue);
+
+        protected abstract boolean hasIntermediateTasks();
+
+        @Override
+        public final boolean hasTasks() {
+            return this.hasIntermediateTasks();
+        }
+
+        @Override
+        public final boolean runTasks(final BooleanSupplier canContinue) {
+            if (this.cancelled.get()) {
+                return false;
+            }
+
+            final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
+            final long tickStart = System.nanoTime();
+
+            if (!this.tryMarkTicking()) {
+                if (!this.cancelled.get()) {
+                    throw new IllegalStateException("Scheduled region should be acquirable");
+                }
+                // region was killed
+                return false;
+            }
+
+            TickRegionScheduler.setTickTask(this);
+            if (this.region != null) {
+                TickRegionScheduler.setTickingRegion(this.region.region);
+            }
+
+            synchronized (this) {
+                this.currentTickingThread = Thread.currentThread();
+            }
+
+            try {
+                this.runRegionTasks(() -> {
+                    return !RegionScheduleHandle.this.cancelled.get() && canContinue.getAsBoolean();
+                });
+            } catch (final Throwable thr) {
+                this.scheduler.regionFailed(this, true, thr);
+                // don't release region for another tick
+                return false;
+            } finally {
+                final long tickEnd = System.nanoTime();
+                final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
+
+                synchronized (this) {
+                    this.intermediateTaskTime += (tickEnd - tickStart);
+                    this.intermediateTaskTimeCPU += (cpuEnd - cpuStart);
+                }
+
+                TickRegionScheduler.setTickTask(null);
+                if (this.region != null) {
+                    TickRegionScheduler.setTickingRegion(null);
+                }
+            }
+
+            return this.markNotTicking() && !this.cancelled.get();
+        }
+
+        @Override
+        public final boolean runTick() {
+            // Remember, we are supposed use setScheduledStart if we return true here, otherwise
+            // the scheduler will try to schedule for the same time.
+            if (this.cancelled.get()) {
+                return false;
+            }
+
+            final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
+            final long tickStart = System.nanoTime();
+
+            // use max(), don't assume that tickStart >= scheduledStart
+            final int tickCount = Math.max(1, this.tickSchedule.getPeriodsAhead(TIME_BETWEEN_TICKS, tickStart));
+
+            if (!this.tryMarkTicking()) {
+                if (!this.cancelled.get()) {
+                    throw new IllegalStateException("Scheduled region should be acquirable");
+                }
+                // region was killed
+                return false;
+            }
+            if (this.cancelled.get()) {
+                this.markNotTicking();
+                // region should be killed
+                return false;
+            }
+
+            TickRegionScheduler.setTickTask(this);
+            if (this.region != null) {
+                TickRegionScheduler.setTickingRegion(this.region.region);
+            }
+            this.incrementTickCount();
+            final long lastTickStart = this.lastTickStart;
+            this.lastTickStart = tickStart;
+
+            final long scheduledStart = this.getScheduledStart();
+            final long scheduledEnd = scheduledStart + TIME_BETWEEN_TICKS;
+
+            final long intermediateTaskTime;
+            final long intermediateTaskTimeCPU;
+
+            synchronized (this) {
+                intermediateTaskTime = this.intermediateTaskTime;
+                intermediateTaskTimeCPU = this.intermediateTaskTimeCPU;
+                this.intermediateTaskTime = 0L;
+                this.intermediateTaskTimeCPU = 0L;
+
+                this.currentTickData = new TickTime(
+                    lastTickStart, scheduledStart, tickStart, cpuStart,
+                    TimeUtil.DEADLINE_NOT_SET, TimeUtil.DEADLINE_NOT_SET,
+                    intermediateTaskTime, intermediateTaskTimeCPU,
+                    MEASURE_CPU_TIME
+                );
+                this.currentTickingThread = Thread.currentThread();
+            }
+
+            try {
+                // next start isn't updated until the end of this tick
+                this.tickRegion(tickCount, tickStart, scheduledEnd);
+            } catch (final Throwable thr) {
+                this.scheduler.regionFailed(this, false, thr);
+                // regionFailed will schedule a shutdown, so we should avoid letting this region tick further
+                return false;
+            } finally {
+                final long tickEnd = System.nanoTime();
+                final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
+
+                // in order to ensure all regions get their chance at scheduling, we have to ensure that regions
+                // that exceed the max tick time are not always prioritised over everything else. Thus, we use the greatest
+                // of the current time and "ideal" next tick start.
+                this.tickSchedule.advanceBy(tickCount, TIME_BETWEEN_TICKS);
+                this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(TIME_BETWEEN_TICKS)));
+
+                final TickTime time = new TickTime(
+                    lastTickStart, scheduledStart, tickStart, cpuStart, tickEnd, cpuEnd,
+                    intermediateTaskTime, intermediateTaskTimeCPU,
+                    MEASURE_CPU_TIME
+                );
+
+                this.addTickTime(time);
+                TickRegionScheduler.setTickTask(null);
+                if (this.region != null) {
+                    TickRegionScheduler.setTickingRegion(null);
+                }
+            }
+
+            // Only AFTER updating the tickStart
+            return this.markNotTicking() && !this.cancelled.get();
+        }
+
+        /**
+         * Only safe to call if this tick data matches the current ticking region.
+         */
+        protected void addTickTime(final TickTime time) {
+            synchronized (this) {
+                this.currentTickData = null;
+                this.currentTickingThread = null;
+                this.tickTimes5s.addDataFrom(time);
+                this.tickTimes15s.addDataFrom(time);
+                this.tickTimes1m.addDataFrom(time);
+                this.tickTimes5m.addDataFrom(time);
+                this.tickTimes15m.addDataFrom(time);
+            }
+        }
+
+        private TickTime adjustCurrentTickData(final long tickEnd) {
+            final TickTime currentTickData = this.currentTickData;
+            if (currentTickData == null) {
+                return null;
+            }
+
+            final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getThreadCpuTime(this.currentTickingThread.threadId()) : 0L;
+
+            return new TickTime(
+                currentTickData.previousTickStart(), currentTickData.scheduledTickStart(),
+                currentTickData.tickStart(), currentTickData.tickStartCPU(),
+                tickEnd, cpuEnd, 0L, 0L, // TODO
+                MEASURE_CPU_TIME
+            );
+        }
+
+        public final TickData.TickReportData getTickReport5s(final long currTime) {
+            synchronized (this) {
+                return this.tickTimes5s.generateTickReport(this.adjustCurrentTickData(currTime), currTime, TIME_BETWEEN_TICKS);
+            }
+        }
+
+        public final TickData.TickReportData getTickReport15s(final long currTime) {
+            synchronized (this) {
+                return this.tickTimes15s.generateTickReport(this.adjustCurrentTickData(currTime), currTime, TIME_BETWEEN_TICKS);
+            }
+        }
+
+        public final TickData.TickReportData getTickReport1m(final long currTime) {
+            synchronized (this) {
+                return this.tickTimes1m.generateTickReport(this.adjustCurrentTickData(currTime), currTime, TIME_BETWEEN_TICKS);
+            }
+        }
+
+        public final TickData.TickReportData getTickReport5m(final long currTime) {
+            synchronized (this) {
+                return this.tickTimes5m.generateTickReport(this.adjustCurrentTickData(currTime), currTime, TIME_BETWEEN_TICKS);
+            }
+        }
+
+        public final TickData.TickReportData getTickReport15m(final long currTime) {
+            synchronized (this) {
+                return this.tickTimes15m.generateTickReport(this.adjustCurrentTickData(currTime), currTime, TIME_BETWEEN_TICKS);
+            }
+        }
+
+        /**
+         * Only safe to call if this tick data matches the current ticking region.
+         */
+        private void incrementTickCount() {
+            ++this.currentTick;
+        }
+
+        /**
+         * Only safe to call if this tick data matches the current ticking region.
+         */
+        public final long getCurrentTick() {
+            return this.currentTick;
+        }
+
+        protected final void setCurrentTick(final long value) {
+            this.currentTick = value;
+        }
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/TickRegions.java b/io/papermc/paper/threadedregions/TickRegions.java
index 8424cf9d4617b4732d44cc460d25b04481068989..40d2883d86a43175b49260bd2cb17459cc329639 100644
--- a/io/papermc/paper/threadedregions/TickRegions.java
+++ b/io/papermc/paper/threadedregions/TickRegions.java
@@ -1,10 +1,486 @@
 package io.papermc.paper.threadedregions;
 
-// placeholder class for Folia
-public class TickRegions {
+import ca.spottedleaf.concurrentutil.numa.OSNuma;
+import ca.spottedleaf.concurrentutil.util.TimeUtil;
+import ca.spottedleaf.moonrise.common.time.TickTime;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceMap;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceMap;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.network.PacketProcessor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import org.slf4j.Logger;
+import java.util.Iterator;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BooleanSupplier;
+
+public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private static int regionShift = 31;
 
     public static int getRegionChunkShift() {
-        return ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ThreadedTicketLevelPropagator.SECTION_SHIFT;
+        return regionShift;
+    }
+
+    private static boolean initialised;
+    private static boolean started;
+    private static TickRegionScheduler scheduler;
+
+    public static TickRegionScheduler getScheduler() {
+        return scheduler;
+    }
+
+    private static int getTickThreads(final GlobalConfiguration.ThreadedRegions config) {
+        int tickThreads;
+        if (config.threads <= 0) {
+            tickThreads = OSNuma.getNativeInstance().getTotalCores() / 2;
+            if (tickThreads <= 4) {
+                tickThreads = 1;
+            } else {
+                tickThreads =  tickThreads / 4;
+            }
+        } else {
+            tickThreads = config.threads;
+        }
+
+        return tickThreads;
+    }
+
+    public static void init(final GlobalConfiguration.ThreadedRegions config) {
+        final int tickThreads = getTickThreads(config);
+        if (initialised) {
+            if (started) {
+                scheduler.setThreads(tickThreads);
+            }
+            return;
+        }
+        initialised = true;
+        int gridExponent = config.gridExponent;
+        gridExponent = Math.max(0, gridExponent);
+        gridExponent = Math.min(31, gridExponent);
+        regionShift = gridExponent;
+        scheduler = new TickRegionScheduler(config.scheduler, tickThreads);
+        LOGGER.info("Initialised " + config.scheduler + " Folia scheduler with initial " + tickThreads + " target thread(s)");
+    }
+
+    public static void start() {
+        if (started) {
+            throw new IllegalStateException("Already started");
+        }
+        started = true;
+        scheduler.setThreads(getTickThreads(GlobalConfiguration.get().threadedRegions));
+        scheduler.start();
+     }
+
+    @Override
+    public TickRegionData createNewData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+        return new TickRegionData(region);
+    }
+
+    @Override
+    public TickRegionSectionData createNewSectionData(final int sectionX, final int sectionZ, final int sectionShift) {
+        return null;
     }
 
+    @Override
+    public void onRegionCreate(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+        final TickRegionData data = region.getData();
+        // post-region merge/split regioninfo update
+        data.getRegionStats().updateFrom(data.getOrCreateRegionizedData(data.world.worldRegionData));
+    }
+
+    @Override
+    public void onRegionDestroy(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+        // nothing for now
+    }
+
+    @Override
+    public void onRegionActive(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+        final TickRegionData data = region.getData();
+
+        data.tickHandle.checkInitialSchedule();
+        scheduler.scheduleRegion(data.tickHandle);
+    }
+
+    @Override
+    public void onRegionInactive(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+        final TickRegionData data = region.getData();
+
+        scheduler.descheduleRegion(data.tickHandle);
+        // old handle cannot be scheduled anymore, copy to a new handle
+        data.tickHandle = data.tickHandle.copy();
+    }
+
+    @Override
+    public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
+                         final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> into) {
+
+    }
+
+    @Override
+    public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
+                         final java.util.List<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> into) {
+
+    }
+
+    public static final class TickRegionSectionData implements ThreadedRegionizer.ThreadedRegionSectionData {}
+
+    public static final class RegionStats {
+
+        private final AtomicInteger entityCount = new AtomicInteger();
+        private final AtomicInteger playerCount = new AtomicInteger();
+        private final AtomicInteger chunkCount = new AtomicInteger();
+
+        public int getEntityCount() {
+            return this.entityCount.get();
+        }
+
+        public int getPlayerCount() {
+            return this.playerCount.get();
+        }
+
+        public int getChunkCount() {
+            return this.chunkCount.get();
+        }
+
+        void updateFrom(final RegionizedWorldData data) {
+            this.entityCount.setRelease(data == null ? 0 : data.getEntityCount());
+            this.playerCount.setRelease(data == null ? 0 : data.getPlayerCount());
+            this.chunkCount.setRelease(data == null ? 0 : data.getChunkCount());
+        }
+
+        static void updateCurrentRegion() {
+            TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+    }
+
+    public static final class TickRegionData implements ThreadedRegionizer.ThreadedRegionData<TickRegionData, TickRegionSectionData> {
+
+        private static final AtomicLong ID_GENERATOR = new AtomicLong();
+        /** Never 0L, since 0L is reserved for global region. */
+        public final long id = ID_GENERATOR.incrementAndGet();
+
+        public final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region;
+        public final ServerLevel world;
+
+        // generic regionised data
+        private final Reference2ReferenceOpenHashMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
+
+        // tick data
+        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, TimeUtil.DEADLINE_NOT_SET);
+
+        // queue data
+        private final RegionizedTaskQueue.RegionTaskQueueData taskQueueData;
+
+        // chunk holder manager data
+        private final ChunkHolderManager.HolderManagerRegionData holderManagerRegionData = new ChunkHolderManager.HolderManagerRegionData();
+
+        // async-safe read-only region data
+        private final RegionStats regionStats;
+
+        private final AtomicBoolean hasPackets = new AtomicBoolean(false);
+
+        private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
+            this.region = region;
+            this.world = region.regioniser.world;
+            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData, this);
+            this.regionStats = new RegionStats();
+        }
+
+        public void setHasTasks() {
+            TickRegions.getScheduler().setHasTasks(this.tickHandle);
+        }
+
+        public void setHasPackets() {
+            if (!this.hasPackets.get() && !this.hasPackets.compareAndExchange(false, true)) {
+                this.setHasTasks();
+            }
+        }
+
+        public boolean drainOnePacket() {
+            if (!this.hasPackets.get()) {
+                return false;
+            }
+
+            final RegionizedWorldData worldData = this.world.getCurrentWorldData();
+            boolean hasPacketsNew = false;
+
+            for (final ServerPlayer player : worldData.getLocalPlayers()) {
+                final PacketProcessor packetProcessor = player.getBukkitEntity().packetProcessor;
+                if (!packetProcessor.hasPackets()) {
+                    continue;
+                }
+                if (!TickThread.isTickThreadFor(player)) {
+                    continue;
+                }
+                if (packetProcessor.executeSinglePacket()) {
+                    hasPacketsNew |= packetProcessor.hasPackets();
+                }
+            }
+
+            if (!hasPacketsNew) {
+                this.hasPackets.set(false);
+
+                // handle race condition: packet added during packet processing
+                for (final ServerPlayer player : worldData.getLocalPlayers()) {
+                    if (player.getBukkitEntity().packetProcessor.hasPackets()) {
+                        this.hasPackets.set(true);
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        public RegionStats getRegionStats() {
+            return this.regionStats;
+        }
+
+        public RegionizedTaskQueue.RegionTaskQueueData getTaskQueueData() {
+            return this.taskQueueData;
+        }
+
+        // the value returned can be invalidated at any time, except when the caller
+        // is ticking this region
+        public TickRegionScheduler.RegionScheduleHandle getRegionSchedulingHandle() {
+            return this.tickHandle;
+        }
+
+        public long getCurrentTick() {
+            return this.tickHandle.getCurrentTick();
+        }
+
+        public ChunkHolderManager.HolderManagerRegionData getHolderManagerRegionData() {
+            return this.holderManagerRegionData;
+        }
+
+        <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
+            return (T)this.regionizedData.get(regionizedData);
+        }
+
+        <T> T getOrCreateRegionizedData(final RegionizedData<T> regionizedData) {
+            T ret = (T)this.regionizedData.get(regionizedData);
+
+            if (ret != null) {
+                return ret;
+            }
+
+            ret = regionizedData.createNewValue(this);
+            this.regionizedData.put(regionizedData, ret);
+
+            return ret;
+        }
+
+        @Override
+        public void split(final ThreadedRegionizer<TickRegionData, TickRegionSectionData> regioniser,
+                          final Long2ReferenceOpenHashMap<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> into,
+                          final ReferenceOpenHashSet<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> regions) {
+            final int shift = regioniser.sectionChunkShift;
+
+            // tick data
+            // note: here it is OK force us to access tick handle, as this region is owned (and thus not scheduled),
+            // and the other regions to split into are not scheduled yet.
+            for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
+                final TickRegionData data = region.getData();
+                data.tickHandle.copyDeadlineAndTickCount(this.tickHandle);
+                // just be lazy about this one, it's not very important
+                if (this.hasPackets.getOpaque()) {
+                    data.hasPackets.setOpaque(true);
+                }
+            }
+
+            // generic regionised data
+            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> dataIterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator();
+                 dataIterator.hasNext();) {
+                final Reference2ReferenceMap.Entry<RegionizedData<?>, Object> regionDataEntry = dataIterator.next();
+                final RegionizedData<?> data = regionDataEntry.getKey();
+                final Object from = regionDataEntry.getValue();
+
+                final ReferenceOpenHashSet<Object> dataSet = new ReferenceOpenHashSet<>(regions.size(), 0.75f);
+
+                for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
+                    dataSet.add(region.getData().getOrCreateRegionizedData(data));
+                }
+
+                final Long2ReferenceOpenHashMap<Object> regionToData = new Long2ReferenceOpenHashMap<>(into.size(), 0.75f);
+
+                for (final Iterator<Long2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>>> regionIterator = into.long2ReferenceEntrySet().fastIterator();
+                     regionIterator.hasNext();) {
+                    final Long2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> entry = regionIterator.next();
+                    final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region = entry.getValue();
+                    final Object to = region.getData().getOrCreateRegionizedData(data);
+
+                    regionToData.put(entry.getLongKey(), to);
+                }
+
+                ((RegionizedData<Object>)data).getCallback().split(from, shift, regionToData, dataSet);
+            }
+
+            // chunk holder manager data
+            {
+                final ReferenceOpenHashSet<ChunkHolderManager.HolderManagerRegionData> dataSet = new ReferenceOpenHashSet<>(regions.size(), 0.75f);
+
+                for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
+                    dataSet.add(region.getData().holderManagerRegionData);
+                }
+
+                final Long2ReferenceOpenHashMap<ChunkHolderManager.HolderManagerRegionData> regionToData = new Long2ReferenceOpenHashMap<>(into.size(), 0.75f);
+
+                for (final Iterator<Long2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>>> regionIterator = into.long2ReferenceEntrySet().fastIterator();
+                     regionIterator.hasNext();) {
+                    final Long2ReferenceMap.Entry<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> entry = regionIterator.next();
+                    final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region = entry.getValue();
+                    final ChunkHolderManager.HolderManagerRegionData to = region.getData().holderManagerRegionData;
+
+                    regionToData.put(entry.getLongKey(), to);
+                }
+
+                this.holderManagerRegionData.split(shift, regionToData, dataSet);
+            }
+
+            // task queue
+            this.taskQueueData.split(regioniser, into);
+        }
+
+        @Override
+        public void mergeInto(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> into) {
+            // Note: merge target is always a region being released from ticking
+            final TickRegionData data = into.getData();
+            final long currentTickTo = data.getCurrentTick();
+            final long currentTickFrom = this.getCurrentTick();
+
+            // here we can access tickHandle because the target (into) is the region being released, so it is
+            // not actually scheduled
+            // there's not really a great solution to the tick problem, no matter what it'll be messed up
+            // we will pick the greatest time delay so that tps will not exceed TICK_RATE
+            data.tickHandle.updateSchedulingToMax(this.tickHandle);
+            // just be lazy about this one, it's not very important
+            if (this.hasPackets.getOpaque()) {
+                data.hasPackets.setOpaque(true);
+            }
+
+            // generic regionised data
+            final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
+            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> iterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator();
+                 iterator.hasNext();) {
+                final Reference2ReferenceMap.Entry<RegionizedData<?>, Object> entry = iterator.next();
+                final RegionizedData<?> regionizedData = entry.getKey();
+                final Object from = entry.getValue();
+                final Object to = into.getData().getOrCreateRegionizedData(regionizedData);
+
+                ((RegionizedData<Object>)regionizedData).getCallback().merge(from, to, fromTickOffset);
+            }
+
+            // chunk holder manager data
+            this.holderManagerRegionData.merge(into.getData().holderManagerRegionData, fromTickOffset);
+
+            // task queue
+            this.taskQueueData.mergeInto(data.taskQueueData);
+        }
+    }
+
+    private static final class ConcreteRegionTickHandle extends TickRegionScheduler.RegionScheduleHandle {
+
+        private final TickRegionData region;
+
+        private ConcreteRegionTickHandle(final TickRegionData region, final long start) {
+            super(region, start);
+            this.region = region;
+        }
+
+        private ConcreteRegionTickHandle copy() {
+            final ConcreteRegionTickHandle ret = new ConcreteRegionTickHandle(this.region, this.getScheduledStart());
+
+            ret.currentTick = this.currentTick;
+            ret.lastTickStart = this.lastTickStart;
+            ret.tickSchedule.setLastPeriod(this.tickSchedule.getLastPeriod());
+
+            return ret;
+        }
+
+        private void updateSchedulingToMax(final ConcreteRegionTickHandle from) {
+            if (from.getScheduledStart() == TimeUtil.DEADLINE_NOT_SET) {
+                return;
+            }
+
+            if (this.getScheduledStart() == TimeUtil.DEADLINE_NOT_SET) {
+                this.updateScheduledStart(from.getScheduledStart());
+                return;
+            }
+
+            this.updateScheduledStart(TimeUtil.getGreatestTime(from.getScheduledStart(), this.getScheduledStart()));
+        }
+
+        private void copyDeadlineAndTickCount(final ConcreteRegionTickHandle from) {
+            this.currentTick = from.currentTick;
+
+            if (from.getScheduledStart() == TimeUtil.DEADLINE_NOT_SET) {
+                return;
+            }
+
+            this.tickSchedule.setLastPeriod(from.tickSchedule.getLastPeriod());
+            this.setScheduledStart(from.getScheduledStart());
+        }
+
+        private void checkInitialSchedule() {
+            if (this.getScheduledStart() == TimeUtil.DEADLINE_NOT_SET) {
+                this.updateScheduledStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
+            }
+        }
+
+        @Override
+        protected boolean tryMarkTicking() {
+            return this.region.region.tryMarkTicking(ConcreteRegionTickHandle.this::isMarkedAsNonSchedulable);
+        }
+
+        @Override
+        protected boolean markNotTicking() {
+            return this.region.region.markNotTicking();
+        }
+
+        @Override
+        protected void tickRegion(final int tickCount, final long startTime, final long scheduledEnd) {
+            MinecraftServer.getServer().tickServer(startTime, scheduledEnd, TimeUnit.MILLISECONDS.toMillis(10L), this.region);
+        }
+
+        @Override
+        protected void runRegionTasks(final BooleanSupplier canContinue) {
+            final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
+
+            boolean processedChunkTask = false;
+
+            boolean executeChunkTask;
+            boolean executeTickTask;
+            boolean executePacketTask;
+            do {
+                executeTickTask = queue.executeTickTask();
+                executeChunkTask = queue.executeChunkTask();
+                executePacketTask = this.region.drainOnePacket();
+
+                processedChunkTask |= executeChunkTask;
+            } while ((executeChunkTask | executeTickTask | executePacketTask) && canContinue.getAsBoolean());
+
+            if (processedChunkTask) {
+                // if we processed any chunk tasks, try to process ticket level updates for full status changes
+                this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
+            }
+        }
+
+        @Override
+        protected boolean hasIntermediateTasks() {
+            return this.region.taskQueueData.hasTasks() || this.region.hasPackets.get();
+        }
+    }
 }
diff --git a/io/papermc/paper/threadedregions/commands/CommandServerHealth.java b/io/papermc/paper/threadedregions/commands/CommandServerHealth.java
new file mode 100644
index 0000000000000000000000000000000000000000..2bb43161f4864c37d8c50854c6608dd02acf1fc7
--- /dev/null
+++ b/io/papermc/paper/threadedregions/commands/CommandServerHealth.java
@@ -0,0 +1,354 @@
+package io.papermc.paper.threadedregions.commands;
+
+import ca.spottedleaf.moonrise.common.time.TickData;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+
+public final class CommandServerHealth extends Command {
+
+    private static final ThreadLocal<DecimalFormat> TWO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.00");
+    });
+    private static final ThreadLocal<DecimalFormat> ONE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.0");
+    });
+    private static final ThreadLocal<DecimalFormat> NO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0");
+    });
+
+    private static final TextColor HEADER = TextColor.color(79, 164, 240);
+    private static final TextColor PRIMARY = TextColor.color(48, 145, 237);
+    private static final TextColor SECONDARY = TextColor.color(104, 177, 240);
+    private static final TextColor INFORMATION = TextColor.color(145, 198, 243);
+    private static final TextColor LIST = TextColor.color(33, 97, 188);
+
+    public CommandServerHealth() {
+        super("tps");
+        this.setUsage("/<command> [server/region] [lowest regions to display]");
+        this.setDescription("Reports information about server health.");
+        this.setPermission("bukkit.command.tps");
+    }
+
+    private static Component formatRegionInfo(final String prefix, final double util, final double mspt, final double tps,
+                                              final boolean newline) {
+        return Component.text()
+            .append(Component.text(prefix, PRIMARY, TextDecoration.BOLD))
+            .append(Component.text(ONE_DECIMAL_PLACES.get().format(util * 100.0), CommandUtil.getUtilisationColourRegion(util)))
+            .append(Component.text("% util at ", PRIMARY))
+            .append(Component.text(TWO_DECIMAL_PLACES.get().format(mspt), CommandUtil.getColourForMSPT(mspt)))
+            .append(Component.text(" MSPT at ", PRIMARY))
+            .append(Component.text(TWO_DECIMAL_PLACES.get().format(tps), CommandUtil.getColourForTPS(tps)))
+            .append(Component.text(" TPS" + (newline ? "\n" : ""), PRIMARY))
+            .build();
+    }
+
+    private static Component formatRegionStats(final TickRegions.RegionStats stats, final boolean newline) {
+        return Component.text()
+            .append(Component.text("Chunks: ", PRIMARY))
+            .append(Component.text(NO_DECIMAL_PLACES.get().format((long)stats.getChunkCount()), INFORMATION))
+            .append(Component.text(" Players: ", PRIMARY))
+            .append(Component.text(NO_DECIMAL_PLACES.get().format((long)stats.getPlayerCount()), INFORMATION))
+            .append(Component.text(" Entities: ", PRIMARY))
+            .append(Component.text(NO_DECIMAL_PLACES.get().format((long)stats.getEntityCount()) + (newline ? "\n" : ""), INFORMATION))
+            .build();
+    }
+
+    private static boolean executeRegion(final CommandSender sender, final String commandLabel, final String[] args) {
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            sender.sendMessage(Component.text("You are not in a region currently", NamedTextColor.RED));
+            return true;
+        }
+
+        final long currTime = System.nanoTime();
+
+        final TickData.TickReportData report15s = region.getData().getRegionSchedulingHandle().getTickReport15s(currTime);
+        final TickData.TickReportData report1m = region.getData().getRegionSchedulingHandle().getTickReport1m(currTime);
+
+        final ServerLevel world = region.regioniser.world;
+        final ChunkPos chunkCenter = region.getCenterChunk();
+        final int centerBlockX = ((chunkCenter.x << 4) | 7);
+        final int centerBlockZ = ((chunkCenter.z << 4) | 7);
+
+        final double util15s = report15s.utilisation();
+        final double tps15s = report15s.tpsData().segmentAll().average();
+        final double mspt15s = report15s.timePerTickData().segmentAll().average() / 1.0E6;
+
+        final double util1m = report1m.utilisation();
+        final double tps1m = report1m.tpsData().segmentAll().average();
+        final double mspt1m = report1m.timePerTickData().segmentAll().average() / 1.0E6;
+
+        final int yLoc = 80;
+        final String location = "[w:'" + world.getWorld().getName() + "'," + centerBlockX + "," + yLoc + "," + centerBlockZ + "]";
+
+        final Component line = Component.text()
+            .append(Component.text("Region around block ", PRIMARY))
+            .append(Component.text(location, INFORMATION))
+            .append(Component.text(":\n", PRIMARY))
+
+            .append(
+                formatRegionInfo("15s: ", util15s, mspt15s, tps15s, true)
+            )
+            .append(
+                formatRegionInfo("1m: ", util1m, mspt1m, tps1m, true)
+            )
+            .append(
+                formatRegionStats(region.getData().getRegionStats(), false)
+            )
+
+            .build();
+
+        sender.sendMessage(line);
+
+        return true;
+    }
+
+    private static boolean executeServer(final CommandSender sender, final String commandLabel, final String[] args) {
+        final int lowestRegionsCount;
+        if (args.length < 2) {
+            lowestRegionsCount = 3;
+        } else {
+            try {
+                lowestRegionsCount = Integer.parseInt(args[1]);
+            } catch (final NumberFormatException ex) {
+                sender.sendMessage(Component.text("Highest utilisation count '" + args[1] + "' must be an integer", NamedTextColor.RED));
+                return true;
+            }
+        }
+
+        final List<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> regions =
+            new ArrayList<>();
+
+        for (final World bukkitWorld : Bukkit.getWorlds()) {
+            final ServerLevel world = ((CraftWorld)bukkitWorld).getHandle();
+            world.regioniser.computeForAllRegions(regions::add);
+        }
+
+        final double minTps;
+        final double medianTps;
+        final double maxTps;
+        double totalUtil = 0.0;
+
+        final DoubleArrayList tpsByRegion = new DoubleArrayList();
+        final List<TickData.TickReportData> reportsByRegion = new ArrayList<>();
+        final int maxThreadCount = TickRegions.getScheduler().getTotalThreadCount();
+
+        final long currTime = System.nanoTime();
+        final TickData.TickReportData globalTickReport = RegionizedServer.getGlobalTickData().getTickReport15s(currTime);
+
+        for (final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region : regions) {
+            final TickData.TickReportData report = region.getData().getRegionSchedulingHandle().getTickReport15s(currTime);
+            tpsByRegion.add(report == null ? 20.0 : report.tpsData().segmentAll().average());
+            reportsByRegion.add(report);
+            totalUtil += (report == null ? 0.0 : report.utilisation());
+        }
+
+        totalUtil += globalTickReport.utilisation();
+
+        tpsByRegion.sort(null);
+        if (!tpsByRegion.isEmpty()) {
+            minTps = tpsByRegion.getDouble(0);
+            maxTps = tpsByRegion.getDouble(tpsByRegion.size() - 1);
+
+            final int middle = tpsByRegion.size() >> 1;
+            if ((tpsByRegion.size() & 1) == 0) {
+                // even, average the two middle points
+                medianTps = (tpsByRegion.getDouble(middle - 1) + tpsByRegion.getDouble(middle)) / 2.0;
+            } else {
+                // odd, can just grab middle
+                medianTps = tpsByRegion.getDouble(middle);
+            }
+        } else {
+            // no regions = green
+            minTps = medianTps = maxTps = 20.0;
+        }
+
+        final List<ObjectObjectImmutablePair<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, TickData.TickReportData>>
+            regionsBelowThreshold = new ArrayList<>();
+
+        for (int i = 0, len = regions.size(); i < len; ++i) {
+            final TickData.TickReportData report = reportsByRegion.get(i);
+
+            regionsBelowThreshold.add(new ObjectObjectImmutablePair<>(regions.get(i), report));
+        }
+
+        regionsBelowThreshold.sort((p1, p2) -> {
+            final TickData.TickReportData report1 = p1.right();
+            final TickData.TickReportData report2 = p2.right();
+            final double util1 = report1 == null ? 0.0 : report1.utilisation();
+            final double util2 = report2 == null ? 0.0 : report2.utilisation();
+
+            // we want the largest first
+            return Double.compare(util2, util1);
+        });
+
+        final TextComponent.Builder lowestRegionsBuilder = Component.text();
+
+        if (sender instanceof Player) {
+            lowestRegionsBuilder.append(Component.text(" Click to teleport\n", SECONDARY));
+        }
+        for (int i = 0, len = Math.min(lowestRegionsCount, regionsBelowThreshold.size()); i < len; ++i) {
+            final ObjectObjectImmutablePair<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, TickData.TickReportData>
+                pair = regionsBelowThreshold.get(i);
+
+            final TickData.TickReportData report = pair.right();
+            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                pair.left();
+
+            if (report == null) {
+                // skip regions with no data
+                continue;
+            }
+
+            final ServerLevel world = region.regioniser.world;
+            final ChunkPos chunkCenter = region.getCenterChunk();
+            if (chunkCenter == null) {
+                // region does not exist anymore
+                continue;
+            }
+            final int centerBlockX = ((chunkCenter.x << 4) | 7);
+            final int centerBlockZ = ((chunkCenter.z << 4) | 7);
+            final double util = report.utilisation();
+            final double tps = report.tpsData().segmentAll().average();
+            final double mspt = report.timePerTickData().segmentAll().average() / 1.0E6;
+
+            final int yLoc = 80;
+            final String location = "[w:'" + world.getWorld().getName() + "'," + centerBlockX + "," + yLoc + "," + centerBlockZ + "]";
+            final Component line = Component.text()
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Region around block ", PRIMARY))
+                .append(Component.text(location, INFORMATION))
+                .append(Component.text(":\n", PRIMARY))
+
+                .append(Component.text("    ", PRIMARY))
+                .append(Component.text(ONE_DECIMAL_PLACES.get().format(util * 100.0), CommandUtil.getUtilisationColourRegion(util)))
+                .append(Component.text("% util at ", PRIMARY))
+                .append(Component.text(TWO_DECIMAL_PLACES.get().format(mspt), CommandUtil.getColourForMSPT(mspt)))
+                .append(Component.text(" MSPT at ", PRIMARY))
+                .append(Component.text(TWO_DECIMAL_PLACES.get().format(tps), CommandUtil.getColourForTPS(tps)))
+                .append(Component.text(" TPS\n", PRIMARY))
+
+                .append(Component.text("    ", PRIMARY))
+                .append(formatRegionStats(region.getData().getRegionStats(), (i + 1) != len))
+                .build()
+
+                .clickEvent(ClickEvent.clickEvent(ClickEvent.Action.RUN_COMMAND, "/minecraft:execute as @s in " + world.getWorld().getKey().toString() + " run tp " + centerBlockX + ".5 " + yLoc + " " + centerBlockZ + ".5"))
+                .hoverEvent(HoverEvent.hoverEvent(HoverEvent.Action.SHOW_TEXT, Component.text("Click to teleport to " + location, SECONDARY)));
+
+            lowestRegionsBuilder.append(line);
+        }
+
+        sender.sendMessage(
+            Component.text()
+                .append(Component.text("Server Health Report\n", HEADER, TextDecoration.BOLD))
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Online Players: ", PRIMARY))
+                .append(Component.text(Bukkit.getOnlinePlayers().size() + "\n", INFORMATION))
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Total regions: ", PRIMARY))
+                .append(Component.text(regions.size() + "\n", INFORMATION))
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Utilisation: ", PRIMARY))
+                .append(Component.text(ONE_DECIMAL_PLACES.get().format(totalUtil * 100.0), CommandUtil.getUtilisationColourRegion(totalUtil / (double)maxThreadCount)))
+                .append(Component.text("% / ", PRIMARY))
+                .append(Component.text(ONE_DECIMAL_PLACES.get().format(maxThreadCount * 100.0), INFORMATION))
+                .append(Component.text("%\n", PRIMARY))
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Lowest Region TPS: ", PRIMARY))
+                .append(Component.text(TWO_DECIMAL_PLACES.get().format(minTps) + "\n", CommandUtil.getColourForTPS(minTps)))
+
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Median Region TPS: ", PRIMARY))
+                .append(Component.text(TWO_DECIMAL_PLACES.get().format(medianTps) + "\n", CommandUtil.getColourForTPS(medianTps)))
+
+                .append(Component.text(" - ", LIST, TextDecoration.BOLD))
+                .append(Component.text("Highest Region TPS: ", PRIMARY))
+                .append(Component.text(TWO_DECIMAL_PLACES.get().format(maxTps) + "\n", CommandUtil.getColourForTPS(maxTps)))
+
+                .append(Component.text("Highest ", HEADER, TextDecoration.BOLD))
+                .append(Component.text(Integer.toString(lowestRegionsCount), INFORMATION, TextDecoration.BOLD))
+                .append(Component.text(" utilisation regions\n", HEADER, TextDecoration.BOLD))
+
+                .append(lowestRegionsBuilder.build())
+                .build()
+        );
+
+        return true;
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String commandLabel, final String[] args) {
+        final String type;
+        if (args.length < 1) {
+            type = "server";
+        } else {
+            type = args[0];
+        }
+
+        switch (type.toLowerCase(Locale.ROOT)) {
+            case "server": {
+                return executeServer(sender, commandLabel, args);
+            }
+            case "region": {
+                if (!(sender instanceof Entity)) {
+                    sender.sendMessage(Component.text("Cannot see current region information as console", NamedTextColor.RED));
+                    return true;
+                }
+                return executeRegion(sender, commandLabel, args);
+            }
+            default: {
+                sender.sendMessage(Component.text("Type '" + args[0] + "' must be one of: [server, region]", NamedTextColor.RED));
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public List<String> tabComplete(final CommandSender sender, final String alias, final String[] args) throws IllegalArgumentException {
+        if (args.length == 0) {
+            if (sender instanceof Entity) {
+                return CommandUtil.getSortedList(Arrays.asList("server", "region"));
+            } else {
+                return CommandUtil.getSortedList(Arrays.asList("server"));
+            }
+        } else if (args.length == 1) {
+            if (sender instanceof Entity) {
+                return CommandUtil.getSortedList(Arrays.asList("server", "region"), args[0]);
+            } else {
+                return CommandUtil.getSortedList(Arrays.asList("server"), args[0]);
+            }
+        }
+        return new ArrayList<>();
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/commands/CommandUtil.java b/io/papermc/paper/threadedregions/commands/CommandUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..7939cb85e13c00740adb2614d6a1733b8ac6c29d
--- /dev/null
+++ b/io/papermc/paper/threadedregions/commands/CommandUtil.java
@@ -0,0 +1,121 @@
+package io.papermc.paper.threadedregions.commands;
+
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.util.HSVLike;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Function;
+
+public final class CommandUtil {
+
+    public static List<String> getSortedList(final Iterable<String> iterable) {
+        final List<String> ret = new ArrayList<>();
+        for (final String val : iterable) {
+            ret.add(val);
+        }
+
+        ret.sort(String.CASE_INSENSITIVE_ORDER);
+
+        return ret;
+    }
+
+    public static List<String> getSortedList(final Iterable<String> iterable, final String prefix) {
+        final List<String> ret = new ArrayList<>();
+        for (final String val : iterable) {
+            if (val.regionMatches(0, prefix, 0, prefix.length())) {
+                ret.add(val);
+            }
+        }
+
+        ret.sort(String.CASE_INSENSITIVE_ORDER);
+
+        return ret;
+    }
+
+    public static <T> List<String> getSortedList(final Iterable<T> iterable, final Function<T, String> transform) {
+        final List<String> ret = new ArrayList<>();
+        for (final T val : iterable) {
+            final String transformed = transform.apply(val);
+            if (transformed != null) {
+                ret.add(transformed);
+            }
+        }
+
+        ret.sort(String.CASE_INSENSITIVE_ORDER);
+
+        return ret;
+    }
+
+    public static <T> List<String> getSortedList(final Iterable<T> iterable, final Function<T, String> transform, final String prefix) {
+        final List<String> ret = new ArrayList<>();
+        for (final T val : iterable) {
+            final String string = transform.apply(val);
+            if (string != null && string.regionMatches(0, prefix, 0, prefix.length())) {
+                ret.add(string);
+            }
+        }
+
+        ret.sort(String.CASE_INSENSITIVE_ORDER);
+
+        return ret;
+    }
+
+    public static TextColor getColourForTPS(final double tps) {
+        final double difference = Math.min(Math.abs(20.0 - tps), 20.0);
+        final double coordinate;
+        if (difference <= 2.0) {
+            // >= 18 tps
+            coordinate = 70.0 + ((140.0 - 70.0)/(0.0 - 2.0)) * (difference - 2.0);
+        } else if (difference <= 5.0) {
+            // >= 15 tps
+            coordinate = 30.0 + ((70.0 - 30.0)/(2.0 - 5.0)) * (difference - 5.0);
+        } else if (difference <= 10.0) {
+            // >= 10 tps
+            coordinate = 10.0 + ((30.0 - 10.0)/(5.0 - 10.0)) * (difference - 10.0);
+        } else {
+            // >= 0.0 tps
+            coordinate = 0.0 + ((10.0 - 0.0)/(10.0 - 20.0)) * (difference - 20.0);
+        }
+
+        return TextColor.color(HSVLike.hsvLike((float)(coordinate / 360.0), 85.0f / 100.0f, 80.0f / 100.0f));
+    }
+
+    public static TextColor getColourForMSPT(final double mspt) {
+        final double clamped = Math.min(Math.abs(mspt), 50.0);
+        final double coordinate;
+        if (clamped <= 15.0) {
+            coordinate = 130.0 + ((140.0 - 130.0)/(0.0 - 15.0)) * (clamped - 15.0);
+        } else if (clamped <= 25.0) {
+            coordinate = 90.0 + ((130.0 - 90.0)/(15.0 - 25.0)) * (clamped - 25.0);
+        } else if (clamped <= 35.0) {
+            coordinate = 30.0 + ((90.0 - 30.0)/(25.0 - 35.0)) * (clamped - 35.0);
+        } else if (clamped <= 40.0) {
+            coordinate = 15.0 + ((30.0 - 15.0)/(35.0 - 40.0)) * (clamped - 40.0);
+        } else {
+            coordinate = 0.0 + ((15.0 - 0.0)/(40.0 - 50.0)) * (clamped - 50.0);
+        }
+
+        return TextColor.color(HSVLike.hsvLike((float)(coordinate / 360.0), 85.0f / 100.0f, 80.0f / 100.0f));
+    }
+
+    public static TextColor getUtilisationColourRegion(final double util) {
+        // TODO anything better?
+        // assume 20TPS
+        return getColourForMSPT(util * 50.0);
+    }
+
+    public static ServerPlayer getPlayer(final String name) {
+        for (final ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            if (player.getGameProfile().name().equalsIgnoreCase(name)) {
+                return player;
+            }
+        }
+
+        return null;
+    }
+
+    private CommandUtil() {}
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java b/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..84fa22ac06f1c2533874e1677f4bbd899288c4d6
--- /dev/null
+++ b/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
@@ -0,0 +1,427 @@
+package io.papermc.paper.threadedregions.scheduler;
+
+import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
+import io.papermc.paper.threadedregions.RegionizedData;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.plugin.IllegalPluginAccessException;
+import org.bukkit.plugin.Plugin;
+import java.lang.invoke.VarHandle;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+
+public final class FoliaRegionScheduler implements RegionScheduler {
+
+    private static Runnable wrap(final Plugin plugin, final World world, final int chunkX, final int chunkZ, final Runnable run) {
+        return () -> {
+            try {
+                run.run();
+            } catch (final Throwable throwable) {
+                plugin.getLogger().log(Level.WARNING, "Location task for " + plugin.getDescription().getFullName()
+                    + " in world " + world + " at " + chunkX + ", " + chunkZ + " generated an exception", throwable);
+            }
+        };
+    }
+
+    private static final RegionizedData<Scheduler> SCHEDULER_DATA = new RegionizedData<>(null, Scheduler::new, Scheduler.REGIONISER_CALLBACK);
+
+    private static void scheduleInternalOnRegion(final LocationScheduledTask task, final long delay) {
+        SCHEDULER_DATA.get().queueTask(task, delay);
+    }
+
+    private static void scheduleInternalOffRegion(final LocationScheduledTask task, final long delay) {
+        final World world = task.world;
+        if (world == null) {
+            // cancelled
+            return;
+        }
+
+        RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+            ((CraftWorld) world).getHandle(), task.chunkX, task.chunkZ, () -> {
+                scheduleInternalOnRegion(task, delay);
+            }
+        );
+    }
+
+    @Override
+    public void execute(final Plugin plugin, final World world, final int chunkX, final int chunkZ, final Runnable run) {
+        Objects.requireNonNull(plugin, "Plugin may not be null");
+        Objects.requireNonNull(world, "World may not be null");
+        Objects.requireNonNull(run, "Runnable may not be null");
+
+        RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+            ((CraftWorld) world).getHandle(), chunkX, chunkZ, wrap(plugin, world, chunkX, chunkZ, run)
+        );
+    }
+
+    @Override
+    public ScheduledTask run(final Plugin plugin, final World world, final int chunkX, final int chunkZ, final Consumer<ScheduledTask> task) {
+        return this.runDelayed(plugin, world, chunkX, chunkZ, task, 1);
+    }
+
+    @Override
+    public ScheduledTask runDelayed(final Plugin plugin, final World world, final int chunkX, final int chunkZ,
+                                    final Consumer<ScheduledTask> task, final long delayTicks) {
+        Objects.requireNonNull(plugin, "Plugin may not be null");
+        Objects.requireNonNull(world, "World may not be null");
+        org.apache.commons.lang3.Validate.notNull(task, "Task may not be null");
+        if (delayTicks <= 0) {
+            throw new IllegalArgumentException("Delay ticks may not be <= 0");
+        }
+
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register task while disabled");
+        }
+
+        final LocationScheduledTask ret = new LocationScheduledTask(plugin, world, chunkX, chunkZ, -1, task);
+
+        if (Bukkit.isOwnedByCurrentRegion(world, chunkX, chunkZ)) {
+            scheduleInternalOnRegion(ret, delayTicks);
+        } else {
+            scheduleInternalOffRegion(ret, delayTicks);
+        }
+
+        if (!plugin.isEnabled()) {
+            // handle race condition where plugin is disabled asynchronously
+            ret.cancel();
+        }
+
+        return ret;
+    }
+
+    @Override
+    public ScheduledTask runAtFixedRate(final Plugin plugin, final World world, final int chunkX, final int chunkZ,
+                                        final Consumer<ScheduledTask> task, final long initialDelayTicks, final long periodTicks) {
+        Objects.requireNonNull(plugin, "Plugin may not be null");
+        Objects.requireNonNull(world, "World may not be null");
+        Objects.requireNonNull(task, "Task may not be null");
+        if (initialDelayTicks <= 0) {
+            throw new IllegalArgumentException("Initial delay ticks may not be <= 0");
+        }
+        if (periodTicks <= 0) {
+            throw new IllegalArgumentException("Period ticks may not be <= 0");
+        }
+
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register task while disabled");
+        }
+
+        final LocationScheduledTask ret = new LocationScheduledTask(plugin, world, chunkX, chunkZ, periodTicks, task);
+
+        if (Bukkit.isOwnedByCurrentRegion(world, chunkX, chunkZ)) {
+            scheduleInternalOnRegion(ret, initialDelayTicks);
+        } else {
+            scheduleInternalOffRegion(ret, initialDelayTicks);
+        }
+
+        if (!plugin.isEnabled()) {
+            // handle race condition where plugin is disabled asynchronously
+            ret.cancel();
+        }
+
+        return ret;
+    }
+
+    public void tick() {
+        SCHEDULER_DATA.get().tick();
+    }
+
+    private static final class Scheduler {
+
+        private Scheduler(final TickRegions.TickRegionData regionData) {}
+
+        private static final RegionizedData.RegioniserCallback<Scheduler> REGIONISER_CALLBACK = new RegionizedData.RegioniserCallback<>() {
+            @Override
+            public void merge(final Scheduler from, final Scheduler into, final long fromTickOffset) {
+                for (final Iterator<Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>>> sectionIterator = from.tasksByDeadlineBySection.long2ObjectEntrySet().fastIterator();
+                     sectionIterator.hasNext();) {
+                    final Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>> entry = sectionIterator.next();
+                    final long sectionKey = entry.getLongKey();
+                    final Long2ObjectOpenHashMap<List<LocationScheduledTask>> section = entry.getValue();
+
+                    final Long2ObjectOpenHashMap<List<LocationScheduledTask>> sectionAdjusted = new Long2ObjectOpenHashMap<>(section.size());
+
+                    for (final Iterator<Long2ObjectMap.Entry<List<LocationScheduledTask>>> iterator = section.long2ObjectEntrySet().fastIterator();
+                         iterator.hasNext();) {
+                        final Long2ObjectMap.Entry<List<LocationScheduledTask>> e = iterator.next();
+                        final long newTick = e.getLongKey() + fromTickOffset;
+                        final List<LocationScheduledTask> tasks = e.getValue();
+
+                        sectionAdjusted.put(newTick, tasks);
+                    }
+
+                    into.tasksByDeadlineBySection.put(sectionKey, sectionAdjusted);
+                }
+            }
+
+            @Override
+            public void split(final Scheduler from, final int chunkToRegionShift, final Long2ReferenceOpenHashMap<Scheduler> regionToData,
+                              final ReferenceOpenHashSet<Scheduler> dataSet) {
+                for (final Scheduler into : dataSet) {
+                    into.tickCount = from.tickCount;
+                }
+
+                for (final Iterator<Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>>> sectionIterator = from.tasksByDeadlineBySection.long2ObjectEntrySet().fastIterator();
+                     sectionIterator.hasNext();) {
+                    final Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>> entry = sectionIterator.next();
+                    final long sectionKey = entry.getLongKey();
+                    final Long2ObjectOpenHashMap<List<LocationScheduledTask>> section = entry.getValue();
+
+                    final Scheduler into = regionToData.get(sectionKey);
+
+                    into.tasksByDeadlineBySection.put(sectionKey, section);
+                }
+            }
+        };
+
+        private long tickCount = 0L;
+        // map of region section -> map of deadline -> list of tasks
+        private final Long2ObjectOpenHashMap<Long2ObjectOpenHashMap<List<LocationScheduledTask>>> tasksByDeadlineBySection = new Long2ObjectOpenHashMap<>();
+
+        private void addTicket(final int sectionX, final int sectionZ) {
+            final ServerLevel world = TickRegionScheduler.getCurrentRegionizedWorldData().world;
+            final int shift = world.moonrise$getRegionChunkShift();
+            final int chunkX = sectionX << shift;
+            final int chunkZ = sectionZ << shift;
+
+            world.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                TicketType.REGION_SCHEDULER_API_HOLD, chunkX, chunkZ, ChunkHolderManager.MAX_TICKET_LEVEL, null
+            );
+        }
+
+        private void removeTicket(final long sectionKey) {
+            final ServerLevel world = TickRegionScheduler.getCurrentRegionizedWorldData().world;
+            final int shift = world.moonrise$getRegionChunkShift();
+            final int chunkX = CoordinateUtils.getChunkX(sectionKey) << shift;
+            final int chunkZ = CoordinateUtils.getChunkZ(sectionKey) << shift;
+
+            world.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                TicketType.REGION_SCHEDULER_API_HOLD, chunkX, chunkZ, ChunkHolderManager.MAX_TICKET_LEVEL, null
+            );
+        }
+
+        private void queueTask(final LocationScheduledTask task, final long delay) {
+            // note: must be on the thread that owns this scheduler
+            // note: delay > 0
+
+            final World world = task.world;
+            if (world == null) {
+                // cancelled
+                return;
+            }
+
+            final int shift = ((CraftWorld)world).getHandle().moonrise$getRegionChunkShift();
+            final int sectionX = task.chunkX >> shift;
+            final int sectionZ = task.chunkZ >> shift;
+
+            final Long2ObjectOpenHashMap<List<LocationScheduledTask>> section =
+                this.tasksByDeadlineBySection.computeIfAbsent(CoordinateUtils.getChunkKey(sectionX, sectionZ), (final long keyInMap) -> {
+                    return new Long2ObjectOpenHashMap<>();
+                }
+            );
+
+            if (section.isEmpty()) {
+                // need to keep the scheduler loaded for this location in order for tick() to be called...
+                this.addTicket(sectionX, sectionZ);
+            }
+
+            section.computeIfAbsent(this.tickCount + delay, (final long keyInMap) -> {
+                return new ArrayList<>();
+            }).add(task);
+        }
+
+        public void tick() {
+            ++this.tickCount;
+
+            final List<LocationScheduledTask> run = new ArrayList<>();
+
+            for (final Iterator<Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>>> sectionIterator = this.tasksByDeadlineBySection.long2ObjectEntrySet().fastIterator();
+                 sectionIterator.hasNext();) {
+                final Long2ObjectMap.Entry<Long2ObjectOpenHashMap<List<LocationScheduledTask>>> entry = sectionIterator.next();
+                final long sectionKey = entry.getLongKey();
+                final Long2ObjectOpenHashMap<List<LocationScheduledTask>> section = entry.getValue();
+
+                final List<LocationScheduledTask> tasks = section.remove(this.tickCount);
+
+                if (tasks == null) {
+                    continue;
+                }
+
+                run.addAll(tasks);
+
+                if (section.isEmpty()) {
+                    this.removeTicket(sectionKey);
+                    sectionIterator.remove();
+                }
+            }
+
+            for (int i = 0, len = run.size(); i < len; ++i) {
+                run.get(i).run();
+            }
+        }
+    }
+
+    private static final class LocationScheduledTask implements ScheduledTask, Runnable {
+
+        private static final int STATE_IDLE                = 0;
+        private static final int STATE_EXECUTING           = 1;
+        private static final int STATE_EXECUTING_CANCELLED = 2;
+        private static final int STATE_FINISHED            = 3;
+        private static final int STATE_CANCELLED           = 4;
+
+        private final Plugin plugin;
+        private final int chunkX;
+        private final int chunkZ;
+        private final long repeatDelay; // in ticks
+        private World world;
+        private Consumer<ScheduledTask> run;
+
+        private volatile int state;
+        private static final VarHandle STATE_HANDLE = ConcurrentUtil.getVarHandle(LocationScheduledTask.class, "state", int.class);
+
+        private LocationScheduledTask(final Plugin plugin, final World world, final int chunkX, final int chunkZ,
+                                      final long repeatDelay, final Consumer<ScheduledTask> run) {
+            this.plugin = plugin;
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.repeatDelay = repeatDelay;
+            this.run = run;
+        }
+
+        private final int getStateVolatile() {
+            return (int)STATE_HANDLE.get(this);
+        }
+
+        private final int compareAndExchangeStateVolatile(final int expect, final int update) {
+            return (int)STATE_HANDLE.compareAndExchange(this, expect, update);
+        }
+
+        private final void setStateVolatile(final int value) {
+            STATE_HANDLE.setVolatile(this, value);
+        }
+
+        @Override
+        public void run() {
+            if (!this.plugin.isEnabled()) {
+                // don't execute if the plugin is disabled
+                return;
+            }
+
+            final boolean repeating = this.isRepeatingTask();
+            if (STATE_IDLE != this.compareAndExchangeStateVolatile(STATE_IDLE, STATE_EXECUTING)) {
+                // cancelled
+                return;
+            }
+
+            try {
+                this.run.accept(this);
+            } catch (final Throwable throwable) {
+                this.plugin.getLogger().log(Level.WARNING, "Location task for " + this.plugin.getDescription().getFullName()
+                    + " in world " + world + " at " + chunkX + ", " + chunkZ + " generated an exception", throwable);
+            } finally {
+                boolean reschedule = false;
+                 if (!repeating) {
+                    this.setStateVolatile(STATE_FINISHED);
+                } else if (!this.plugin.isEnabled()) {
+                     this.setStateVolatile(STATE_CANCELLED);
+                } else if (STATE_EXECUTING == this.compareAndExchangeStateVolatile(STATE_EXECUTING, STATE_IDLE)) {
+                    reschedule = true;
+                } // else: cancelled repeating task
+
+                if (!reschedule) {
+                    this.run = null;
+                    this.world = null;
+                } else {
+                    FoliaRegionScheduler.scheduleInternalOnRegion(this, this.repeatDelay);
+                }
+            }
+        }
+
+        @Override
+        public Plugin getOwningPlugin() {
+            return this.plugin;
+        }
+
+        @Override
+        public boolean isRepeatingTask() {
+            return this.repeatDelay > 0;
+        }
+
+        @Override
+        public CancelledState cancel() {
+            for (int curr = this.getStateVolatile();;) {
+                switch (curr) {
+                    case STATE_IDLE: {
+                        if (STATE_IDLE == (curr = this.compareAndExchangeStateVolatile(STATE_IDLE, STATE_CANCELLED))) {
+                            this.state = STATE_CANCELLED;
+                            this.run = null;
+                            this.world = null;
+                            return CancelledState.CANCELLED_BY_CALLER;
+                        }
+                        // try again
+                        continue;
+                    }
+                    case STATE_EXECUTING: {
+                        if (!this.isRepeatingTask()) {
+                            return CancelledState.RUNNING;
+                        }
+                        if (STATE_EXECUTING == (curr = this.compareAndExchangeStateVolatile(STATE_EXECUTING, STATE_EXECUTING_CANCELLED))) {
+                            return CancelledState.NEXT_RUNS_CANCELLED;
+                        }
+                        // try again
+                        continue;
+                    }
+                    case STATE_EXECUTING_CANCELLED: {
+                        return CancelledState.NEXT_RUNS_CANCELLED_ALREADY;
+                    }
+                    case STATE_FINISHED: {
+                        return CancelledState.ALREADY_EXECUTED;
+                    }
+                    case STATE_CANCELLED: {
+                        return CancelledState.CANCELLED_ALREADY;
+                    }
+                    default: {
+                        throw new IllegalStateException("Unknown state: " + curr);
+                    }
+                }
+            }
+        }
+
+        @Override
+        public ExecutionState getExecutionState() {
+            final int state = this.getStateVolatile();
+            switch (state) {
+                case STATE_IDLE:
+                    return ExecutionState.IDLE;
+                case STATE_EXECUTING:
+                    return ExecutionState.RUNNING;
+                case STATE_EXECUTING_CANCELLED:
+                    return ExecutionState.CANCELLED_RUNNING;
+                case STATE_FINISHED:
+                    return ExecutionState.FINISHED;
+                case STATE_CANCELLED:
+                    return ExecutionState.CANCELLED;
+                default: {
+                    throw new IllegalStateException("Unknown state: " + state);
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/util/SimpleThreadLocalRandomSource.java b/io/papermc/paper/threadedregions/util/SimpleThreadLocalRandomSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..14d20c996e9b25077f7e51c5d7d432c4a2b01671
--- /dev/null
+++ b/io/papermc/paper/threadedregions/util/SimpleThreadLocalRandomSource.java
@@ -0,0 +1,79 @@
+package io.papermc.paper.threadedregions.util;
+
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.levelgen.BitRandomSource;
+import net.minecraft.world.level.levelgen.PositionalRandomFactory;
+import java.util.concurrent.ThreadLocalRandom;
+
+public final class SimpleThreadLocalRandomSource implements BitRandomSource {
+
+    public static final SimpleThreadLocalRandomSource INSTANCE = new SimpleThreadLocalRandomSource();
+
+    private final PositionalRandomFactory positionalRandomFactory = new SimpleThreadLocalRandomSource.SimpleThreadLocalRandomPositionalRandomFactory();
+
+    private SimpleThreadLocalRandomSource() {}
+
+    @Override
+    public int next(final int bits) {
+        return ThreadLocalRandom.current().nextInt() >>> (Integer.SIZE - bits);
+    }
+
+    @Override
+    public int nextInt() {
+        return ThreadLocalRandom.current().nextInt();
+    }
+
+    @Override
+    public int nextInt(final int bound) {
+        if (bound <= 0) {
+            throw new IllegalArgumentException();
+        }
+
+        // https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/
+        final long value = (long)this.nextInt() & 0xFFFFFFFFL;
+        return (int)((value * (long)bound) >>> Integer.SIZE);
+    }
+
+    @Override
+    public void setSeed(final long seed) {
+        // no-op
+    }
+
+    @Override
+    public double nextGaussian() {
+        return ThreadLocalRandom.current().nextGaussian();
+    }
+
+    @Override
+    public RandomSource fork() {
+        return this;
+    }
+
+    @Override
+    public PositionalRandomFactory forkPositional() {
+        return this.positionalRandomFactory;
+    }
+
+    private static final class SimpleThreadLocalRandomPositionalRandomFactory implements PositionalRandomFactory {
+
+        @Override
+        public RandomSource fromHashOf(final String seed) {
+            return SimpleThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public RandomSource fromSeed(final long seed) {
+            return SimpleThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public RandomSource at(final int x, final int y, final int z) {
+            return SimpleThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public void parityConfigString(final StringBuilder info) {
+            info.append("SimpleThreadLocalRandomPositionalRandomFactory{}");
+        }
+    }
+}
\ No newline at end of file
diff --git a/io/papermc/paper/threadedregions/util/ThreadLocalRandomSource.java b/io/papermc/paper/threadedregions/util/ThreadLocalRandomSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..c167179775ec09877808d91eb04b3cdb688c00a4
--- /dev/null
+++ b/io/papermc/paper/threadedregions/util/ThreadLocalRandomSource.java
@@ -0,0 +1,73 @@
+package io.papermc.paper.threadedregions.util;
+
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.levelgen.BitRandomSource;
+import net.minecraft.world.level.levelgen.PositionalRandomFactory;
+import java.util.concurrent.ThreadLocalRandom;
+
+public final class ThreadLocalRandomSource implements BitRandomSource {
+
+    public static final ThreadLocalRandomSource INSTANCE = new ThreadLocalRandomSource();
+
+    private final PositionalRandomFactory positionalRandomFactory = new ThreadLocalRandomPositionalRandomFactory();
+
+    private ThreadLocalRandomSource() {}
+
+    @Override
+    public int next(final int bits) {
+        return ThreadLocalRandom.current().nextInt() >>> (Integer.SIZE - bits);
+    }
+
+    @Override
+    public int nextInt() {
+        return ThreadLocalRandom.current().nextInt();
+    }
+
+    @Override
+    public int nextInt(final int bound) {
+        return ThreadLocalRandom.current().nextInt(bound);
+    }
+
+    @Override
+    public void setSeed(final long seed) {
+        // no-op
+    }
+
+    @Override
+    public double nextGaussian() {
+        return ThreadLocalRandom.current().nextGaussian();
+    }
+
+    @Override
+    public RandomSource fork() {
+        return this;
+    }
+
+    @Override
+    public PositionalRandomFactory forkPositional() {
+        return this.positionalRandomFactory;
+    }
+
+    private static final class ThreadLocalRandomPositionalRandomFactory implements PositionalRandomFactory {
+
+        @Override
+        public RandomSource fromHashOf(final String seed) {
+            return ThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public RandomSource fromSeed(final long seed) {
+            return ThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public RandomSource at(final int x, final int y, final int z) {
+            return ThreadLocalRandomSource.INSTANCE;
+        }
+
+        @Override
+        public void parityConfigString(final StringBuilder info) {
+            info.append("ThreadLocalRandomPositionalRandomFactory{}");
+        }
+    }
+}
\ No newline at end of file
diff --git a/net/minecraft/commands/CommandSourceStack.java b/net/minecraft/commands/CommandSourceStack.java
index 566304106fd4f1c677a56e7c66282d1570e7b974..f046aca874eb3376696baaad3719a6987afbfe22 100644
--- a/net/minecraft/commands/CommandSourceStack.java
+++ b/net/minecraft/commands/CommandSourceStack.java
@@ -92,7 +92,7 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
             CommandResultCallback.EMPTY,
             EntityAnchorArgument.Anchor.FEET,
             CommandSigningContext.ANONYMOUS,
-            TaskChainer.immediate(server)
+            TaskChainer.immediate((Runnable run) -> { io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(run);}) // Folia - region threading
         );
     }
 
diff --git a/net/minecraft/commands/Commands.java b/net/minecraft/commands/Commands.java
index 668eb52d71d77f75c24d4840be9a6c49d96dfc34..d4a5ba350f3cf0d6cd2aab786e1ef8dbb616ee2b 100644
--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -196,15 +196,15 @@ public class Commands {
         AdvancementCommands.register(this.dispatcher);
         AttributeCommand.register(this.dispatcher, context);
         ExecuteCommand.register(this.dispatcher, context);
-        BossBarCommands.register(this.dispatcher, context);
+        //BossBarCommands.register(this.dispatcher, context); // Folia - region threading - TODO
         ClearInventoryCommands.register(this.dispatcher, context);
-        CloneCommands.register(this.dispatcher, context);
+        //CloneCommands.register(this.dispatcher, context); // Folia - region threading - TODO
         DamageCommand.register(this.dispatcher, context);
-        DataCommands.register(this.dispatcher);
-        DataPackCommand.register(this.dispatcher, context);
-        DebugCommand.register(this.dispatcher);
+        //DataCommands.register(this.dispatcher); // Folia - region threading - TODO
+        //DataPackCommand.register(this.dispatcher, context); // Folia - region threading - TODO
+        //DebugCommand.register(this.dispatcher); // Folia - region threading - TODO
         DefaultGameModeCommands.register(this.dispatcher);
-        DialogCommand.register(this.dispatcher, context);
+        //DialogCommand.register(this.dispatcher, context); // Folia - region threading - TODO
         DifficultyCommand.register(this.dispatcher);
         EffectCommands.register(this.dispatcher, context);
         EmoteCommands.register(this.dispatcher);
@@ -213,52 +213,52 @@ public class Commands {
         FillCommand.register(this.dispatcher, context);
         FillBiomeCommand.register(this.dispatcher, context);
         ForceLoadCommand.register(this.dispatcher);
-        FunctionCommand.register(this.dispatcher);
+        //FunctionCommand.register(this.dispatcher); // Folia - region threading - TODO
         GameModeCommand.register(this.dispatcher);
         GameRuleCommand.register(this.dispatcher, context);
         GiveCommand.register(this.dispatcher, context);
         HelpCommand.register(this.dispatcher);
-        ItemCommands.register(this.dispatcher, context);
+        //ItemCommands.register(this.dispatcher, context); // Folia - region threading - TODO later
         KickCommand.register(this.dispatcher);
         KillCommand.register(this.dispatcher);
         ListPlayersCommand.register(this.dispatcher);
         LocateCommand.register(this.dispatcher, context);
-        LootCommand.register(this.dispatcher, context);
+        //LootCommand.register(this.dispatcher, context); // Folia - region threading - TODO later
         MsgCommand.register(this.dispatcher);
         ParticleCommand.register(this.dispatcher, context);
         PlaceCommand.register(this.dispatcher);
         PlaySoundCommand.register(this.dispatcher);
         RandomCommand.register(this.dispatcher);
-        ReloadCommand.register(this.dispatcher);
+        //ReloadCommand.register(this.dispatcher); // Folia - region threading
         RecipeCommand.register(this.dispatcher);
         FetchProfileCommand.register(this.dispatcher);
-        ReturnCommand.register(this.dispatcher);
+        ReturnCommand.register(this.dispatcher); // Folia - region threading - TODO later
         RideCommand.register(this.dispatcher);
         RotateCommand.register(this.dispatcher);
         SayCommand.register(this.dispatcher);
-        ScheduleCommand.register(this.dispatcher);
-        ScoreboardCommand.register(this.dispatcher, context);
+        //ScheduleCommand.register(this.dispatcher); // Folia - region threading
+        //ScoreboardCommand.register(this.dispatcher, context); // Folia - region threading
         SeedCommand.register(this.dispatcher, selection != Commands.CommandSelection.INTEGRATED);
         VersionCommand.register(this.dispatcher, selection != Commands.CommandSelection.INTEGRATED);
         SetBlockCommand.register(this.dispatcher, context);
         SetSpawnCommand.register(this.dispatcher);
         SetWorldSpawnCommand.register(this.dispatcher);
-        SpectateCommand.register(this.dispatcher);
-        SpreadPlayersCommand.register(this.dispatcher);
+        //SpectateCommand.register(this.dispatcher); // Folia - region threading - TODO later
+        //SpreadPlayersCommand.register(this.dispatcher); // Folia - region threading - TODO later
         StopSoundCommand.register(this.dispatcher);
         StopwatchCommand.register(this.dispatcher);
         SummonCommand.register(this.dispatcher, context);
-        TagCommand.register(this.dispatcher);
-        TeamCommand.register(this.dispatcher, context);
-        TeamMsgCommand.register(this.dispatcher);
+        //TagCommand.register(this.dispatcher); // Folia - region threading - TODO later
+        //TeamCommand.register(this.dispatcher, context); // Folia - region threading - TODO later
+        //TeamMsgCommand.register(this.dispatcher); // Folia - region threading - TODO later
         TeleportCommand.register(this.dispatcher);
         TellRawCommand.register(this.dispatcher, context);
-        TestCommand.register(this.dispatcher, context);
-        TickCommand.register(this.dispatcher);
+        //TestCommand.register(this.dispatcher, context); // Folia - region threading
+        //TickCommand.register(this.dispatcher); // Folia - region threading - TODO later
         TimeCommand.register(this.dispatcher);
         TitleCommand.register(this.dispatcher, context);
-        TriggerCommand.register(this.dispatcher);
-        WaypointCommand.register(this.dispatcher, context);
+        //TriggerCommand.register(this.dispatcher); // Folia - region threading - TODO later
+        //WaypointCommand.register(this.dispatcher, context); // Folia - region threading - TODO later
         WeatherCommand.register(this.dispatcher);
         WorldBorderCommand.register(this.dispatcher);
         if (JvmProfiler.INSTANCE.isAvailable()) {
@@ -289,8 +289,8 @@ public class Commands {
             OpCommand.register(this.dispatcher);
             PardonCommand.register(this.dispatcher);
             PardonIpCommand.register(this.dispatcher);
-            PerfCommand.register(this.dispatcher);
-            SaveAllCommand.register(this.dispatcher);
+            //PerfCommand.register(this.dispatcher); // Folia - region threading - TODO later
+            //SaveAllCommand.register(this.dispatcher); // Folia - region threading - TODO later
             SaveOffCommand.register(this.dispatcher);
             SaveOnCommand.register(this.dispatcher);
             SetPlayerIdleTimeoutCommand.register(this.dispatcher);
@@ -514,9 +514,12 @@ public class Commands {
         }
         // Paper start - Perf: Async command map building
         new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootCommandNode, false).callEvent(); // Paper - Brigadier API
-        net.minecraft.server.MinecraftServer.getServer().execute(() -> {
-            runSync(player, bukkit, rootCommandNode);
-        });
+        // Folia start - region threading
+        // ignore if retired
+        player.getBukkitEntity().taskScheduler.schedule((ServerPlayer updatedPlayer) -> {
+            runSync((ServerPlayer)updatedPlayer, bukkit, rootCommandNode);
+        }, null, 1L);
+        // Folia end - region threading
     }
 
     private void runSync(ServerPlayer player, java.util.Collection<String> bukkit, RootCommandNode<CommandSourceStack> rootCommandNode) {
diff --git a/net/minecraft/core/dispenser/DispenseItemBehavior.java b/net/minecraft/core/dispenser/DispenseItemBehavior.java
index bfefb5031544caa59230f0073e8880c2b39ebf4d..f9a164ce49562d506ac240af12449b1cf90b8505 100644
--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -407,20 +407,21 @@ public interface DispenseItemBehavior {
                     return result;
                 }
                 // Paper end - Call BlockDispenseEvent
-                level.captureTreeGeneration = true; // CraftBukkit
+                io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+                worldData.captureTreeGeneration = true; // CraftBukkit // Folia - region threading
                 if (!BoneMealItem.growCrop(item, level, blockPos) && !BoneMealItem.growWaterPlant(item, level, blockPos, null)) {
                     this.setSuccess(false);
                 } else if (!level.isClientSide()) {
                     level.levelEvent(LevelEvent.PARTICLES_AND_SOUND_PLANT_GROWTH, blockPos, 15);
                 }
                 // CraftBukkit start
-                level.captureTreeGeneration = false;
-                if (!level.capturedBlockStates.isEmpty()) {
-                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                    net.minecraft.world.level.block.SaplingBlock.treeType = null;
+                worldData.captureTreeGeneration = false; // Folia - region threading
+                if (!worldData.capturedBlockStates.isEmpty()) { // Folia - region threading
+                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeTypeRT.get(); // Folia - region threading
+                    net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(null); // Folia - region threading
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(blockPos, level);
-                    List<org.bukkit.block.BlockState> states = new java.util.ArrayList<>(level.capturedBlockStates.values());
-                    level.capturedBlockStates.clear();
+                    List<org.bukkit.block.BlockState> states = new java.util.ArrayList<>(worldData.capturedBlockStates.values()); // Folia - region threading
+                    worldData.capturedBlockStates.clear(); // Folia - region threading
                     org.bukkit.event.world.StructureGrowEvent structureEvent = null;
                     if (treeType != null) {
                         structureEvent = new org.bukkit.event.world.StructureGrowEvent(location, treeType, false, null, states);
diff --git a/net/minecraft/gametest/framework/GameTestHelper.java b/net/minecraft/gametest/framework/GameTestHelper.java
index 2a1aef6bfa15882748b98b5257baaced107ba194..170d02d59c1aa58f24b5d5c456378f5ac2060411 100644
--- a/net/minecraft/gametest/framework/GameTestHelper.java
+++ b/net/minecraft/gametest/framework/GameTestHelper.java
@@ -342,7 +342,7 @@ public class GameTestHelper {
         };
         Connection connection = new Connection(PacketFlow.SERVERBOUND);
         new EmbeddedChannel(connection);
-        this.getLevel().getServer().getPlayerList().placeNewPlayer(connection, serverPlayer, commonListenerCookie);
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         return serverPlayer;
     }
 
diff --git a/net/minecraft/gametest/framework/GameTestServer.java b/net/minecraft/gametest/framework/GameTestServer.java
index 586ab84d95ac1b04a8b269ed63e6e4399fef64e2..11ac2304861892a92f2bf155e387e3d581ffe50f 100644
--- a/net/minecraft/gametest/framework/GameTestServer.java
+++ b/net/minecraft/gametest/framework/GameTestServer.java
@@ -218,8 +218,12 @@ public class GameTestServer extends MinecraftServer {
     }
 
     @Override
-    public void tickServer(BooleanSupplier hasTimeLeft) {
-        super.tickServer(hasTimeLeft);
+    // Folia start - region threading
+    public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
+                           io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
+        if (true) throw new UnsupportedOperationException();
+        super.tickServer(startTime, scheduledEnd, targetBuffer, region);
+        // Folia end - region threading
         ServerLevel serverLevel = this.overworld();
         if (!this.haveTestsStarted()) {
             this.startTests(serverLevel);
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 19ec939529eb638bdc4d7fd9260f161fae118314..c26e81b07f1ea6d0820147da35cc8555fd83f75c 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -65,7 +65,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static final ProtocolInfo<ServerHandshakePacketListener> INITIAL_PROTOCOL = HandshakeProtocols.SERVERBOUND;
     private final PacketFlow receiving;
     private volatile boolean sendLoginDisconnect = true;
-    private final Queue<WrappedConsumer> pendingActions = Queues.newConcurrentLinkedQueue(); // Paper - Optimize network
+    private final Queue<WrappedConsumer> pendingActions = new ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue<>(); // Paper - Optimize network // Folia - region threading - connection fixes
     public Channel channel;
     public SocketAddress address;
     // Spigot start
@@ -77,7 +77,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private volatile @Nullable PacketListener packetListener;
     private @Nullable DisconnectionDetails disconnectionDetails;
     private boolean encrypted;
-    private boolean disconnectionHandled;
+    private final java.util.concurrent.atomic.AtomicBoolean disconnectionHandled = new java.util.concurrent.atomic.AtomicBoolean(false); // Folia - region threading - may be called concurrently during configuration stage
     private int receivedPackets;
     private int sentPackets;
     private float averageReceivedPackets;
@@ -132,6 +132,41 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.receiving = receiving;
     }
 
+    // Folia start - region threading
+    private volatile boolean becomeActive;
+
+    public boolean becomeActive() {
+        return this.becomeActive;
+    }
+
+    private static record DisconnectReq(DisconnectionDetails details) {}
+
+    private final ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue<DisconnectReq> disconnectReqs =
+            new ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue<>();
+
+    /**
+     * Safely disconnects the connection while possibly on another thread. Note: This call will not block, even if on the
+     * same thread that could disconnect.
+     */
+    public final void disconnectSafely(DisconnectionDetails details) {
+        this.disconnectReqs.add(new DisconnectReq(details));
+        // We can't halt packet processing here because a plugin could cancel a kick request.
+    }
+
+    /**
+     * Safely disconnects the connection while possibly on another thread. Note: This call will not block, even if on the
+     * same thread that could disconnect.
+     */
+    public final void disconnectSafely(Component disconnectReason, io.papermc.paper.connection.DisconnectionReason cause) {
+        this.disconnectReqs.add(new DisconnectReq(new DisconnectionDetails(disconnectReason, java.util.Optional.empty(), java.util.Optional.empty(), java.util.Optional.empty(), java.util.Optional.ofNullable(cause))));
+        // We can't halt packet processing here because a plugin could cancel a kick request.
+    }
+
+    public final boolean isPlayerConnected() {
+        return this.packetListener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl;
+    }
+    // Folia end - region threading
+
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         super.channelActive(ctx);
@@ -141,6 +176,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         if (this.delayedDisconnect != null) {
             this.disconnect(this.delayedDisconnect);
         }
+        this.becomeActive = true; // Folia - region threading
     }
 
     @Override
@@ -406,7 +442,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
 
         packet.onPacketDispatch(this.getPlayer());
-        if (connected && (InnerUtil.canSendImmediate(this, packet)
+        if (false && connected && (InnerUtil.canSendImmediate(this, packet) // Folia - region threading - connection fixes
             || (io.papermc.paper.util.MCUtil.isMainThread() && packet.isReady() && this.pendingActions.isEmpty()
             && (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())))) {
             this.sendPacket(packet, sendListener, flush);
@@ -435,11 +471,12 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void runOnceConnected(Consumer<Connection> action) {
-        if (this.isConnected()) {
+        if (false && this.isConnected()) { // Folia - region threading - connection fixes
             this.flushQueue();
             action.accept(this);
         } else {
             this.pendingActions.add(new WrappedConsumer(action)); // Paper - Optimize network
+            this.flushQueue(); // Folia - region threading - connection fixes
         }
     }
 
@@ -484,10 +521,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void flushChannel() {
-        if (this.isConnected()) {
+        if (false && this.isConnected()) { // Folia - region threading - connection fixes
             this.flush();
         } else {
             this.pendingActions.add(new WrappedConsumer(Connection::flush)); // Paper - Optimize network
+            this.flushQueue(); // Folia - region threading - connection fixes
         }
     }
 
@@ -501,53 +539,61 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     // Paper start - Optimize network: Rewrite this to be safer if ran off main thread
     private boolean flushQueue() {
-        if (!this.isConnected()) {
-            return true;
-        }
-        if (io.papermc.paper.util.MCUtil.isMainThread()) {
-            return this.processQueue();
-        } else if (this.isPending) {
-            // Should only happen during login/status stages
-            synchronized (this.pendingActions) {
-                return this.processQueue();
-            }
-        }
-        return false;
+        return this.processQueue(); // Folia - region threading - connection fixes
+    }
+
+    // Folia start - region threading - connection fixes
+    // allow only one thread to be flushing the queue at once to ensure packets are written in the order they are sent
+    // into the queue
+    private final java.util.concurrent.atomic.AtomicBoolean flushingQueue = new java.util.concurrent.atomic.AtomicBoolean();
+
+    private static boolean canWrite(WrappedConsumer queued) {
+        return queued != null && (!(queued instanceof PacketSendAction packet) || packet.packet.isReady());
     }
 
+    private boolean canWritePackets() {
+        return canWrite(this.pendingActions.peek());
+    }
+    // Folia end - region threading - connection fixes
+
     private boolean processQueue() {
-        if (this.pendingActions.isEmpty()) {
+        // Folia start - region threading - connection fixes
+        if (!this.isConnected()) {
             return true;
         }
 
-        // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
-        // But if we are not on main due to login/status, the parent is synchronized on packetQueue
-        final java.util.Iterator<WrappedConsumer> iterator = this.pendingActions.iterator();
-        while (iterator.hasNext()) {
-            final WrappedConsumer queued = iterator.next(); // poll -> peek
-
-            // Fix NPE (Spigot bug caused by handleDisconnection())
-            if (queued == null) {
-                return true;
-            }
+        while (this.canWritePackets()) {
+            final boolean set = this.flushingQueue.getAndSet(true);
+            try {
+                if (set) {
+                    // we didn't acquire the lock, break
+                    return false;
+                }
 
-            if (queued.isConsumed()) {
-                continue;
-            }
+                ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue<WrappedConsumer> queue =
+                    (ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue<WrappedConsumer>)this.pendingActions;
+                WrappedConsumer holder;
+                for (;;) {
+                    // synchronise so that queue clears appear atomic
+                    synchronized (queue) {
+                        holder = queue.pollIf(Connection::canWrite);
+                    }
+                    if (holder == null) {
+                        break;
+                    }
 
-            if (queued instanceof PacketSendAction packetSendAction) {
-                final Packet<?> packet = packetSendAction.packet;
-                if (!packet.isReady()) {
-                    return false;
+                    holder.accept(this);
                 }
-            }
 
-            iterator.remove();
-            if (queued.tryMarkConsumed()) {
-                queued.accept(this);
+            } finally {
+                if (!set) {
+                    this.flushingQueue.set(false);
+                }
             }
         }
+
         return true;
+        // Folia end - region threading - connection fixes
     }
     // Paper end - Optimize network
 
@@ -556,17 +602,36 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int currTick; // Paper - Buffer joins to world
     public void tick() {
         this.flushQueue();
-        // Paper start - Buffer joins to world
-        if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
-            Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
-            Connection.joinAttemptsThisTick = 0;
+        // Folia - this is broken
+        // Folia start - region threading
+        // handle disconnect requests, but only after flushQueue()
+        DisconnectReq disconnectReq;
+        while ((disconnectReq = this.disconnectReqs.poll()) != null) {
+            PacketListener packetlistener = this.packetListener;
+
+            if (packetlistener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener) {
+                loginPacketListener.disconnect(disconnectReq.details.reason());
+                // this doesn't fail, so abort any further attempts
+                return;
+            } else if (packetlistener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl commonPacketListener) {
+                commonPacketListener.disconnect(disconnectReq.details);
+                // may be cancelled by a plugin, if not cancelled then any further calls do nothing
+                continue;
+            } else {
+                this.disconnect(disconnectReq.details);
+                this.setReadOnly();
+                return;
+            }
         }
-        // Paper end - Buffer joins to world
+        if (!this.isConnected()) {
+            // disconnected from above
+            this.handleDisconnection();
+            return;
+        }
+        // Folia end - region threading
         if (this.packetListener instanceof TickablePacketListener tickablePacketListener) {
             // Paper start - Buffer joins to world
-            if (!(this.packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener)
-                || loginPacketListener.state != net.minecraft.server.network.ServerLoginPacketListenerImpl.State.VERIFYING
-                || Connection.joinAttemptsThisTick++ < MAX_PER_TICK) {
+            if (true) { // Folia - region threading
             // Paper start - detailed watchdog information
             net.minecraft.network.PacketProcessor.packetProcessing.push(this.packetListener);
             try {
@@ -577,7 +642,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             } // Paper end - Buffer joins to world
         }
 
-        if (!this.isConnected() && !this.disconnectionHandled) {
+        if (!this.isConnected()) {// Folia - region threading - it's fine to call if it is already handled, as it no longer logs
             this.handleDisconnection();
         }
 
@@ -628,6 +693,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             this.channel.close(); // We can't wait as this may be called from an event loop.
             this.disconnectionDetails = disconnectionDetails;
         }
+        this.becomeActive = true; // Folia - region threading
     }
 
     public boolean isMemoryConnection() {
@@ -807,10 +873,10 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     public void handleDisconnection() {
         if (this.channel != null && !this.channel.isOpen()) {
-            if (this.disconnectionHandled) {
+            if (!this.disconnectionHandled.compareAndSet(false, true)) { // Folia - region threading - may be called concurrently during configuration stage
                 // LOGGER.warn("handleDisconnection() called twice"); // Paper - Don't log useless message
             } else {
-                this.disconnectionHandled = true;
+                //this.disconnectionHandled = true; // Folia - region threading - may be called concurrently during configuration stage - set above
                 PacketListener packetListener = this.getPacketListener();
                 PacketListener packetListener1 = packetListener != null ? packetListener : this.disconnectListener;
                 if (packetListener1 != null) {
@@ -839,6 +905,21 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
                     }
                 }
                 // Paper end - Add PlayerConnectionCloseEvent
+                // Folia start - region threading
+                if (packetListener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl commonPacketListener) {
+                    net.minecraft.server.MinecraftServer.getServer().getPlayerList().removeConnection(
+                            commonPacketListener.getOwner().name(),
+                            commonPacketListener.getOwner().id(), this
+                    );
+                } else if (packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener) {
+                    if (loginPacketListener.state.ordinal() >= net.minecraft.server.network.ServerLoginPacketListenerImpl.State.VERIFYING.ordinal()) {
+                        net.minecraft.server.MinecraftServer.getServer().getPlayerList().removeConnection(
+                                loginPacketListener.authenticatedProfile.name(),
+                                loginPacketListener.authenticatedProfile.id(), this
+                        );
+                    }
+                }
+                // Folia end - region threading
             }
         }
     }
@@ -858,15 +939,25 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     // Paper start - Optimize network
     public void clearPacketQueue() {
         final net.minecraft.server.level.ServerPlayer player = getPlayer();
-        for (final Consumer<Connection> queuedAction : this.pendingActions) {
-            if (queuedAction instanceof PacketSendAction packetSendAction) {
-                final Packet<?> packet = packetSendAction.packet;
-                if (packet.hasFinishListener()) {
-                    packet.onPacketDispatchFinish(player, null);
+        // Folia start - region threading - connection fixes
+        java.util.List<Connection.PacketSendAction> queuedPackets = new java.util.ArrayList<>();
+        // synchronise so that flushQueue does not poll values while the queue is being cleared
+        synchronized (this.pendingActions) {
+            Connection.WrappedConsumer consumer;
+            while ((consumer = this.pendingActions.poll()) != null) {
+                if (consumer instanceof Connection.PacketSendAction packetHolder) {
+                    queuedPackets.add(packetHolder);
                 }
             }
         }
-        this.pendingActions.clear();
+
+        for (Connection.PacketSendAction queuedPacket : queuedPackets) {
+            Packet<?> packet = queuedPacket.packet;
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+        }
+        // Folia end - region threading - connection fixes
     }
 
     private static final class InnerUtil { // Attempt to hide these methods from ProtocolLib, so it doesn't accidently pick them up.
diff --git a/net/minecraft/network/PacketProcessor.java b/net/minecraft/network/PacketProcessor.java
index 3e4241976fdfe65bc0aae90a9097770745c0ddf1..f9300b9f8d15843dae8fd73ff066e4be99b60451 100644
--- a/net/minecraft/network/PacketProcessor.java
+++ b/net/minecraft/network/PacketProcessor.java
@@ -19,6 +19,12 @@ public class PacketProcessor implements AutoCloseable {
         this.runningThread = runningThread;
     }
 
+    // Folia start - region threading
+    public boolean hasPackets() {
+        return !this.packetsToBeHandled.isEmpty();
+    }
+    // Folia end - region threading
+
     // Paper start - improve tick loop
     public final boolean executeSinglePacket() {
         if (this.closed) {
@@ -39,9 +45,9 @@ public class PacketProcessor implements AutoCloseable {
         return Thread.currentThread() == this.runningThread;
     }
 
-    public <T extends PacketListener> void scheduleIfPossible(T listener, Packet<T> packet) {
+    public <T extends PacketListener> boolean scheduleIfPossible(T listener, Packet<T> packet) { // Folia - region threading - return whether to notify
         if (this.closed) {
-            throw new RejectedExecutionException("Server already shutting down");
+            throw new RejectedExecutionException("Packet processor is shut down"); // Folia - region threading - change exception message
         } else {
             // Paper start - improve tick loop
             // wake up main thread inbetween ticks to process packets
@@ -52,9 +58,10 @@ public class PacketProcessor implements AutoCloseable {
                 // only unpark if we are the first packet OR are at the head of the queue
                 // we unpark if we are at the head in case the main thread emptied the queue
                 // immediately before we added but after checking isEmpty
-                java.util.concurrent.locks.LockSupport.unpark(this.runningThread);
+                return true; // Folia - region threading - return whether to notify
             }
             // Paper end - improve tick loop
+            return false; // Folia - region threading - return whether to notify
         }
     }
 
@@ -93,7 +100,7 @@ public class PacketProcessor implements AutoCloseable {
         public void handle() {
             packetProcessing.push(this.listener); // Paper - detailed watchdog information
             try { // Paper - detailed watchdog information
-            if (this.listener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl serverCommonPacketListener && serverCommonPacketListener.processedDisconnect) return; // Paper - Don't handle sync packets for kicked players
+            if (this.listener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl serverCommonPacketListener && (serverCommonPacketListener.processedDisconnect || serverCommonPacketListener.handledDisconnect)) return; // Paper - Don't handle sync packets for kicked players // Folia - correctly handle cases where the configuration listener disconnects, ensure that no login packets get processed
             if (this.listener.shouldHandleMessage(this.packet)) {
                 try {
                     this.packet.handle(this.listener);
diff --git a/net/minecraft/network/protocol/PacketUtils.java b/net/minecraft/network/protocol/PacketUtils.java
index 42d2f82b24ae48471bfc091667f8e84c5b0d62a8..ab80a66646a7ebe2862221ac342b06c14fcfc734 100644
--- a/net/minecraft/network/protocol/PacketUtils.java
+++ b/net/minecraft/network/protocol/PacketUtils.java
@@ -19,8 +19,16 @@ public class PacketUtils {
     }
 
     public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T packetListener, PacketProcessor processor) throws RunningOnDifferentThreadException {
-        if (!processor.isSameThread()) {
-            processor.scheduleIfPossible(packetListener, packet);
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) { // Folia - region threading
+            // Folia start - region threading
+            if (packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl gamePacketListener) {
+                gamePacketListener.player.getBukkitEntity().schedulePacket(packetListener, packet);
+            } else if (packetListener instanceof net.minecraft.server.network.ServerConfigurationPacketListenerImpl || packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl) {
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().schedulePacket(packetListener, packet);
+            } else {
+                throw new UnsupportedOperationException("Unknown listener: " + processor);
+            }
+            // Folia end - region threading
             throw RunningOnDifferentThreadException.RUNNING_ON_DIFFERENT_THREAD;
         }
     }
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index aa4d7c102c0952c35e6068dfa7f29e2fe52a43b2..b68e0220b3a2850f6a10578c0784decdc0cdef18 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -196,7 +196,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
     private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
-    private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND; // Folia - region threading - public
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
     private static final int MAX_STATUS_PLAYER_SAMPLE = 12;
     public static final int SPAWN_POSITION_SEARCH_RADIUS = 5;
@@ -232,8 +232,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private volatile boolean running = true;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
     private boolean stopped;
-    private int tickCount;
-    private int ticksUntilAutosave = 6000;
+    // Folia - region threading
     protected final Proxy proxy;
     private boolean onlineMode;
     private boolean preventProxyConnections;
@@ -289,7 +288,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public org.bukkit.craftbukkit.CraftServer server;
     public joptsimple.OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
-    public static int currentTick; // Paper - improve tick loop
+    //public static int currentTick; // Paper - improve tick loop // Folia - region threading
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // Paper - don't store the vanilla dispatcher
@@ -382,6 +381,50 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
     // Paper end - improve tick loop
 
+    // Folia start - regionised ticking
+    public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer();
+
+    @Override
+    public <V> CompletableFuture<V> submit(java.util.function.Supplier<V> task) {
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        return super.submit(task);
+    }
+
+    @Override
+    public CompletableFuture<Void> submit(Runnable task) {
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        return super.submit(task);
+    }
+
+    @Override
+    public void schedule(TickTask task) {
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        super.schedule(task);
+    }
+
+    @Override
+    public void executeBlocking(Runnable runnable) {
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        super.executeBlocking(runnable);
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        super.execute(runnable);
+    }
+    // Folia end - regionised ticking
+
     public static <S extends MinecraftServer> S spin(Function<Thread, S> threadFunction) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
         AtomicReference<S> atomicReference = new AtomicReference<>();
@@ -410,46 +453,30 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
     private static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
 
-    private long lastMidTickExecute;
-    private long lastMidTickExecuteFailure;
-
-    private boolean tickMidTickTasks() {
-        // give all worlds a fair chance at by targeting them all.
-        // if we execute too many tasks, that's fine - we have logic to correctly handle overuse of allocated time.
-        boolean executed = false;
-        for (final ServerLevel world : this.getAllLevels()) {
-            long currTime = System.nanoTime();
-            if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
-                continue;
-            }
-            if (!world.getChunkSource().pollTask()) {
-                // we need to back off if this fails
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$setLastMidTickFailure(currTime);
-            } else {
-                executed = true;
-            }
-        }
+    // Folia - region threading - moved to regionized data
 
-        return executed;
+    private boolean tickMidTickTasks(final io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Folia - region threading
+        return worldData.world.getChunkSource().pollTask(); // Folia - region threading
     }
 
     @Override
     public final void moonrise$executeMidTickTasks() {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         final long startTime = System.nanoTime();
-        if ((startTime - this.lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - this.lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
+        if ((startTime - worldData.lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - worldData.lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) { // Folia - region threading
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
             // so, backoff to prevent this
             return;
         }
 
         for (;;) {
-            final boolean moreTasks = this.tickMidTickTasks();
+            final boolean moreTasks = this.tickMidTickTasks(worldData); // Folia - region threading
             final long currTime = System.nanoTime();
             final long diff = currTime - startTime;
 
             if (!moreTasks || diff >= MAX_CHUNK_EXEC_TIME) {
                 if (!moreTasks) {
-                    this.lastMidTickExecuteFailure = currTime;
+                    worldData.lastMidTickExecuteFailure = currTime; // Folia - region threading
                 }
 
                 // note: negative values reduce the time
@@ -462,7 +489,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 final double overuseCount = (double)overuse/(double)MAX_CHUNK_EXEC_TIME;
                 final long extraSleep = (long)Math.round(overuseCount*CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
 
-                this.lastMidTickExecute = currTime + extraSleep;
+                worldData.lastMidTickExecute = currTime + extraSleep; // Folia - region threading
                 return;
             }
         }
@@ -530,7 +557,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.tickFrame = TracyClient.createDiscontinuousFrame("Server Tick");
             this.notificationManager = new NotificationManager();
             this.serverActivityMonitor = new ServerActivityMonitor(this.notificationManager, 30);
-            this.packetProcessor = new PacketProcessor(serverThread);
+            this.packetProcessor = null; // Folia - region threading
         }
         // CraftBukkit start
         this.options = options;
@@ -838,8 +865,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             levelLoadListener.updateFocus(level.dimension(), chunkPos);
             int spawnHeight = chunkSource.getGenerator().getSpawnHeight(level);
             if (spawnHeight < level.getMinY()) {
-                BlockPos worldPosition = chunkPos.getWorldPosition();
-                spawnHeight = level.getHeight(Heightmap.Types.WORLD_SURFACE, worldPosition.getX() + 8, worldPosition.getZ() + 8);
+                // Folia start - region threading
+                // pre-apply offset to make the rest easier
+                BlockPos worldPosition = chunkPos.getWorldPosition().offset(8, 0, 8);
+                spawnHeight = level.moonrise$getChunkTaskScheduler().syncLoadNonFull(
+                        worldPosition.getX() >> 4, worldPosition.getZ() >> 4,
+                        net.minecraft.world.level.chunk.status.ChunkStatus.SPAWN
+                ).getHeight(Heightmap.Types.WORLD_SURFACE, worldPosition.getX(), worldPosition.getZ()) + 1; // add one to match LevelReader#getHeight
+                // Folia end - region threading
             }
 
             levelData.setSpawn(LevelData.RespawnData.of(level.dimension(), chunkPos.getWorldPosition().offset(8, spawnHeight, 8), 0.0F, 0.0F));
@@ -867,7 +900,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 i1 += i3;
             }
 
-            if (generateBonusChest) {
+            if (false && generateBonusChest) { // Folia - region threading - too lazy to hack around this one
                 level.registryAccess()
                     .lookup(Registries.CONFIGURED_FEATURE)
                     .flatMap(registry -> registry.get(MiscOverworldFeatures.BONUS_CHEST))
@@ -896,19 +929,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         ChunkLoadCounter chunkLoadCounter = new ChunkLoadCounter();
 
         if (true) { // CraftBukkit
-            chunkLoadCounter.track(serverLevel, () -> {
+            //chunkLoadCounter.track(serverLevel, () -> { // Folia - region threading
                 TicketStorage ticketStorage = serverLevel.getDataStorage().get(TicketStorage.TYPE);
                 if (ticketStorage != null) {
                     ticketStorage.activateAllDeactivatedTickets();
                 }
-            });
+            //}); // Folia - region threading
         }
 
         serverLevel.levelLoadListener.start(LevelLoadListener.Stage.LOAD_INITIAL_CHUNKS, chunkLoadCounter.totalChunks()); // Paper - per world load listener
 
         do {
             serverLevel.levelLoadListener.update(LevelLoadListener.Stage.LOAD_INITIAL_CHUNKS, chunkLoadCounter.readyChunks(), chunkLoadCounter.totalChunks()); // Paper - per world load listener
-            this.executeModerately(); // CraftBukkit
+            //this.executeModerately(); // CraftBukkit // Folia - region threading
         } while (chunkLoadCounter.pendingChunks() > 0);
 
         serverLevel.levelLoadListener.finish(LevelLoadListener.Stage.LOAD_INITIAL_CHUNKS); // Paper - per world load listener
@@ -916,6 +949,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.updateEffectiveRespawnData();
         this.forceTicks = false; // CraftBukkit
         //serverLevel.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - rewrite chunk system
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(serverLevel); // Folia - region threading
         new org.bukkit.event.world.WorldLoadEvent(serverLevel.getWorld()).callEvent(); // Paper - call WorldLoadEvent
     }
 
@@ -999,7 +1033,37 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
     // CraftBukkit end
 
+    // Folia start - region threading
+    private final java.util.concurrent.atomic.AtomicBoolean hasStartedShutdownThread = new java.util.concurrent.atomic.AtomicBoolean();
+
+    private void haltServerRegionThreading() {
+        if (this.hasStartedShutdownThread.getAndSet(true)) {
+            // already started shutdown
+            return;
+        }
+        new io.papermc.paper.threadedregions.RegionShutdownThread("Region shutdown thread").start();
+    }
+
+    public void haltCurrentRegion() {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isShutdownThread()) {
+            throw new IllegalStateException();
+        }
+    }
+    // Folia end - region threading
+
     public void stopServer() {
+        // Folia start - region threading
+        // halt scheduler
+        // don't wait, we may be on a scheduler thread
+        io.papermc.paper.threadedregions.TickRegions.getScheduler().halt(false, 0L);
+        // cannot run shutdown logic on this thread, as it may be a scheduler
+        if (true) {
+            if (!ca.spottedleaf.moonrise.common.util.TickThread.isShutdownThread()) {
+                this.haltServerRegionThreading();
+                return;
+            } // else: fall through to regular stop logic
+        }
+        // Folia end - region threading
         // CraftBukkit start - prevent double stopping on multiple threads
         synchronized(this.stopLock) {
             if (this.hasStopped) return;
@@ -1009,7 +1073,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         shutdownThread = Thread.currentThread(); // Paper - Improved watchdog support
         org.spigotmc.WatchdogThread.doStop(); // Paper - Improved watchdog support
         // CraftBukkit end
-        this.packetProcessor.close();
+        //this.packetProcessor.close(); // Folia - region threading
         if (this.metricsRecorder.isRecording()) {
             this.cancelRecordingMetrics();
         }
@@ -1027,12 +1091,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.getConnection().stop();
         this.isSaving = true;
         if (this.playerList != null) {
-            LOGGER.info("Saving players");
-            this.playerList.saveAll();
+            //LOGGER.info("Saving players"); // Folia - move to shutdown thread logic
+            //this.playerList.saveAll(); // Folia - move to shutdown thread logic
             this.playerList.removeAll(this.isRestarting); // Paper
             try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
         }
 
+        // Folia start - region threading
+        if (true) {
+            // the rest till part 2 is handled by the region shutdown thread
+            return;
+        }
+        // Folia end - region threading
+
         LOGGER.info("Saving worlds");
 
         for (ServerLevel serverLevel : this.getAllLevels()) {
@@ -1061,6 +1132,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.saveAllChunks(false, true, false, true); // Paper - rewrite chunk system
 
         this.isSaving = false;
+        // Folia start - region threading
+        this.stopPart2();
+    }
+    public void stopPart2() {
+        // Folia end - region threading
         this.resources.close();
 
         try {
@@ -1119,6 +1195,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
         // Paper end
         this.running = false;
+        this.stopServer(); // Folia - region threading
         if (waitForShutdown) {
             try {
                 this.serverThread.join();
@@ -1267,6 +1344,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.status = this.buildServerStatus();
 
             this.server.spark.enableBeforePlugins(); // Paper - spark
+            // Folia start - region threading
+            if (true) {
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
+                final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli(); // Paper - Improve startup message
+                LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Improve startup message
+                for (;;) {
+                    try {
+                        Thread.sleep(Long.MAX_VALUE);
+                    } catch (final InterruptedException ex) {}
+                }
+            }
+            // Folia end - region threading
             // Spigot start
             // Paper start
             LOGGER.info("Running delayed init tasks");
@@ -1322,13 +1411,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.lastOverloadWarningNanos = this.nextTickTimeNanos;
 
                 this.currentTickStart = tickStart;
-                ++MinecraftServer.currentTick;
+                //++MinecraftServer.currentTick; // Folia - region threading
                 // Paper end - improve tick loop
 
                 boolean flag = l == 0L;
                 if (this.debugCommandProfilerDelayStart) {
                     this.debugCommandProfilerDelayStart = false;
-                    this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
+                    //this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount); // Folia - region threading
                 }
 
                 // Paper - improve tick loop - done above
@@ -1482,28 +1571,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public TickTask wrapRunnable(Runnable runnable) {
-        // Paper start - anything that does try to post to main during watchdog crash, run on watchdog
-        if (this.hasStopped && Thread.currentThread().equals(shutdownThread)) {
-            runnable.run();
-            runnable = () -> {};
-        }
-        // Paper end
-        return new TickTask(this.tickCount, runnable);
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
     protected boolean shouldRun(TickTask runnable) {
-        return runnable.getTick() + 1 < this.tickCount || this.haveTime(); // Paper - improve tick loop - do not stall queued tasks
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
     public boolean pollTask() {
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         boolean flag = this.packetProcessor.executeSinglePacket() | this.pollTaskInternal(); // Paper - improve tick loop - process packets while waiting inbetween ticks
         this.mayHaveDelayedTasks = flag;
         return flag;
     }
 
     private boolean pollTaskInternal() {
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         if (super.pollTask()) {
             this.moonrise$executeMidTickTasks(); // Paper - rewrite chunk system
             return true;
@@ -1523,6 +1608,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public void doRunTask(TickTask task) {
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         Profiler.get().incrementCounter("runTask");
         super.doRunTask(task);
     }
@@ -1569,12 +1655,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
-    public void tickServer(BooleanSupplier hasTimeLeft) {
+    // Folia start - region threading
+    public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
+                           io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
+        // Folia end - region threading
         org.spigotmc.WatchdogThread.tick(); // Spigot
-        long nanos = Util.getNanos();
+        long nanos = startTime; // Folia - region threading
         int i = this.pauseWhenEmptySeconds() * 20;
         this.removeDisabledPluginsBlockingSleep(); // Paper - API to allow/disallow tick sleeping
-        if (i > 0) {
+        if (false && i > 0) { // Folia - region threading - this is complicated to implement, and even if done correctly is messy
             if (this.playerList.getPlayerCount() == 0 && !this.tickRateManager.isSprinting() && this.pluginsBlockingSleep.isEmpty()) { // Paper - API to allow/disallow tick sleeping
                 this.emptyTicks++;
             } else {
@@ -1599,24 +1688,53 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     level.getChunkSource().tick(() -> true, false);
                 }
                 // Paper end - avoid issues with certain tasks not processing during sleep
-                this.server.spark.executeMainThreadTasks(); // Paper - spark
+                //this.server.spark.executeMainThreadTasks(); // Paper - spark // Folia - region threading
                 this.tickConnection();
                 this.server.spark.tickEnd(((double)(System.nanoTime() - this.currentTickStart) / 1000000D)); // Paper - spark
                 return;
             }
         }
 
+        // Folia start - region threading
+        region.world.getCurrentWorldData().updateTickData();
+        BooleanSupplier hasTimeLeft = () -> {
+            return scheduledEnd - System.nanoTime() > targetBuffer;
+        };
+        // Folia end - region threading
+
         this.server.spark.tickStart(); // Paper - spark
-        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper - Server Tick Events
-        this.tickCount++;
-        this.tickRateManager.tick();
-        this.tickChildren(hasTimeLeft);
-        if (nanos - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) {
+        new com.destroystokyo.paper.event.server.ServerTickStartEvent((int)region.getCurrentTick()).callEvent(); // Paper - Server Tick Events // Folia - region threading
+        // Folia start - region threading
+        if (region != null) {
+            region.getTaskQueueData().drainTasks();
+            // run all player packets
+            for (ServerPlayer player : new java.util.ArrayList<>(region.world.getCurrentWorldData().getLocalPlayers())) {
+                PacketProcessor packetProcessor = ((org.bukkit.craftbukkit.entity.CraftPlayer)player.getBukkitEntity()).packetProcessor;
+                while (packetProcessor.hasPackets() && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+                    packetProcessor.executeSinglePacket();
+                }
+            }
+            ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)org.bukkit.Bukkit.getRegionScheduler()).tick();
+            // now run all the entity schedulers
+            for (io.papermc.paper.threadedregions.EntityScheduler scheduler : region.world.getCurrentWorldData().entitySchedulerTickList.getAllSchedulers()) {
+                net.minecraft.world.entity.Entity handle = scheduler.entity.getHandleRaw();
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(handle) || scheduler.isRetired()) {
+                    continue;
+                }
+
+                scheduler.executeTick();
+            }
+        }
+        // Folia end - region threading
+        //this.tickCount++; // Folia - region threading
+        //this.tickRateManager.tick(); // Folia - region threading
+        this.tickChildren(hasTimeLeft, region); // Folia - region threading
+        if (false && nanos - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) { // Folia - region threading
             this.lastServerStatus = nanos;
             this.status = this.buildServerStatus();
         }
 
-        this.ticksUntilAutosave--;
+        //this.ticksUntilAutosave--; // Folia - region threading
         // Paper start - Incremental chunk and player saving
         final ProfilerFiller profiler = Profiler.get();
         int playerSaveInterval = io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.rate;
@@ -1624,15 +1742,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             playerSaveInterval = autosavePeriod;
         }
         profiler.push("save");
-        final boolean fullSave = autosavePeriod > 0 && this.tickCount % autosavePeriod == 0;
+        final boolean fullSave = autosavePeriod > 0 && io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() % autosavePeriod == 0; // Folia - region threading
         try {
             this.isSaving = true;
             if (playerSaveInterval > 0) {
                 this.playerList.saveAll(playerSaveInterval);
             }
-            for (final ServerLevel level : this.getAllLevels()) {
+            for (final ServerLevel level : (region == null ? this.getAllLevels() : Arrays.asList(region.world))) { // Folia - region threading
                 if (level.paperConfig().chunks.autoSaveInterval.value() > 0) {
-                    level.saveIncrementally(fullSave);
+                    level.saveIncrementally(region == null && fullSave); // Folia - region threading - don't save level.dat
                 }
             }
         } finally {
@@ -1642,22 +1760,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper end - Incremental chunk and player saving
 
         ProfilerFiller profilerFiller = Profiler.get();
-        this.server.spark.executeMainThreadTasks(); // Paper - spark
+        //this.server.spark.executeMainThreadTasks(); // Paper - spark // Folia - region threading
         // Paper start - Server Tick Events
         long endTime = System.nanoTime();
-        long remaining = this.nextTickTimeNanos - endTime;
-        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double)(endTime - this.currentTickStart) / 1000000D), remaining).callEvent();
+        long remaining = scheduledEnd - endTime; // Folia - region ticking
+        new com.destroystokyo.paper.event.server.ServerTickEndEvent((int)io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(), ((double)(endTime - startTime) / 1000000D), remaining).callEvent(); // Folia - region ticking
         // Paper end - Server Tick Events
-        this.server.spark.tickEnd(((double)(endTime - this.currentTickStart) / 1000000D)); // Paper - spark
-        profilerFiller.push("tallying");
-        long l = Util.getNanos() - nanos;
-        int i1 = this.tickCount % 100;
-        this.aggregatedTickTimesNanos = this.aggregatedTickTimesNanos - this.tickTimesNanos[i1];
-        this.aggregatedTickTimesNanos += l;
-        this.tickTimesNanos[i1] = l;
-        this.smoothedTickTimeMillis = this.smoothedTickTimeMillis * 0.8F + (float)l / (float)TimeUtil.NANOSECONDS_PER_MILLISECOND * 0.19999999F;
-        this.logTickMethodTime(nanos);
-        profilerFiller.pop();
+        this.server.spark.tickEnd(((double)(endTime - startTime) / 1000000D)); // Paper - spark // Folia - region threading
+        // Folia - region threading
     }
 
     protected void processPacketsAndTick(boolean sprinting) {
@@ -1666,7 +1776,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.tickFrame.start();
         // Paper - improve tick loop - moved into runAllTasksAtTickStart
         this.runAllTasksAtTickStart(); // Paper - improve tick loop
-        this.tickServer(sprinting ? () -> false : this::haveTime);
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         // Paper start - rewrite chunk system
         final Throwable crash = this.chunkSystemCrash;
         if (crash != null) {
@@ -1680,7 +1790,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private void autoSave() {
-        this.ticksUntilAutosave = this.autosavePeriod; // CraftBukkit
+        //this.ticksUntilAutosave = this.autosavePeriod; // CraftBukkit // Folia - region threading
         LOGGER.debug("Autosave started");
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("save");
@@ -1695,30 +1805,22 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    private int computeNextAutosaveInterval() {
-        float f;
-        if (this.tickRateManager.isSprinting()) {
-            long l = this.getAverageTickTimeNanos() + 1L;
-            f = (float)TimeUtil.NANOSECONDS_PER_SECOND / (float)l;
-        } else {
-            f = this.tickRateManager.tickrate();
-        }
-
-        int i = 300;
-        return Math.max(100, (int)(f * 300.0F));
-    }
+    // Folia - region threading - use absolute time instead of this
 
     public void onTickRateChanged() {
-        int i = this.computeNextAutosaveInterval();
-        if (i < this.ticksUntilAutosave) {
-            this.ticksUntilAutosave = i;
-        }
+        // Folia - region threading - use absolute time instead of this
     }
 
     protected abstract SampleLogger getTickTimeLogger();
 
     public abstract boolean isTickTimeLoggingEnabled();
 
+    // Folia start - region threading
+    public void rebuildServerStatus() {
+        this.status = this.buildServerStatus();
+    }
+    // Folia end - region threading
+
     private ServerStatus buildServerStatus() {
         ServerStatus.Players players = this.buildPlayerStatus();
         return new ServerStatus(
@@ -1731,7 +1833,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private ServerStatus.Players buildPlayerStatus() {
-        List<ServerPlayer> players = this.playerList.getPlayers();
+        List<ServerPlayer> players = new java.util.ArrayList<>(this.playerList.getPlayers()); // Folia - region threading
         int maxPlayers = this.getMaxPlayers();
         if (this.hidesOnlinePlayers()) {
             return new ServerStatus.Players(maxPlayers, players.size(), List.of());
@@ -1750,44 +1852,36 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList(); // Paper - optimise Folia entity scheduler
+    // Folia - region threading - moved to regionised data
 
-    protected void tickChildren(BooleanSupplier hasTimeLeft) {
+    protected void tickChildren(BooleanSupplier hasTimeLeft, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - region threading
+        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - regionised ticking
         ProfilerFiller profilerFiller = Profiler.get();
-        this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
-        this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
-        // Paper start - optimise Folia entity scheduler
-        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler)org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        for (io.papermc.paper.threadedregions.EntityScheduler scheduler : this.entitySchedulerTickList.getAllSchedulers()) {
-            if (scheduler.isRetired()) {
-                continue;
-            }
-
-            scheduler.executeTick();
-        }
-        // Paper end - optimise Folia entity scheduler
-        io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.ADVENTURE_CLICK_MANAGER.handleQueue(this.tickCount); // Paper
-        io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper
+        //this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing()); // Folia - region threading
+        //this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit // Folia - region threading
+        // Folia - region threading - moved to global tick - and moved entity scheduler to tickRegion
+        //io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.ADVENTURE_CLICK_MANAGER.handleQueue(this.tickCount); // Paper // Folia - region threading - moved to global tick
+        //io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper // Folia - region threading - moved to global tick
         profilerFiller.push("commandFunctions");
-        this.getFunctions().tick();
+        //this.getFunctions().tick(); // Folia - region threading - TODO Purge functions
         profilerFiller.popPush("levels");
         this.updateEffectiveRespawnData();
 
         // CraftBukkit start
         // Run tasks that are waiting on processing
-        while (!this.processQueue.isEmpty()) {
+        if (false) while (!this.processQueue.isEmpty()) { // Folia - region threading
             this.processQueue.remove().run();
         }
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        if (true) { ServerLevel level = region.world; // Folia - region threading
             final boolean doDaylight = level.getGameRules().get(GameRules.ADVANCE_TIME);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
             final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
-            for (Player entityhuman : level.players()) {
-                if (!(entityhuman instanceof ServerPlayer) || (tickCount + entityhuman.getId()) % 20 != 0) {
+            for (Player entityhuman : level.getLocalPlayers()) { // Folia - region threading
+                if (!(entityhuman instanceof ServerPlayer) || (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + entityhuman.getId()) % 20 != 0) { // Folia - region threading
                     continue;
                 }
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
@@ -1800,12 +1894,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
 
-        this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
-        for (ServerLevel serverLevel : this.getAllLevels()) {
-            serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            serverLevel.updateLagCompensationTick(); // Paper - lag compensation
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+        //this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked // Folia - region threading
+        if (true) { ServerLevel serverLevel = region.world; // Folia - region threading
+            // Folia - region threading
             profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().identifier());
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
@@ -1818,7 +1909,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             profilerFiller.push("tick");
 
             try {
-                serverLevel.tick(hasTimeLeft);
+                serverLevel.tick(hasTimeLeft, region); // Folia - region threading
             } catch (Throwable var7) {
                 CrashReport crashReport = CrashReport.forThrowable(var7, "Exception ticking world");
                 serverLevel.fillReportDetails(crashReport);
@@ -1827,14 +1918,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             profilerFiller.pop();
             profilerFiller.pop();
-            serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
+            regionizedWorldData.explosionDensityCache.clear(); // Paper - Optimize explosions // Folia - region threading
         }
-        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        //this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked // Folia - region threading
 
         profilerFiller.popPush("connection");
-        this.tickConnection();
+        regionizedWorldData.tickConnections(); // Folia - region threading
         profilerFiller.popPush("players");
-        this.playerList.tick();
+        //this.playerList.tick(); // Folia - region threading
         profilerFiller.popPush("debugSubscribers");
         this.debugSubscribers.tick();
         if (this.tickRateManager.runsNormally()) {
@@ -1844,13 +1935,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         profilerFiller.popPush("server gui refresh");
 
-        for (Runnable runnable : this.tickables) {
+        if (false) for (Runnable runnable : this.tickables) { // Folia - region threading - TODO WTF is this?
             runnable.run();
         }
 
         profilerFiller.popPush("send chunks");
 
-        for (ServerPlayer serverPlayer : this.playerList.getPlayers()) {
+        if (false) for (ServerPlayer serverPlayer : this.playerList.getPlayers()) { // Folia - region threading
             serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
             serverPlayer.connection.resumeFlushing();
         }
@@ -2150,11 +2241,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             int i = 0;
 
             for (ServerPlayer serverPlayer : this.getPlayerList().getPlayers()) {
+                serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> { // Folia - region threading
                 // Paper start - Expand PlayerGameModeChangeEvent
-                org.bukkit.event.player.PlayerGameModeChangeEvent event = serverPlayer.setGameMode(gameMode, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.DEFAULT_GAMEMODE, null);
+                org.bukkit.event.player.PlayerGameModeChangeEvent event = player.setGameMode(gameMode, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.DEFAULT_GAMEMODE, null); // Folia - region threading
                 if (event == null || event.isCancelled()) {
-                    continue;
+                    return; // Folia - region threading
                 }
+                }, null, 1L); // Folia - region threading
                 i++;
                 // Paper end - Expand PlayerGameModeChangeEvent
             }
@@ -2176,7 +2269,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public int getTickCount() {
-        return this.tickCount;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     public boolean isUnderSpawnProtection(ServerLevel level, BlockPos pos, Player player) {
@@ -2212,6 +2305,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public void invalidateStatus() {
+        // Folia start - region threading
+        if (true) {
+            // we don't need this to notify the global tick region
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTaskWithoutNotify(() -> {
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().invalidateStatus();
+            });
+            return;
+        }
+        // Folia end - region threading
         this.lastServerStatus = 0L;
     }
 
@@ -2226,6 +2328,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public void executeIfPossible(Runnable task) {
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         if (this.isStopped()) {
             throw new io.papermc.paper.util.ServerStopRejectedExecutionException("Server already shutting down"); // Paper - do not prematurely disconnect players on stop
         } else {
@@ -2568,7 +2671,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public long getAverageTickTimeNanos() {
-        return this.aggregatedTickTimesNanos / Math.min(100, Math.max(this.tickCount, 1));
+        // Folia start - region threading
+        if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask() instanceof io.papermc.paper.threadedregions.TickRegionScheduler.RegionScheduleHandle handle) {
+            return (long)Math.ceil(handle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average());
+        }
+        return 0L;
+        // Folia end - region threading
     }
 
     public long[] getTickTimesNanos() {
@@ -2812,13 +2920,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public ProfileResults stopTimeProfiler() {
-        if (this.debugCommandProfiler == null) {
-            return EmptyProfileResults.EMPTY;
-        } else {
-            ProfileResults profileResults = this.debugCommandProfiler.stop(Util.getNanos(), this.tickCount);
-            this.debugCommandProfiler = null;
-            return profileResults;
-        }
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     public int getMaxChainedNeighborUpdates() {
@@ -3070,24 +3172,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // Paper start - API to check if the server is sleeping
     public boolean isTickPaused() {
-        return this.emptyTicks > 0 && this.emptyTicks >= this.pauseWhenEmptySeconds() * 20;
+        return false; // Folia - region threading
     }
 
     public void addPluginAllowingSleep(final String pluginName, final boolean value) {
-        if (!value) {
-            this.pluginsBlockingSleep.add(pluginName);
-        } else {
-            this.pluginsBlockingSleep.remove(pluginName);
-        }
+        // Folia - region threading
     }
 
     private void removeDisabledPluginsBlockingSleep() {
-        if (this.pluginsBlockingSleep.isEmpty()) {
-            return;
-        }
-        this.pluginsBlockingSleep.removeIf(plugin -> (
-            !io.papermc.paper.plugin.manager.PaperPluginManagerImpl.getInstance().isPluginEnabled(plugin)
-        ));
+        // Folia - region threading
     }
     // Paper end - API to check if the server is sleeping
 }
diff --git a/net/minecraft/server/commands/AdvancementCommands.java b/net/minecraft/server/commands/AdvancementCommands.java
index 7ec90a444da501664e9fe21f6082ff1cdaa18b32..c8943ee098beca5509a3e68dd306419e8767394a 100644
--- a/net/minecraft/server/commands/AdvancementCommands.java
+++ b/net/minecraft/server/commands/AdvancementCommands.java
@@ -257,7 +257,12 @@ public class AdvancementCommands {
         int i = 0;
 
         for (ServerPlayer serverPlayer : targets) {
-            i += action.perform(serverPlayer, advancements, grantEverything);
+            // Folia start - region threading
+            i += 1;
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                action.perform(player, advancements, grantEverything);
+            }, null, 1L);
+            // Folia end - region threading
         }
 
         if (i == 0) {
@@ -321,9 +326,12 @@ public class AdvancementCommands {
             throw ERROR_CRITERION_NOT_FOUND.create(Advancement.name(advancement), criterionName);
         } else {
             for (ServerPlayer serverPlayer : targets) {
-                if (action.performCriterion(serverPlayer, advancement, criterionName)) {
-                    i++;
-                }
+                // Folia start - region threading
+                ++i;
+                serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                    action.performCriterion(player, advancement, criterionName);
+                }, null, 1L);
+                // Folia end - region threading
             }
 
             if (i == 0) {
diff --git a/net/minecraft/server/commands/AttributeCommand.java b/net/minecraft/server/commands/AttributeCommand.java
index 6b35bfbc106d1db2398415683cdb6e811ab1ffc7..41886819ece8d6d08574872458b09addbd998c74 100644
--- a/net/minecraft/server/commands/AttributeCommand.java
+++ b/net/minecraft/server/commands/AttributeCommand.java
@@ -266,30 +266,62 @@ public class AttributeCommand {
         }
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int getAttributeValue(CommandSourceStack source, Entity entity, Holder<Attribute> attribute, double scale) throws CommandSyntaxException {
-        LivingEntity entityWithAttribute = getEntityWithAttribute(entity, attribute);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        LivingEntity entityWithAttribute = getEntityWithAttribute(nmsEntity, attribute); // Folia - region threading
         double attributeValue = entityWithAttribute.getAttributeValue(attribute);
         source.sendSuccess(
-            () -> Component.translatable("commands.attribute.value.get.success", getAttributeDescription(attribute), entity.getName(), attributeValue), false
+            () -> Component.translatable("commands.attribute.value.get.success", getAttributeDescription(attribute), nmsEntity.getName(), attributeValue), false // Folia - region threading
         );
-        return (int)(attributeValue * scale);
+        return; // Folia - region threading
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static int getAttributeBase(CommandSourceStack source, Entity entity, Holder<Attribute> attribute, double scale) throws CommandSyntaxException {
-        LivingEntity entityWithAttribute = getEntityWithAttribute(entity, attribute);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        LivingEntity entityWithAttribute = getEntityWithAttribute(nmsEntity, attribute); // Folia - region threading
         double attributeBaseValue = entityWithAttribute.getAttributeBaseValue(attribute);
         source.sendSuccess(
-            () -> Component.translatable("commands.attribute.base_value.get.success", getAttributeDescription(attribute), entity.getName(), attributeBaseValue),
+            () -> Component.translatable("commands.attribute.base_value.get.success", getAttributeDescription(attribute), nmsEntity.getName(), attributeBaseValue), // Folia - region threading
             false
         );
-        return (int)(attributeBaseValue * scale);
+        return; // Folia - region threading
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static int getAttributeModifier(CommandSourceStack source, Entity entity, Holder<Attribute> attribute, Identifier id, double scale) throws CommandSyntaxException {
-        LivingEntity entityWithAttribute = getEntityWithAttribute(entity, attribute);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        LivingEntity entityWithAttribute = getEntityWithAttribute(nmsEntity, attribute); // Folia - region threading
         AttributeMap attributes = entityWithAttribute.getAttributes();
         if (!attributes.hasModifier(attribute, id)) {
-            throw ERROR_NO_SUCH_MODIFIER.create(entity.getName(), getAttributeDescription(attribute), id);
+            throw ERROR_NO_SUCH_MODIFIER.create(nmsEntity.getName(), getAttributeDescription(attribute), id); // Folia - region threading
         } else {
             double modifierValue = attributes.getModifierValue(attribute, id);
             source.sendSuccess(
@@ -297,13 +329,20 @@ public class AttributeCommand {
                     "commands.attribute.modifier.value.get.success",
                     Component.translationArg(id),
                     getAttributeDescription(attribute),
-                    entity.getName(),
+                    nmsEntity.getName(), // Folia - region threading
                     modifierValue
                 ),
                 false
             );
-            return (int)(modifierValue * scale);
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static Stream<Identifier> getAttributeModifiers(Entity entity, Holder<Attribute> attribute) throws CommandSyntaxException {
@@ -312,11 +351,22 @@ public class AttributeCommand {
     }
 
     private static int setAttributeBase(CommandSourceStack source, Entity entity, Holder<Attribute> attribute, double value) throws CommandSyntaxException {
-        getAttributeInstance(entity, attribute).setBaseValue(value);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        getAttributeInstance(nmsEntity, attribute).setBaseValue(value); // Folia - region threading
         source.sendSuccess(
-            () -> Component.translatable("commands.attribute.base_value.set.success", getAttributeDescription(attribute), entity.getName(), value), false
+            () -> Component.translatable("commands.attribute.base_value.set.success", getAttributeDescription(attribute), nmsEntity.getName(), value), false // Folia - region threading
         );
-        return 1;
+        return; // Folia - region threading
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static int resetAttributeBase(CommandSourceStack source, Entity entity, Holder<Attribute> attribute) throws CommandSyntaxException {
@@ -338,35 +388,57 @@ public class AttributeCommand {
     private static int addModifier(
         CommandSourceStack source, Entity entity, Holder<Attribute> attribute, Identifier id, double amount, AttributeModifier.Operation operation
     ) throws CommandSyntaxException {
-        AttributeInstance attributeInstance = getAttributeInstance(entity, attribute);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        AttributeInstance attributeInstance = getAttributeInstance(nmsEntity, attribute); // Folia - region threading
         AttributeModifier attributeModifier = new AttributeModifier(id, amount, operation);
         if (attributeInstance.hasModifier(id)) {
-            throw ERROR_MODIFIER_ALREADY_PRESENT.create(entity.getName(), getAttributeDescription(attribute), id);
+            throw ERROR_MODIFIER_ALREADY_PRESENT.create(nmsEntity.getName(), getAttributeDescription(attribute), id); // Folia - region threading
         } else {
             attributeInstance.addPermanentModifier(attributeModifier);
             source.sendSuccess(
                 () -> Component.translatable(
-                    "commands.attribute.modifier.add.success", Component.translationArg(id), getAttributeDescription(attribute), entity.getName()
+                    "commands.attribute.modifier.add.success", Component.translationArg(id), getAttributeDescription(attribute), nmsEntity.getName() // Folia - region threading
                 ),
                 false
             );
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static int removeModifier(CommandSourceStack source, Entity entity, Holder<Attribute> attribute, Identifier id) throws CommandSyntaxException {
-        AttributeInstance attributeInstance = getAttributeInstance(entity, attribute);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        AttributeInstance attributeInstance = getAttributeInstance(nmsEntity, attribute); // Folia - region threading
         if (attributeInstance.removeModifier(id)) {
             source.sendSuccess(
                 () -> Component.translatable(
-                    "commands.attribute.modifier.remove.success", Component.translationArg(id), getAttributeDescription(attribute), entity.getName()
+                    "commands.attribute.modifier.remove.success", Component.translationArg(id), getAttributeDescription(attribute), nmsEntity.getName() // Folia - region threading
                 ),
                 false
             );
-            return 1;
+            return; // Folia - region threading
         } else {
-            throw ERROR_NO_SUCH_MODIFIER.create(entity.getName(), getAttributeDescription(attribute), id);
+            throw ERROR_NO_SUCH_MODIFIER.create(nmsEntity.getName(), getAttributeDescription(attribute), id); // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
     private static Component getAttributeDescription(Holder<Attribute> attribute) {
diff --git a/net/minecraft/server/commands/ClearInventoryCommands.java b/net/minecraft/server/commands/ClearInventoryCommands.java
index f0ccb32c7488385314f14ceb827f94388e7f59a7..09b04c76c7de2717fb408612d7d0e08aed40e424 100644
--- a/net/minecraft/server/commands/ClearInventoryCommands.java
+++ b/net/minecraft/server/commands/ClearInventoryCommands.java
@@ -73,9 +73,14 @@ public class ClearInventoryCommands {
         int i = 0;
 
         for (ServerPlayer serverPlayer : targetPlayers) {
-            i += serverPlayer.getInventory().clearOrCountMatchingItems(itemPredicate, maxCount, serverPlayer.inventoryMenu.getCraftSlots());
-            serverPlayer.containerMenu.broadcastChanges();
-            serverPlayer.inventoryMenu.slotsChanged(serverPlayer.getInventory());
+            // Folia start - region threading
+            ++i;
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                player.getInventory().clearOrCountMatchingItems(itemPredicate, maxCount, player.inventoryMenu.getCraftSlots());
+                player.containerMenu.broadcastChanges();
+                player.inventoryMenu.slotsChanged(player.getInventory());
+            }, null, 1L);
+            // Folia end - region threading
         }
 
         if (i == 0) {
diff --git a/net/minecraft/server/commands/DamageCommand.java b/net/minecraft/server/commands/DamageCommand.java
index e55f374100734d548c1078119ddef37348d3f71c..87cb36c17afcdfd742cc3d7fc2ece9e93fc41e9f 100644
--- a/net/minecraft/server/commands/DamageCommand.java
+++ b/net/minecraft/server/commands/DamageCommand.java
@@ -102,12 +102,29 @@ public class DamageCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int damage(CommandSourceStack source, Entity target, float amount, DamageSource damageType) throws CommandSyntaxException {
-        if (target.hurtServer(source.getLevel(), damageType, amount)) {
-            source.sendSuccess(() -> Component.translatable("commands.damage.success", amount, target.getDisplayName()), true);
-            return 1;
+        // Folia start - region threading
+        target.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            try {
+                // Folia end - region threading
+        if (nmsEntity.hurtServer(source.getLevel(), damageType, amount)) { // Folia - region threading
+            source.sendSuccess(() -> Component.translatable("commands.damage.success", amount, nmsEntity.getDisplayName()), true); // Folia - region threading
+            return; // Folia - region threading
         } else {
             throw ERROR_INVULNERABLE.create();
         }
+        // Folia start - region threading
+        } catch (CommandSyntaxException ex) {
+            sendMessage(source, ex);
+        }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 }
diff --git a/net/minecraft/server/commands/EffectCommands.java b/net/minecraft/server/commands/EffectCommands.java
index 8731c07d6d907f77cd175c06c8c9064048c6ffa9..0cf2c9fbaa7ca7bee048774f4d9fad0da8ea392f 100644
--- a/net/minecraft/server/commands/EffectCommands.java
+++ b/net/minecraft/server/commands/EffectCommands.java
@@ -182,7 +182,12 @@ public class EffectCommands {
         for (Entity entity : targets) {
             if (entity instanceof LivingEntity) {
                 MobEffectInstance mobEffectInstance = new MobEffectInstance(effect, i1, amplifier, false, showParticles);
-                if (((LivingEntity)entity).addEffect(mobEffectInstance, source.getEntity(), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND)) { // CraftBukkit
+                // Folia start - region threading
+                entity.getBukkitEntity().taskScheduler.schedule((LivingEntity nmsEntity) -> {
+                    ((LivingEntity)nmsEntity).addEffect(mobEffectInstance, source.getEntity(), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND);
+                }, null, 1L);
+                // Folia end - region threading
+                if (true) { // CraftBukkit // Folia - region threading
                     i++;
                 }
             }
@@ -212,7 +217,12 @@ public class EffectCommands {
         int i = 0;
 
         for (Entity entity : targets) {
-            if (entity instanceof LivingEntity && ((LivingEntity)entity).removeAllEffects(org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND)) { // CraftBukkit
+            if (entity instanceof LivingEntity && true) { // CraftBukkit // Folia - region threading
+                // Folia start - region threading
+                entity.getBukkitEntity().taskScheduler.schedule((LivingEntity nmsEntity) -> {
+                    ((LivingEntity)nmsEntity).removeAllEffects(org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND);
+                }, null, 1L);
+                // Folia end - region threading
                 i++;
             }
         }
@@ -237,7 +247,12 @@ public class EffectCommands {
         int i = 0;
 
         for (Entity entity : targets) {
-            if (entity instanceof LivingEntity && ((LivingEntity)entity).removeEffect(effect, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND)) { // CraftBukkit
+            if (entity instanceof LivingEntity && true) { // CraftBukkit // Folia - region threading
+                // Folia start - region threading
+                entity.getBukkitEntity().taskScheduler.schedule((LivingEntity nmsEntity) -> {
+                    ((LivingEntity)nmsEntity).removeEffect(effect, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.COMMAND);
+                }, null, 1L);
+                // Folia end - region threading
                 i++;
             }
         }
diff --git a/net/minecraft/server/commands/EnchantCommand.java b/net/minecraft/server/commands/EnchantCommand.java
index 21548995eb278236946b6e495d27f6261e24f7a2..8a3ea57c5d1383cd58f13ab5120d84894884b995 100644
--- a/net/minecraft/server/commands/EnchantCommand.java
+++ b/net/minecraft/server/commands/EnchantCommand.java
@@ -68,50 +68,77 @@ public class EnchantCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Holder<Enchantment> enchantment, int level) throws CommandSyntaxException {
         Enchantment enchantment1 = enchantment.value();
         if (level > enchantment1.getMaxLevel()) {
             throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment1.getMaxLevel());
         } else {
-            int i = 0;
+            final java.util.concurrent.atomic.AtomicInteger changed = new java.util.concurrent.atomic.AtomicInteger(0); // Folia - region threading
+            final java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(targets.size()); // Folia - region threading
+            final java.util.concurrent.atomic.AtomicReference<Component> possibleSingleDisplayName = new java.util.concurrent.atomic.AtomicReference<>(); // Folia - region threading
 
             for (Entity entity : targets) {
                 if (entity instanceof LivingEntity livingEntity) {
-                    ItemStack mainHandItem = livingEntity.getMainHandItem();
-                    if (!mainHandItem.isEmpty()) {
-                        if (enchantment1.canEnchant(mainHandItem)
-                            && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment)) {
-                            mainHandItem.enchant(enchantment, level);
-                            i++;
-                        } else if (targets.size() == 1) {
-                            throw ERROR_INCOMPATIBLE.create(mainHandItem.getHoverName().getString());
+                    // Folia start - region threading
+                    entity.getBukkitEntity().taskScheduler.schedule((LivingEntity nmsEntity) -> {
+                        try {
+                            ItemStack mainHandItem = livingEntity.getMainHandItem();
+                            if (!mainHandItem.isEmpty()) {
+                                if (enchantment1.canEnchant(mainHandItem)
+                                    && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment)) {
+                                    mainHandItem.enchant(enchantment, level);
+                                    possibleSingleDisplayName.set(livingEntity.getDisplayName());
+                                    changed.incrementAndGet();
+                                } else if (targets.size() == 1) {
+                                    throw ERROR_INCOMPATIBLE.create(mainHandItem.getHoverName().getString());
+                                }
+                            } else if (targets.size() == 1) {
+                                throw ERROR_NO_ITEM.create(livingEntity.getName().getString());
+                            }
+                        } catch (final CommandSyntaxException exception) {
+                            sendMessage(source, exception);
+                            return; // don't send feedback twice
                         }
-                    } else if (targets.size() == 1) {
-                        throw ERROR_NO_ITEM.create(livingEntity.getName().getString());
-                    }
+                        sendFeedback(source, enchantment, level, possibleSingleDisplayName, count, changed);
+                    }, ignored -> sendFeedback(source, enchantment, level, possibleSingleDisplayName, count, changed), 1L);
                 } else if (targets.size() == 1) {
                     throw ERROR_NOT_LIVING_ENTITY.create(entity.getName().getString());
+                } else {
+                    sendFeedback(source, enchantment, level, possibleSingleDisplayName, count, changed);
+                    // Folia end - region threading
                 }
             }
+            return targets.size(); // Folia - region threading
+        }
+    }
 
+    // Folia start - region threading
+    private static void sendFeedback(final CommandSourceStack source, final Holder<Enchantment> enchantment, final int level, final java.util.concurrent.atomic.AtomicReference<Component> possibleSingleDisplayName, final java.util.concurrent.atomic.AtomicInteger count, final java.util.concurrent.atomic.AtomicInteger changed) {
+        if (count.decrementAndGet() == 0) {
+            final int i = changed.get();
             if (i == 0) {
-                throw ERROR_NOTHING_HAPPENED.create();
+                sendMessage(source, ERROR_NOTHING_HAPPENED.create());
             } else {
-                if (targets.size() == 1) {
+                if (i == 1) {
                     source.sendSuccess(
                         () -> Component.translatable(
-                            "commands.enchant.success.single", Enchantment.getFullname(enchantment, level), targets.iterator().next().getDisplayName()
+                            "commands.enchant.success.single", Enchantment.getFullname(enchantment, level), possibleSingleDisplayName.get()
                         ),
                         true
                     );
                 } else {
                     source.sendSuccess(
-                        () -> Component.translatable("commands.enchant.success.multiple", Enchantment.getFullname(enchantment, level), targets.size()), true
+                        () -> Component.translatable("commands.enchant.success.multiple", Enchantment.getFullname(enchantment, level), i), true
                     );
                 }
-
-                return i;
             }
         }
     }
+    // Folia end - region threading
 }
diff --git a/net/minecraft/server/commands/ExperienceCommand.java b/net/minecraft/server/commands/ExperienceCommand.java
index 473415506ef8e2268ea8ad8f229312dac1776fc7..03c4507823e404416186d7e81b4ebf33c91a8ed4 100644
--- a/net/minecraft/server/commands/ExperienceCommand.java
+++ b/net/minecraft/server/commands/ExperienceCommand.java
@@ -131,14 +131,18 @@ public class ExperienceCommand {
     }
 
     private static int queryExperience(CommandSourceStack source, ServerPlayer player, ExperienceCommand.Type type) {
-        int i = type.query.applyAsInt(player);
-        source.sendSuccess(() -> Component.translatable("commands.experience.query." + type.name, player.getDisplayName(), i), false);
-        return i;
+        player.getBukkitEntity().taskScheduler.schedule((ServerPlayer serverPlayer) -> { // Folia - region threading
+        int i = type.query.applyAsInt(serverPlayer); // Folia - region threading
+        source.sendSuccess(() -> Component.translatable("commands.experience.query." + type.name, serverPlayer.getDisplayName(), i), false); // Folia - region threading
+        }, null, 1L); // Folia - region threading
+        return 0; // Folia - region threading
     }
 
     private static int addExperience(CommandSourceStack source, Collection<? extends ServerPlayer> targets, int amount, ExperienceCommand.Type type) {
         for (ServerPlayer serverPlayer : targets) {
-            type.add.accept(serverPlayer, amount);
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> { // Folia - region threading
+                type.add.accept(player, amount);
+            }, null, 1L); // Folia - region threading
         }
 
         if (targets.size() == 1) {
@@ -157,9 +161,11 @@ public class ExperienceCommand {
         int i = 0;
 
         for (ServerPlayer serverPlayer : targets) {
-            if (type.set.test(serverPlayer, amount)) {
-                i++;
+            i++; serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> { // Folia - region threading
+            if (type.set.test(player, amount)) { // Folia - region threading
+                //i++; // Folia - region threading
             }
+            }, null, 1L); // Folia - region threading
         }
 
         if (i == 0) {
diff --git a/net/minecraft/server/commands/FetchProfileCommand.java b/net/minecraft/server/commands/FetchProfileCommand.java
index d6976aa7ea3b3b3299695fba7ac38e19c2a53785..a6159b746a4d22fb7d3bcbc81fd2c378cdfb17cb 100644
--- a/net/minecraft/server/commands/FetchProfileCommand.java
+++ b/net/minecraft/server/commands/FetchProfileCommand.java
@@ -102,7 +102,7 @@ public class FetchProfileCommand {
                 () -> {
                     Component component = Component.literal(name);
                     Optional<GameProfile> optional = profileResolver.fetchByName(name);
-                    server.execute(
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask( // Folia - region threading
                         () -> optional.ifPresentOrElse(
                             gameProfile -> reportResolvedProfile(source, gameProfile, "commands.fetchprofile.name.success", component),
                             () -> source.sendFailure(Component.translatable("commands.fetchprofile.name.failure", component))
@@ -121,7 +121,7 @@ public class FetchProfileCommand {
                 () -> {
                     Component component = Component.translationArg(id);
                     Optional<GameProfile> optional = profileResolver.fetchById(id);
-                    server.execute(
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask( // Folia - region threading
                         () -> optional.ifPresentOrElse(
                             gameProfile -> reportResolvedProfile(source, gameProfile, "commands.fetchprofile.id.success", component),
                             () -> source.sendFailure(Component.translatable("commands.fetchprofile.id.failure", component))
diff --git a/net/minecraft/server/commands/FillBiomeCommand.java b/net/minecraft/server/commands/FillBiomeCommand.java
index 18c94e011f6b7bcea94810f748fc846187374567..31d3dffb3e7060ccd9be8ebb82d1981d3b35f990 100644
--- a/net/minecraft/server/commands/FillBiomeCommand.java
+++ b/net/minecraft/server/commands/FillBiomeCommand.java
@@ -107,6 +107,16 @@ public class FillBiomeCommand {
         return fill(level, from, to, biome, holder -> true, supplier -> {});
     }
 
+    // Folia start - region threading
+    private static void sendMessage(Consumer<Supplier<Component>> src, Supplier<Either<Integer, CommandSyntaxException>> supplier) {
+        Either<Integer, CommandSyntaxException> either = supplier.get();
+        CommandSyntaxException ex = either == null ? null : either.right().orElse(null);
+        if (ex != null) {
+            src.accept(() -> (Component)ex.getRawMessage());
+        }
+    }
+    // Folia end - region threading
+
     public static Either<Integer, CommandSyntaxException> fill(
         ServerLevel level, BlockPos from, BlockPos to, Holder<Biome> biome, Predicate<Holder<Biome>> filter, Consumer<Supplier<Component>> messageOutput
     ) {
@@ -118,6 +128,17 @@ public class FillBiomeCommand {
         if (i > i1) {
             return Either.right(ERROR_VOLUME_TOO_LARGE.create(i1, i));
         } else {
+            // Folia start - region threading
+            int buffer = 0; // no buffer, we do not touch neighbours
+            level.moonrise$loadChunksAsync(
+                (boundingBox.minX() - buffer) >> 4,
+                (boundingBox.maxX() + buffer) >> 4,
+                (boundingBox.minZ() - buffer) >> 4,
+                (boundingBox.maxZ() + buffer) >> 4,
+                net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunks) -> {
+                    sendMessage(messageOutput, () -> {
             List<ChunkAccess> list = new ArrayList<>();
 
             for (int sectionPosMinZ = SectionPos.blockToSectionCoord(boundingBox.minZ());
@@ -158,6 +179,11 @@ public class FillBiomeCommand {
                 )
             );
             return Either.left(mutableInt.intValue());
+            // Folia start - region threading
+                    }); // sendMessage
+                    }); // loadChunksAsync
+            return Either.left(Integer.valueOf(0));
+            // Folia end - region threading
         }
     }
 
diff --git a/net/minecraft/server/commands/FillCommand.java b/net/minecraft/server/commands/FillCommand.java
index 6730f65eb9e190501d46f1404040b3ffd6d0b1b7..643759bbb4e76f743f42e0f0d8ec9abd857a7185 100644
--- a/net/minecraft/server/commands/FillCommand.java
+++ b/net/minecraft/server/commands/FillCommand.java
@@ -172,6 +172,12 @@ public class FillCommand {
             );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int fillBlocks(
         CommandSourceStack source, BoundingBox box, BlockInput block, FillCommand.Mode mode, @Nullable Predicate<BlockInWorld> filter, boolean strict
     ) throws CommandSyntaxException {
@@ -188,6 +194,18 @@ public class FillCommand {
             if (level.isDebug()) {
                 throw ERROR_FAILED.create();
             } else {
+                // Folia start - region threading
+                int buffer = 32;
+                // physics may spill into neighbour chunks, so use a buffer
+                level.moonrise$loadChunksAsync(
+                        (box.minX() - buffer) >> 4,
+                        (box.maxX() + buffer) >> 4,
+                        (box.minZ() - buffer) >> 4,
+                        (box.maxZ() + buffer) >> 4,
+                        net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                        ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                        (chunks) -> {
+                            try { // Folia end - region threading
                 int i2 = 0;
 
                 for (BlockPos blockPos : BlockPos.betweenClosed(box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ())) {
@@ -228,8 +246,12 @@ public class FillCommand {
                 } else {
                     int i3 = i2;
                     source.sendSuccess(() -> Component.translatable("commands.fill.success", i3), true);
-                    return i2;
+                    return; // Folia - region threading
                 }
+                // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }}); return 0; // Folia end - region threading
             }
         }
     }
diff --git a/net/minecraft/server/commands/ForceLoadCommand.java b/net/minecraft/server/commands/ForceLoadCommand.java
index 4dd9300c1fa38f59cae9526eb95926714d8a115a..b443ce679ce144ce9aa9792fcd40a000a39d6242 100644
--- a/net/minecraft/server/commands/ForceLoadCommand.java
+++ b/net/minecraft/server/commands/ForceLoadCommand.java
@@ -97,7 +97,17 @@ public class ForceLoadCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int queryForceLoad(CommandSourceStack source, ColumnPos pos) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+        // Folia end - region threading
         ChunkPos chunkPos = pos.toChunkPos();
         ServerLevel level = source.getLevel();
         ResourceKey<Level> resourceKey = level.dimension();
@@ -109,14 +119,22 @@ public class ForceLoadCommand {
                 ),
                 false
             );
-            return 1;
+            return; // Folia - region threading
         } else {
             throw ERROR_NOT_TICKING.create(chunkPos, resourceKey.identifier());
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int listForceLoad(CommandSourceStack source) {
         ServerLevel level = source.getLevel();
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         ResourceKey<Level> resourceKey = level.dimension();
         LongSet forceLoadedChunks = level.getForceLoadedChunks();
         int size = forceLoadedChunks.size();
@@ -134,20 +152,27 @@ public class ForceLoadCommand {
         } else {
             source.sendFailure(Component.translatable("commands.forceload.added.none", Component.translationArg(resourceKey.identifier())));
         }
+        }); // Folia - region threading
 
-        return size;
+        return 1; // Folia - region threading
     }
 
     private static int removeAll(CommandSourceStack source) {
         ServerLevel level = source.getLevel();
         ResourceKey<Level> resourceKey = level.dimension();
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         LongSet forceLoadedChunks = level.getForceLoadedChunks();
         forceLoadedChunks.forEach(l -> level.setChunkForced(ChunkPos.getX(l), ChunkPos.getZ(l), false));
         source.sendSuccess(() -> Component.translatable("commands.forceload.removed.all", Component.translationArg(resourceKey.identifier())), true);
+        }); // Folia - region threading
         return 0;
     }
 
     private static int changeForceLoad(CommandSourceStack source, ColumnPos from, ColumnPos to, boolean add) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+        // Folia end - region threading
         int min = Math.min(from.x(), to.x());
         int min1 = Math.min(from.z(), to.z());
         int max = Math.max(from.x(), to.x());
@@ -207,11 +232,18 @@ public class ForceLoadCommand {
                         );
                     }
 
-                    return i2x;
+                    return; // Folia - region threading
                 }
             }
         } else {
             throw BlockPosArgument.ERROR_OUT_OF_WORLD.create();
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 }
diff --git a/net/minecraft/server/commands/GameModeCommand.java b/net/minecraft/server/commands/GameModeCommand.java
index 503447fbb54bed493f1d867c75ef3f344fe7b81b..948f2b7ca3762ac44a2724cf48fddb8d9d5fbb5e 100644
--- a/net/minecraft/server/commands/GameModeCommand.java
+++ b/net/minecraft/server/commands/GameModeCommand.java
@@ -56,9 +56,11 @@ public class GameModeCommand {
         int i = 0;
 
         for (ServerPlayer serverPlayer : players) {
-            if (setGameMode(context.getSource(), serverPlayer, gameType)) {
-                i++;
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer nmsEntity) -> { // Folia - region threading
+            if (setGameMode(context.getSource(), nmsEntity, gameType)) { // Folia - region threading
+                //i++; // Folia - region threading
             }
+            }, null, 1L); // Folia - region threading
         }
 
         return i;
diff --git a/net/minecraft/server/commands/GiveCommand.java b/net/minecraft/server/commands/GiveCommand.java
index 0fc63717af24ca37497db8ea5a2395548d9d8491..1281eadb2d0c5b4ce5e3afd51d8205f9a4ef011c 100644
--- a/net/minecraft/server/commands/GiveCommand.java
+++ b/net/minecraft/server/commands/GiveCommand.java
@@ -67,32 +67,34 @@ public class GiveCommand {
                     int min = Math.min(maxStackSize, i1);
                     i1 -= min;
                     ItemStack itemStack1 = item.createItemStack(min, false);
-                    boolean flag = serverPlayer.getInventory().add(itemStack1);
+                    serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer nmsEntity) -> { // Folia - region threading
+                    boolean flag = nmsEntity.getInventory().add(itemStack1); // Folia - region threading
                     if (flag && itemStack1.isEmpty()) {
-                        ItemEntity itemEntity = serverPlayer.drop(itemStack, false, false, false, null); // Paper - do not fire PlayerDropItemEvent for /give command
+                        ItemEntity itemEntity = nmsEntity.drop(itemStack, false, false, false, null); // Paper - do not fire PlayerDropItemEvent for /give command // Folia - region threading
                         if (itemEntity != null) {
                             itemEntity.makeFakeItem();
                         }
 
-                        serverPlayer.level()
+                        nmsEntity.level() // Folia - region threading
                             .playSound(
                                 null,
-                                serverPlayer.getX(),
-                                serverPlayer.getY(),
-                                serverPlayer.getZ(),
+                                nmsEntity.getX(), // Folia - region threading
+                                nmsEntity.getY(), // Folia - region threading
+                                nmsEntity.getZ(), // Folia - region threading
                                 SoundEvents.ITEM_PICKUP,
                                 SoundSource.PLAYERS,
                                 0.2F,
-                                ((serverPlayer.getRandom().nextFloat() - serverPlayer.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F
+                                ((nmsEntity.getRandom().nextFloat() - nmsEntity.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F // Folia - region threading
                             );
-                        serverPlayer.containerMenu.broadcastChanges();
+                        nmsEntity.containerMenu.broadcastChanges(); // Folia - region threading
                     } else {
-                        ItemEntity itemEntity = serverPlayer.drop(itemStack1, false, false, false, null); // Paper - do not fire PlayerDropItemEvent for /give command
+                        ItemEntity itemEntity = nmsEntity.drop(itemStack1, false, false, false, null); // Paper - do not fire PlayerDropItemEvent for /give command // Folia - region threading
                         if (itemEntity != null) {
                             itemEntity.setNoPickUpDelay();
-                            itemEntity.setTarget(serverPlayer.getUUID());
+                            itemEntity.setTarget(nmsEntity.getUUID()); // Folia - region threading
                         }
                     }
+                    }, null, 1L); // Folia - region threading
                 }
             }
 
diff --git a/net/minecraft/server/commands/KillCommand.java b/net/minecraft/server/commands/KillCommand.java
index 8c6ff5b895d566d6d38155e690d1a81f5dbc544c..bcf0c53b474213f2d06745950332288d536a3de9 100644
--- a/net/minecraft/server/commands/KillCommand.java
+++ b/net/minecraft/server/commands/KillCommand.java
@@ -24,7 +24,9 @@ public class KillCommand {
 
     private static int kill(CommandSourceStack source, Collection<? extends Entity> targets) {
         for (Entity entity : targets) {
-            entity.kill(source.getLevel());
+            entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> { // Folia - region threading
+                nmsEntity.kill((net.minecraft.server.level.ServerLevel)nmsEntity.level()); // Folia - region threading
+            }, null, 1L); // Folia - region threading
         }
 
         if (targets.size() == 1) {
diff --git a/net/minecraft/server/commands/PlaceCommand.java b/net/minecraft/server/commands/PlaceCommand.java
index 7edf514dfe807c7cb4ee544eb43a5c156cf58557..c7d374738cb2d702fbb40cc6c419313c2c858686 100644
--- a/net/minecraft/server/commands/PlaceCommand.java
+++ b/net/minecraft/server/commands/PlaceCommand.java
@@ -255,36 +255,79 @@ public class PlaceCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     public static int placeFeature(CommandSourceStack source, Holder.Reference<ConfiguredFeature<?, ?>> feature, BlockPos pos) throws CommandSyntaxException {
         ServerLevel level = source.getLevel();
         ConfiguredFeature<?, ?> configuredFeature = feature.value();
         ChunkPos chunkPos = new ChunkPos(pos);
         checkLoaded(level, new ChunkPos(chunkPos.x - 1, chunkPos.z - 1), new ChunkPos(chunkPos.x + 1, chunkPos.z + 1));
+        // Folia start - region threading
+        level.moonrise$loadChunksAsync(
+                pos, 16, net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunks) -> {
+                    try {
+                        // Folia end - region threading
         if (!configuredFeature.place(level, level.getChunkSource().getGenerator(), level.getRandom(), pos)) {
             throw ERROR_FEATURE_FAILED.create();
         } else {
             String string = feature.key().identifier().toString();
             source.sendSuccess(() -> Component.translatable("commands.place.feature.success", string, pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }
+            }
+        );
+        return 1;
+        // Folia end - region threading
     }
 
     public static int placeJigsaw(CommandSourceStack source, Holder<StructureTemplatePool> templatePool, Identifier target, int maxDepth, BlockPos pos) throws CommandSyntaxException {
         ServerLevel level = source.getLevel();
         ChunkPos chunkPos = new ChunkPos(pos);
         checkLoaded(level, chunkPos, chunkPos);
+        // Folia start - region threading
+        level.moonrise$loadChunksAsync(
+                pos, 16, net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunks) -> {
+                    try {
+                        // Folia end - region threading
         if (!JigsawPlacement.generateJigsaw(level, templatePool, target, maxDepth, pos, false)) {
             throw ERROR_JIGSAW_FAILED.create();
         } else {
             source.sendSuccess(() -> Component.translatable("commands.place.jigsaw.success", pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }
+            }
+        );
+        return 1;
+        // Folia end - region threading
     }
 
     public static int placeStructure(CommandSourceStack source, Holder.Reference<Structure> structure, BlockPos pos) throws CommandSyntaxException {
         ServerLevel level = source.getLevel();
         Structure structure1 = structure.value();
         ChunkGenerator generator = level.getChunkSource().getGenerator();
+        // Folia start - region threading
+        level.moonrise$loadChunksAsync(
+                pos, 16, net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunks) -> {
+                    try {
+                        // Folia end - region threading
         StructureStart structureStart = structure1.generate(
             structure,
             level.dimension(),
@@ -327,14 +370,29 @@ public class PlaceCommand {
                 );
             String string = structure.key().identifier().toString();
             source.sendSuccess(() -> Component.translatable("commands.place.structure.success", string, pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }
+            }
+        );
+        return 1;
+        // Folia end - region threading
     }
 
     public static int placeTemplate(
         CommandSourceStack source, Identifier template, BlockPos pos, Rotation rotation, Mirror mirror, float integrity, int seed, boolean strict
     ) throws CommandSyntaxException {
         ServerLevel level = source.getLevel();
+        // Folia start - region threading
+        level.moonrise$loadChunksAsync(
+                pos, 16, net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunks) -> {
+                    try {
+                        // Folia end - region threading
         StructureTemplateManager structureManager = level.getStructureManager();
 
         Optional<StructureTemplate> optional;
@@ -369,9 +427,17 @@ public class PlaceCommand {
                     () -> Component.translatable("commands.place.template.success", Component.translationArg(template), pos.getX(), pos.getY(), pos.getZ()),
                     true
                 );
-                return 1;
+                return; // Folia - region threading
             }
         }
+        // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }
+            }
+        );
+        return 1;
+        // Folia end - region threading
     }
 
     private static void checkLoaded(ServerLevel level, ChunkPos start, ChunkPos end) throws CommandSyntaxException {
diff --git a/net/minecraft/server/commands/RecipeCommand.java b/net/minecraft/server/commands/RecipeCommand.java
index ce7956b706ecfa036e03c1f6207efac4b84f4afd..2df9ef239c723a7d6a9574ebdd919e0b30d5be67 100644
--- a/net/minecraft/server/commands/RecipeCommand.java
+++ b/net/minecraft/server/commands/RecipeCommand.java
@@ -81,7 +81,12 @@ public class RecipeCommand {
         int i = 0;
 
         for (ServerPlayer serverPlayer : targets) {
-            i += serverPlayer.awardRecipes(recipes);
+            // Folia start - region threading
+            ++i;
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                player.awardRecipes(recipes);
+            }, null, 1L);
+            // Folia end - region threading
         }
 
         if (i == 0) {
@@ -103,7 +108,12 @@ public class RecipeCommand {
         int i = 0;
 
         for (ServerPlayer serverPlayer : targets) {
-            i += serverPlayer.resetRecipes(recipes);
+            // Folia start - region threading
+            ++i;
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                player.resetRecipes(recipes);
+            }, null, 1L);
+            // Folia end - region threading
         }
 
         if (i == 0) {
diff --git a/net/minecraft/server/commands/RideCommand.java b/net/minecraft/server/commands/RideCommand.java
index 552b15ac8a35ced2cb48e48ab972d995f5286518..2ecd61d7b90c2f8f5d81ab6ba6264b535afea455 100644
--- a/net/minecraft/server/commands/RideCommand.java
+++ b/net/minecraft/server/commands/RideCommand.java
@@ -56,7 +56,22 @@ public class RideCommand {
         );
     }
 
-    private static int mount(CommandSourceStack source, Entity target, Entity vehicle) throws CommandSyntaxException {
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
+    private static int mount(CommandSourceStack source, Entity targetOld, Entity vehicleOld) throws CommandSyntaxException {  // Folia - region threading
+        // Folia start - region threading
+        targetOld.getBukkitEntity().taskScheduler.schedule((Entity target) -> {
+            try {
+                Entity vehicle = vehicleOld.getBukkitEntity().getHandleRaw();
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(vehicle)) {
+                    source.sendFailure(Component.literal("Cannot mount entities cross-region"));
+                    return;
+                }
+                // Folia end - region threading
         Entity vehicle1 = target.getVehicle();
         if (vehicle1 != null) {
             throw ERROR_ALREADY_RIDING.create(target.getDisplayName(), vehicle1.getDisplayName());
@@ -70,18 +85,36 @@ public class RideCommand {
             throw ERROR_MOUNT_FAILED.create(target.getDisplayName(), vehicle.getDisplayName());
         } else {
             source.sendSuccess(() -> Component.translatable("commands.ride.mount.success", target.getDisplayName(), vehicle.getDisplayName()), true);
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 
-    private static int dismount(CommandSourceStack source, Entity target) throws CommandSyntaxException {
+    private static int dismount(CommandSourceStack source, Entity targetOld) throws CommandSyntaxException { // Folia - region threading
+        // Folia start - region threading
+        targetOld.getBukkitEntity().taskScheduler.schedule((Entity target) -> {
+            try {
+                // Folia end - region threading
         Entity vehicle = target.getVehicle();
         if (vehicle == null) {
             throw ERROR_NOT_RIDING.create(target.getDisplayName());
         } else {
             target.stopRiding();
             source.sendSuccess(() -> Component.translatable("commands.ride.dismount.success", target.getDisplayName(), vehicle.getDisplayName()), true);
-            return 1;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        }, null, 1L);
+        return 0;
+        // Folia end - region threading
     }
 }
diff --git a/net/minecraft/server/commands/RotateCommand.java b/net/minecraft/server/commands/RotateCommand.java
index 3f3d55a7ba65c9e83ba140d585f49317f6b56cb1..b090cf8d4b7d1e60fe37866740b015c25bff1e29 100644
--- a/net/minecraft/server/commands/RotateCommand.java
+++ b/net/minecraft/server/commands/RotateCommand.java
@@ -76,15 +76,23 @@ public class RotateCommand {
 
     private static int rotate(CommandSourceStack source, Entity entity, Coordinates coordinates) {
         Vec2 rotation = coordinates.getRotation(source);
-        float f = coordinates.isYRelative() ? rotation.y - entity.getYRot() : rotation.y;
-        float f1 = coordinates.isXRelative() ? rotation.x - entity.getXRot() : rotation.x;
-        entity.forceSetRotation(f, coordinates.isYRelative(), f1, coordinates.isXRelative());
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            float f = coordinates.isYRelative() ? rotation.y - nmsEntity.getYRot() : rotation.y;
+            float f1 = coordinates.isXRelative() ? rotation.x - nmsEntity.getXRot() : rotation.x;
+            nmsEntity.forceSetRotation(f, coordinates.isYRelative(), f1, coordinates.isXRelative());
+        }, null, 1L);
+        // Folia end - region threading
         source.sendSuccess(() -> Component.translatable("commands.rotate.success", entity.getDisplayName()), true);
         return 1;
     }
 
     private static int rotate(CommandSourceStack source, Entity entity, LookAt lookAt) {
-        lookAt.perform(source, entity);
+        // Folia start - region threading
+        entity.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+            lookAt.perform(source, nmsEntity);
+        }, null, 1L);
+        // Folia end - region threading
         source.sendSuccess(() -> Component.translatable("commands.rotate.success", entity.getDisplayName()), true);
         return 1;
     }
diff --git a/net/minecraft/server/commands/SetBlockCommand.java b/net/minecraft/server/commands/SetBlockCommand.java
index 00f7da02829eb8ecf34627e0ba3eccbb9329f2ce..ae9953c61717da0f0bc791cdaf7797e82e3fc0a1 100644
--- a/net/minecraft/server/commands/SetBlockCommand.java
+++ b/net/minecraft/server/commands/SetBlockCommand.java
@@ -97,10 +97,21 @@ public class SetBlockCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int setBlock(
         CommandSourceStack source, BlockPos pos, BlockInput block, SetBlockCommand.Mode mode, @Nullable Predicate<BlockInWorld> filter, boolean strict
     ) throws CommandSyntaxException {
         ServerLevel level = source.getLevel();
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                level, pos.getX() >> 4, pos.getZ() >> 4, () -> {
+                    try {
+                        // Folia end - region threading
         if (level.isDebug()) {
             throw ERROR_FAILED.create();
         } else if (filter != null && !filter.test(new BlockInWorld(level, pos, true))) {
@@ -124,9 +135,16 @@ public class SetBlockCommand {
                 }
 
                 source.sendSuccess(() -> Component.translatable("commands.setblock.success", pos.getX(), pos.getY(), pos.getZ()), true);
-                return 1;
+                return; // Folia - region threading
             }
         }
+        // Folia start - region threading
+                } catch (CommandSyntaxException ex) {
+                    sendMessage(source, ex);
+                }
+            });
+        return 1;
+        // Folia end - region threading
     }
 
     public static enum Mode {
diff --git a/net/minecraft/server/commands/SetSpawnCommand.java b/net/minecraft/server/commands/SetSpawnCommand.java
index 57dfdff52f2ab7a66a215317d6ed927d3a410881..6a9cb4313c0e42889e36ade57ea02bcc91bd8fee 100644
--- a/net/minecraft/server/commands/SetSpawnCommand.java
+++ b/net/minecraft/server/commands/SetSpawnCommand.java
@@ -77,7 +77,11 @@ public class SetSpawnCommand {
         final Collection<ServerPlayer> actualTargets = new java.util.ArrayList<>(); // Paper - Add PlayerSetSpawnEvent
         for (ServerPlayer serverPlayer : targets) {
             // Paper start - Add PlayerSetSpawnEvent
-            if (serverPlayer.setRespawnPosition(new ServerPlayer.RespawnConfig(LevelData.RespawnData.of(resourceKey, pos, f, f1), true), false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.COMMAND)) {
+            // Folia start - region threading
+            serverPlayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                player.setRespawnPosition(new ServerPlayer.RespawnConfig(LevelData.RespawnData.of(resourceKey, pos, f, f1), true), false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.COMMAND);
+            }, null, 1L);
+            if (true) { // Folia end - region threading
                 actualTargets.add(serverPlayer);
             }
             // Paper end - Add PlayerSetSpawnEvent
diff --git a/net/minecraft/server/commands/SummonCommand.java b/net/minecraft/server/commands/SummonCommand.java
index 88927b0bab343ae46678537e25ad8b3a730ab8be..81baca2f0ec800fead23c6be47596a50aaae38a0 100644
--- a/net/minecraft/server/commands/SummonCommand.java
+++ b/net/minecraft/server/commands/SummonCommand.java
@@ -94,11 +94,17 @@ public class SummonCommand {
             if (entity == null) {
                 throw ERROR_FAILED.create();
             } else {
+                // Folia start - region threading
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                        level, entity.chunkPosition().x, entity.chunkPosition().z, () -> {
+                            // Folia end - region threading
                 if (randomizeProperties && entity instanceof Mob mob) {
                     mob.finalizeSpawn(source.getLevel(), source.getLevel().getCurrentDifficultyAt(entity.blockPosition()), EntitySpawnReason.COMMAND, null);
                 }
+                level.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.COMMAND); // Folia - region threading
+                }); // Folia - region threading
 
-                if (!level.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.COMMAND)) { // CraftBukkit - pass a spawn reason of "COMMAND"
+                if (false) { // CraftBukkit - pass a spawn reason of "COMMAND" // Folia - region threading
                     throw ERROR_DUPLICATE_UUID.create();
                 } else {
                     return entity;
diff --git a/net/minecraft/server/commands/TeleportCommand.java b/net/minecraft/server/commands/TeleportCommand.java
index 9134e090610fa30e99b3f24a831ab01c787143ae..f15a9f15066a40c05a6e5ada16b01dd437deae85 100644
--- a/net/minecraft/server/commands/TeleportCommand.java
+++ b/net/minecraft/server/commands/TeleportCommand.java
@@ -154,18 +154,7 @@ public class TeleportCommand {
 
     private static int teleportToEntity(CommandSourceStack source, Collection<? extends Entity> targets, Entity destination) throws CommandSyntaxException {
         for (Entity entity : targets) {
-            performTeleport(
-                source,
-                entity,
-                (ServerLevel)destination.level(),
-                destination.getX(),
-                destination.getY(),
-                destination.getZ(),
-                EnumSet.noneOf(Relative.class),
-                destination.getYRot(),
-                destination.getXRot(),
-                null
-            );
+            io.papermc.paper.threadedregions.TeleportUtils.teleport(entity, false, destination, Float.valueOf(destination.getYRot()), Float.valueOf(destination.getXRot()), Entity.TELEPORT_FLAG_LOAD_CHUNK, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND, null); // Folia - region threading
         }
 
         if (targets.size() == 1) {
@@ -263,6 +252,24 @@ public class TeleportCommand {
             float f1 = relatives.contains(Relative.X_ROT) ? xRot - target.getXRot() : xRot;
             float f2 = Mth.wrapDegrees(f);
             float f3 = Mth.wrapDegrees(f1);
+            // Folia start - region threading
+            if (true) {
+                ServerLevel worldFinal = level;
+                Vec3 posFinal = new Vec3(x, y, z);
+                Float yawFinal = Float.valueOf(f2);
+                Float pitchFinal = Float.valueOf(f3);
+                target.getBukkitEntity().taskScheduler.schedule((Entity nmsEntity) -> {
+                    nmsEntity.stopRiding();
+                    nmsEntity.teleportAsync(
+                            worldFinal, posFinal, yawFinal, pitchFinal, Vec3.ZERO,
+                            org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND,
+                            Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                            null
+                    );
+                }, null, 1L);
+                return;
+            }
+            // Folia end - region threading
             if (target.teleportTo(level, d, d1, d2, relatives, f2, f3, true, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND)) { // Paper - teleport cause
                 if (lookAt != null) {
                     lookAt.perform(source, target);
diff --git a/net/minecraft/server/commands/TimeCommand.java b/net/minecraft/server/commands/TimeCommand.java
index 2efd7e73985cd55c53cdfb4cd829d72b90b541c7..a2abfdf67bed349f5c1dd67e8ad3926c4c788d57 100644
--- a/net/minecraft/server/commands/TimeCommand.java
+++ b/net/minecraft/server/commands/TimeCommand.java
@@ -56,6 +56,7 @@ public class TimeCommand {
     }
 
     public static int setTime(CommandSourceStack source, int time) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         for (ServerLevel serverLevel : io.papermc.paper.configuration.GlobalConfiguration.get().commands.timeCommandAffectsAllWorlds ? source.getServer().getAllLevels() : java.util.List.of(source.getLevel())) { // CraftBukkit - SPIGOT-6496: Only set the time for the world the command originates in // Paper - add config option for spigot's change
             // serverLevel.setDayTime(time);
             // CraftBukkit start
@@ -69,10 +70,12 @@ public class TimeCommand {
 
         source.getServer().forceTimeSynchronization();
         source.sendSuccess(() -> Component.translatable("commands.time.set", time), true);
-        return getDayTime(source.getLevel());
+        }); // Folia - region threading
+        return 0; // Folia - region threading
     }
 
     public static int addTime(CommandSourceStack source, int amount) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         for (ServerLevel serverLevel : io.papermc.paper.configuration.GlobalConfiguration.get().commands.timeCommandAffectsAllWorlds ? source.getServer().getAllLevels() : java.util.List.of(source.getLevel())) { // CraftBukkit - SPIGOT-6496: Only set the time for the world the command originates in // Paper - add config option for spigot's change
             // CraftBukkit start
             org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(serverLevel.getWorld(), org.bukkit.event.world.TimeSkipEvent.SkipReason.COMMAND, amount);
@@ -86,6 +89,7 @@ public class TimeCommand {
         source.getServer().forceTimeSynchronization();
         int dayTime = getDayTime(source.getLevel());
         source.sendSuccess(() -> Component.translatable("commands.time.set", dayTime), true);
-        return dayTime;
+        }); // Folia - region threading
+        return 0; // Folia - region threading
     }
 }
diff --git a/net/minecraft/server/commands/WeatherCommand.java b/net/minecraft/server/commands/WeatherCommand.java
index 23436e22199ae66fe702f50f843288223c9b1b56..0b32db7215a4bb869f39a4631a95ad8b31aa347f 100644
--- a/net/minecraft/server/commands/WeatherCommand.java
+++ b/net/minecraft/server/commands/WeatherCommand.java
@@ -48,20 +48,26 @@ public class WeatherCommand {
     }
 
     private static int setClear(CommandSourceStack source, int time) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         source.getLevel().setWeatherParameters(getDuration(source, time, ServerLevel.RAIN_DELAY), 0, false, false); // CraftBukkit - SPIGOT-7680: per-world
         source.sendSuccess(() -> Component.translatable("commands.weather.set.clear"), true);
+        }); // Folia - region threading
         return time;
     }
 
     private static int setRain(CommandSourceStack source, int time) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         source.getLevel().setWeatherParameters(0, getDuration(source, time, ServerLevel.RAIN_DURATION), true, false); // CraftBukkit - SPIGOT-7680: per-world
         source.sendSuccess(() -> Component.translatable("commands.weather.set.rain"), true);
+        }); // Folia - region threading
         return time;
     }
 
     private static int setThunder(CommandSourceStack source, int time) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         source.getLevel().setWeatherParameters(0, getDuration(source, time, ServerLevel.THUNDER_DURATION), true, true); // CraftBukkit - SPIGOT-7680: per-world
         source.sendSuccess(() -> Component.translatable("commands.weather.set.thunder"), true);
+        }); // Folia - region threading
         return time;
     }
 }
diff --git a/net/minecraft/server/commands/WorldBorderCommand.java b/net/minecraft/server/commands/WorldBorderCommand.java
index 9616edff080c05ea50009cdf84cbdf17154644a1..1161bfed2037b897f1bbafd02b443181b4c751d2 100644
--- a/net/minecraft/server/commands/WorldBorderCommand.java
+++ b/net/minecraft/server/commands/WorldBorderCommand.java
@@ -135,18 +135,39 @@ public class WorldBorderCommand {
         );
     }
 
+    // Folia start - region threading
+    private static void sendMessage(CommandSourceStack src, CommandSyntaxException ex) {
+        src.sendFailure((Component)ex.getRawMessage());
+    }
+    // Folia end - region threading
+
     private static int setDamageBuffer(CommandSourceStack source, float distance) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         WorldBorder worldBorder = source.getLevel().getWorldBorder();
         if (worldBorder.getSafeZone() == distance) {
             throw ERROR_SAME_DAMAGE_BUFFER.create();
         } else {
             worldBorder.setSafeZone(distance);
             source.sendSuccess(() -> Component.translatable("commands.worldborder.damage.buffer.success", String.format(Locale.ROOT, "%.2f", distance)), true);
-            return (int)distance;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int setDamageAmount(CommandSourceStack source, float damagePerBlock) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         WorldBorder worldBorder = source.getLevel().getWorldBorder();
         if (worldBorder.getDamagePerBlock() == damagePerBlock) {
             throw ERROR_SAME_DAMAGE_AMOUNT.create();
@@ -155,39 +176,79 @@ public class WorldBorderCommand {
             source.sendSuccess(
                 () -> Component.translatable("commands.worldborder.damage.amount.success", String.format(Locale.ROOT, "%.2f", damagePerBlock)), true
             );
-            return (int)damagePerBlock;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int setWarningTime(CommandSourceStack source, int time) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         WorldBorder worldBorder = source.getLevel().getWorldBorder();
         if (worldBorder.getWarningTime() == time) {
             throw ERROR_SAME_WARNING_TIME.create();
         } else {
             worldBorder.setWarningTime(time);
             source.sendSuccess(() -> Component.translatable("commands.worldborder.warning.time.success", formatTicksToSeconds(time)), true);
-            return time;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int setWarningDistance(CommandSourceStack source, int distance) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         WorldBorder worldBorder = source.getLevel().getWorldBorder();
         if (worldBorder.getWarningBlocks() == distance) {
             throw ERROR_SAME_WARNING_DISTANCE.create();
         } else {
             worldBorder.setWarningBlocks(distance);
             source.sendSuccess(() -> Component.translatable("commands.worldborder.warning.distance.success", distance), true);
-            return distance;
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int getSize(CommandSourceStack source) {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            // Folia end - region threading
         double size = source.getLevel().getWorldBorder().getSize();
         source.sendSuccess(() -> Component.translatable("commands.worldborder.get", String.format(Locale.ROOT, "%.0f", size)), false);
-        return Mth.floor(size + 0.5);
+        return; // Folia - region threading
+        // Folia start - region threading
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int setCenter(CommandSourceStack source, Vec2 pos) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         WorldBorder worldBorder = source.getLevel().getWorldBorder();
         if (worldBorder.getCenterX() == pos.x && worldBorder.getCenterZ() == pos.y) {
             throw ERROR_SAME_CENTER.create();
@@ -199,13 +260,24 @@ public class WorldBorderCommand {
                 ),
                 true
             );
-            return 0;
+            return; // Folia - region threading
         } else {
             throw ERROR_TOO_FAR_OUT.create();
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static int setSize(CommandSourceStack source, double newSize, long time) throws CommandSyntaxException {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+            try {
+                // Folia end - region threading
         ServerLevel level = source.getLevel();
         WorldBorder worldBorder = level.getWorldBorder();
         double size = worldBorder.getSize();
@@ -229,8 +301,15 @@ public class WorldBorderCommand {
                 source.sendSuccess(() -> Component.translatable("commands.worldborder.set.immediate", string), true);
             }
 
-            return (int)(newSize - size);
+            return; // Folia - region threading
         }
+        // Folia start - region threading
+            } catch (CommandSyntaxException ex) {
+                sendMessage(source, ex);
+            }
+        });
+        return 1;
+        // Folia end - region threading
     }
 
     private static String formatTicksToSeconds(long time) {
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index eb06d8f012684845146429832e977e6c1ddcd62b..3d8290b952e4341211ef8e669372bf7ea1c4bf62 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -423,8 +423,11 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     }
 
     @Override
-    public void tickServer(BooleanSupplier hasTimeLeft) {
-        super.tickServer(hasTimeLeft);
+    // Folia start - region threading
+    public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
+                           io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
+        super.tickServer(startTime, scheduledEnd, targetBuffer, region);
+        // Folia end - region threading
         if (this.jsonRpcServer != null) {
             this.jsonRpcServer.tick();
         }
@@ -547,7 +550,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     @Override
     public void tickConnection() {
         super.tickConnection();
-        this.handleConsoleInputs();
+        // Folia - region threading
     }
 
     private static final java.util.concurrent.atomic.AtomicInteger ASYNC_DEBUG_CHUNKS_COUNT = new java.util.concurrent.atomic.AtomicInteger(); // Paper - rewrite chunk system
@@ -889,7 +892,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         if (s.isBlank()) return ""; // Paper - Do not process empty rcon commands
 
         rconConsoleSource.prepareForCommand();
-        this.executeBlocking(() -> {
+        final java.util.concurrent.atomic.AtomicReference<String> command = new java.util.concurrent.atomic.AtomicReference<>(s); // Folia start - region threading
+        Runnable sync = () -> { // Folia - region threading
             CommandSourceStack wrapper = rconConsoleSource.createCommandSourceStack();
             org.bukkit.event.server.RemoteServerCommandEvent event = new org.bukkit.event.server.RemoteServerCommandEvent(rconConsoleSource.getBukkitSender(wrapper), s);
             this.server.getPluginManager().callEvent(event);
@@ -897,7 +901,16 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 return;
             }
             this.getCommands().performPrefixedCommand(wrapper, event.getCommand());
-        });
+        }; // Folia start - region threading
+        java.util.concurrent.CompletableFuture
+            .runAsync(sync, io.papermc.paper.threadedregions.RegionizedServer.getInstance()::addTask)
+            .whenComplete((Void r, Throwable t) -> {
+                if (t != null) {
+                    LOGGER.error("Error handling command for rcon: " + s, t);
+                }
+            })
+            .join();
+        // Folia end - region threading
         return rconConsoleSource.getCommandResponse();
         // CraftBukkit end
     }
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index ab8893163ac85971a470e4a4d6fa76bd174e2bae..47e1d65f0c2fb6535413bf66e2b40516ff9f7484 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -138,8 +138,8 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
     private final ChunkStatusUpdateListener chunkStatusListener;
     public final ChunkMap.DistanceManager distanceManager;
     private final String storageName;
-    private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
+    //private final PlayerMap playerMap = new PlayerMap(); // Folia - region threading
+    //public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>(); // Folia - region threading
     private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
     // Paper - rewrite chunk system
     public int serverViewDistance;
@@ -710,7 +710,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
     // Paper start - optimise chunk tick iteration
     private boolean isChunkNearPlayer(final ChunkMap chunkMap, final ChunkPos chunkPos, final LevelChunk levelChunk) {
         final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData = ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemLevelChunk)levelChunk).moonrise$getChunkHolder().holderData;
-        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers = chunkData.nearbyPlayers;
+        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers = this.level.moonrise$getNearbyPlayers().getChunk(chunkPos); // Folia - region threading
         if (nearbyPlayers == null) {
             return false;
         }
@@ -746,7 +746,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
     void collectSpawningChunks(List<LevelChunk> output) {
         // Paper start - optimise chunk tick iteration
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> tickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickServerLevel)this.level).moonrise$getPlayerTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> tickingChunks = this.level.getCurrentWorldData().getEntityTickingChunks(); // Folia - region threading
 
         final LevelChunk[] raw = tickingChunks.getRawDataUnchecked();
         final int size = tickingChunks.size();
@@ -790,7 +790,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
     boolean anyPlayerCloseEnoughTo(BlockPos pos, int radius) {
         Vec3 vec3 = new Vec3(pos);
 
-        for (ServerPlayer serverPlayer : this.playerMap.getAllPlayers()) {
+        for (ServerPlayer serverPlayer : this.level.getLocalPlayers()) { // Folia - region threading
             if (this.playerIsCloseEnoughTo(serverPlayer, vec3, radius)) {
                 return true;
             }
@@ -902,12 +902,12 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
     void updatePlayerStatus(ServerPlayer player, boolean track) {
         boolean flag = this.skipPlayer(player);
-        boolean flag1 = this.playerMap.ignoredOrUnknown(player);
+        //boolean flag1 = this.playerMap.ignoredOrUnknown(player); // Folia - region threading
         if (track) {
-            this.playerMap.addPlayer(player, flag);
+            //this.playerMap.addPlayer(player, flag); // Folia - region threading
             this.updatePlayerPos(player);
             if (!flag) {
-                this.distanceManager.addPlayer(SectionPos.of(player), player);
+                //this.distanceManager.addPlayer(SectionPos.of(player), player); // Folia - region threading
                 ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$addPlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
@@ -915,9 +915,9 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             ca.spottedleaf.moonrise.common.PlatformHooks.get().addPlayerToDistanceMaps(this.level, player); // Paper - rewrite chunk system
         } else {
             SectionPos lastSectionPos = player.getLastSectionPos();
-            this.playerMap.removePlayer(player);
-            if (!flag1) {
-                this.distanceManager.removePlayer(lastSectionPos, player);
+            //this.playerMap.removePlayer(player); // Folia - region threading
+            if (true) { // Folia - region threading
+                //this.distanceManager.removePlayer(lastSectionPos, player); // Folia - region threading
                 ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$removePlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
@@ -935,27 +935,13 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
         SectionPos lastSectionPos = player.getLastSectionPos();
         SectionPos sectionPos = SectionPos.of(player);
-        boolean flag = this.playerMap.ignored(player);
+        //boolean flag = this.playerMap.ignored(player); // Folia - region threading
         boolean flag1 = this.skipPlayer(player);
-        boolean flag2 = lastSectionPos.asLong() != sectionPos.asLong();
-        if (flag2 || flag != flag1) {
+        //boolean flag2 = lastSectionPos.asLong() != sectionPos.asLong(); // Folia - region threading
+        if (true) { // Folia - region threading
             this.updatePlayerPos(player);
-            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$updatePlayer(player, lastSectionPos, sectionPos, flag, flag1); // Paper - chunk tick iteration optimisation
-            if (!flag) {
-                this.distanceManager.removePlayer(lastSectionPos, player);
-            }
-
-            if (!flag1) {
-                this.distanceManager.addPlayer(sectionPos, player);
-            }
-
-            if (!flag && flag1) {
-                this.playerMap.ignorePlayer(player);
-            }
-
-            if (flag && !flag1) {
-                this.playerMap.unIgnorePlayer(player);
-            }
+            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$updatePlayer(player, lastSectionPos, sectionPos, false, flag1); // Paper - chunk tick iteration optimisation // Folia - region threading
+            // Folia - region threading
 
             // Paper - rewrite chunk system
         }
@@ -985,9 +971,9 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
     public void addEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
-        if (!entity.valid || entity.level() != this.level || this.entityMap.containsKey(entity.getId())) {
+        if (!entity.valid || entity.level() != this.level || entity.moonrise$getTrackedEntity() != null) { // Folia - region threading
             LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
+                + ": " + entity  + (entity.moonrise$getTrackedEntity() != null ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable()); // Folia - region threading
             return;
         }
         // Paper end - ignore and warn about illegal addEntity calls instead of crashing server
@@ -998,22 +984,28 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
             if (i != 0) {
                 int updateInterval = type.updateInterval();
-                if (this.entityMap.containsKey(entity.getId())) {
+                if (entity.moonrise$getTrackedEntity() != null) { // Folia - region threading
                     throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
                 } else {
                     ChunkMap.TrackedEntity trackedEntity = new ChunkMap.TrackedEntity(entity, i, updateInterval, type.trackDeltas());
-                    this.entityMap.put(entity.getId(), trackedEntity);
+                    //this.entityMap.put(entity.getId(), trackedEntity); // Folia - region threading
                     // Paper start - optimise entity tracker
                     if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity() != null) {
                         throw new IllegalStateException("Entity is already tracked");
                     }
                     ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$setTrackedEntity(trackedEntity);
                     // Paper end - optimise entity tracker
-                    trackedEntity.updatePlayers(this.level.players());
+                    trackedEntity.updatePlayers(this.level.getLocalPlayers()); // Folia - region threading
                     if (entity instanceof ServerPlayer serverPlayer) {
                         this.updatePlayerStatus(serverPlayer, true);
 
-                        for (ChunkMap.TrackedEntity trackedEntity1 : this.entityMap.values()) {
+                        // Folia start - region threading
+                        for (Entity possible : this.level.getCurrentWorldData().trackerEntities) {
+                            ChunkMap.TrackedEntity trackedEntity1 = possible.moonrise$getTrackedEntity();
+                            if (trackedEntity1 == null) {
+                                continue;
+                            }
+                            // Folia end - region threading
                             if (trackedEntity1.entity != serverPlayer) {
                                 trackedEntity1.updatePlayer(serverPlayer);
                             }
@@ -1029,12 +1021,19 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
         if (entity instanceof ServerPlayer serverPlayer) {
             this.updatePlayerStatus(serverPlayer, false);
 
-            for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
+            // Folia start - region threading
+            for (Entity possible : this.level.getCurrentWorldData().getLocalEntities()) {
+                ChunkMap.TrackedEntity trackedEntity = possible.moonrise$getTrackedEntity();
+                if (trackedEntity == null) {
+                    continue;
+                }
+                // Folia end - region threading
                 trackedEntity.removePlayer(serverPlayer);
             }
+            // Folia end - region threading
         }
 
-        ChunkMap.TrackedEntity trackedEntity1 = this.entityMap.remove(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity1 = entity.moonrise$getTrackedEntity(); // Folia - region threading
         if (trackedEntity1 != null) {
             trackedEntity1.broadcastRemoved();
         }
@@ -1043,9 +1042,11 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
+        final io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
+        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = this.level.moonrise$getNearbyPlayers(); // Folia - region threading
 
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = entityLookup.trackerEntities;
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = worldData.trackerEntities; // Folia - region threading
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
@@ -1053,7 +1054,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkData().nearbyPlayers);
+            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(nearbyPlayers.getChunk(entity.chunkPosition())); // Folia - region threading
             if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$hasPlayers()
                 || ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus().isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
                 tracker.serverEntity.sendChanges();
@@ -1071,67 +1072,37 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
         // Paper end - optimise entity tracker
         // Paper - rewrite chunk system
 
-        List<ServerPlayer> list = Lists.newArrayList();
-        List<ServerPlayer> list1 = this.level.players();
-
-        for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            SectionPos sectionPos = trackedEntity.lastSectionPos;
-            SectionPos sectionPos1 = SectionPos.of(trackedEntity.entity);
-            boolean flag = !Objects.equals(sectionPos, sectionPos1);
-            if (flag) {
-                trackedEntity.updatePlayers(list1);
-                Entity entity = trackedEntity.entity;
-                if (entity instanceof ServerPlayer) {
-                    list.add((ServerPlayer)entity);
-                }
-
-                trackedEntity.lastSectionPos = sectionPos1;
-            }
-
-            if (flag || trackedEntity.entity.needsSync || this.distanceManager.inEntityTickingRange(sectionPos1.chunk().toLong())) {
-                trackedEntity.serverEntity.sendChanges();
-            }
-        }
-
-        if (!list.isEmpty()) {
-            for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-                trackedEntity.updatePlayers(list);
-            }
-        }
+        // Folia - region threading
     }
 
     public void sendToTrackingPlayers(Entity entity, Packet<? super ClientGamePacketListener> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Folia - region threading
         if (trackedEntity != null) {
             trackedEntity.sendToTrackingPlayers(packet);
         }
     }
 
     public void sendToTrackingPlayersFiltered(Entity entity, Packet<? super ClientGamePacketListener> packet, Predicate<ServerPlayer> filter) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Folia - region threading
         if (trackedEntity != null) {
             trackedEntity.sendToTrackingPlayersFiltered(packet, filter);
         }
     }
 
     protected void sendToTrackingPlayersAndSelf(Entity entity, Packet<? super ClientGamePacketListener> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Folia - region threading
         if (trackedEntity != null) {
             trackedEntity.sendToTrackingPlayersAndSelf(packet);
         }
     }
 
     public boolean isTrackedByAnyPlayer(Entity entity) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity trackedEntity = entity.moonrise$getTrackedEntity(); // Folia - region threading
         return trackedEntity != null && !trackedEntity.seenBy.isEmpty();
     }
 
     public void forEachEntityTrackedBy(ServerPlayer player, Consumer<Entity> action) {
-        for (ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            if (trackedEntity.seenBy.contains(player.connection)) {
-                action.accept(trackedEntity.entity);
-            }
-        }
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     public void resendBiomesForChunks(List<ChunkAccess> chunks) {
@@ -1377,8 +1348,13 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
                 }
                 flag = flag && this.entity.broadcastToPlayer(player) && ChunkMap.this.isChunkTracked(player, this.entity.chunkPosition().x, this.entity.chunkPosition().z);
                 // Paper end - Configurable entity tracking range by Y
+                // Folia start - region threading
+                if (flag && (this.entity instanceof ServerPlayer thisEntity) && thisEntity.broadcastedDeath) {
+                    flag = false;
+                }
+                // Folia end - region threading
                 // CraftBukkit start - respect vanish API
-                if (flag && !player.getBukkitEntity().canSee(this.entity.getBukkitEntity())) { // Paper - only consider hits
+                if (flag && (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player) || !player.getBukkitEntity().canSee(this.entity.getBukkitEntity()))) { // Paper - only consider hits // Folia - region threading
                     flag = false;
                 }
                 // CraftBukkit end
diff --git a/net/minecraft/server/level/DistanceManager.java b/net/minecraft/server/level/DistanceManager.java
index 8a5c37cf572abc6b9526648d3c8ec92b7af37e3d..1fd1ecc3caa4443dde3d0091af80685c3ae81e38 100644
--- a/net/minecraft/server/level/DistanceManager.java
+++ b/net/minecraft/server/level/DistanceManager.java
@@ -54,18 +54,18 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     }
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration optimisation
-    private final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
+    // Folia - move to regionized world data
     // Note: Cannot do narrow tracking on Paper due to custom spawn range
 
     @Override
     public final void moonrise$addPlayer(final ServerPlayer player, final SectionPos pos) {
-        this.spawnChunkTracker.add(player, pos.x(), pos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE);
+        this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.add(player, pos.x(), pos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE); // Folia - region threading
         // Note: Cannot do narrow tracking on Paper due to custom spawn range
     }
 
     @Override
     public final void moonrise$removePlayer(final ServerPlayer player, final SectionPos pos) {
-        this.spawnChunkTracker.remove(player);
+        this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.remove(player); // Folia - region threading
         // Note: Cannot do narrow tracking on Paper due to custom spawn range
     }
 
@@ -74,10 +74,10 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
                                             final SectionPos oldPos, final SectionPos newPos,
                                             final boolean oldIgnore, final boolean newIgnore) {
         if (newIgnore) {
-            this.spawnChunkTracker.remove(player);
+            this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.remove(player); // Folia - region threading
             // Note: Cannot do narrow tracking on Paper due to custom spawn range
         } else {
-            this.spawnChunkTracker.addOrUpdate(player, newPos.x(), newPos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE);
+            this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.addOrUpdate(player, newPos.x(), newPos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE); // Folia - region threading
             // Note: Cannot do narrow tracking on Paper due to custom spawn range
         }
     }
@@ -159,12 +159,12 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     }
 
     public int getNaturalSpawnChunkCount() {
-        return this.spawnChunkTracker.getTotalPositions(); // Paper - chunk tick iteration optimisation
+        return this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.getTotalPositions(); // Paper - chunk tick iteration optimisation // Folia - region threading
     }
 
     public TriState hasPlayersNearby(long chunkPos) {
         // Note: Cannot do narrow tracking on Paper due to custom spawn range // Paper - chunk tick iteration optimisation
-        return this.spawnChunkTracker.hasObjectsNear(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkPos)) ? net.minecraft.util.TriState.DEFAULT : net.minecraft.util.TriState.FALSE; // Paper - chunk tick iteration optimisation
+        return this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.hasObjectsNear(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkPos)) ? net.minecraft.util.TriState.DEFAULT : net.minecraft.util.TriState.FALSE; // Paper - chunk tick iteration optimisation // Folia - region threading
     }
 
     public void forEachEntityTickingChunk(LongConsumer action) {
@@ -183,7 +183,7 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     }
 
     public LongIterator getSpawnCandidateChunks() {
-        return this.spawnChunkTracker.getPositions().iterator(); // Paper - chunk tick iteration optimisation
+        return this.moonrise$getChunkMap().level.getCurrentWorldData().spawnChunkTracker.getPositions().iterator(); // Paper - chunk tick iteration optimisation // Folia - region threading
     }
 
     public String getDebugStatus() {
diff --git a/net/minecraft/server/level/PlayerSpawnFinder.java b/net/minecraft/server/level/PlayerSpawnFinder.java
index 2c6d0e17fe28751c38cf8186ba869aac2ec6d778..c964030a144eadd5f8e4ecb9bf4a1c097761b57e 100644
--- a/net/minecraft/server/level/PlayerSpawnFinder.java
+++ b/net/minecraft/server/level/PlayerSpawnFinder.java
@@ -26,7 +26,7 @@ import net.minecraft.world.phys.Vec3;
 import org.jspecify.annotations.Nullable;
 
 public class PlayerSpawnFinder {
-    private static final EntityDimensions PLAYER_DIMENSIONS = EntityType.PLAYER.getDimensions();
+    public static final EntityDimensions PLAYER_DIMENSIONS = EntityType.PLAYER.getDimensions(); // Folia - region threading - public
     private static final int ABSOLUTE_MAX_ATTEMPTS = 1024;
     private final ServerLevel level;
     private final BlockPos spawnSuggestion;
@@ -122,8 +122,11 @@ public class PlayerSpawnFinder {
         if (!this.finishedFuture.isDone()) {
             int sectionPosX = SectionPos.blockToSectionCoord(x);
             int sectionPosZ = SectionPos.blockToSectionCoord(z);
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAndLoadWithRadius(TicketType.SPAWN_SEARCH, new ChunkPos(sectionPosX, sectionPosZ), 0, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, ca.spottedleaf.concurrentutil.util.Priority.HIGH) // Paper - rewrite chunk system
-                .whenCompleteAsync((object, throwable) -> {
+
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+                    sectionPosX, sectionPosZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, false,
+                    ca.spottedleaf.concurrentutil.util.Priority.HIGHER, (final net.minecraft.world.level.chunk.ChunkAccess object) -> {
+                    Throwable throwable = null;
                     if (throwable == null) {
                         try {
                             Optional<Vec3> optional = calculator.get();
@@ -146,13 +149,13 @@ public class PlayerSpawnFinder {
                         crashReportCategory.setDetail("Progress", () -> index + " out of " + this.candidateCount);
                         this.finishedFuture.completeExceptionally(new ReportedException(crashReport));
                     }
-                }, this.level.chunkSource.mainThreadProcessor); // Paper - rewrite chunk system
+                }); // Paper - rewrite chunk system // Folia - region threading
         }
     }
 
     protected static @Nullable BlockPos getOverworldRespawnPos(ServerLevel level, int x, int z) {
         boolean hasCeiling = level.dimensionType().hasCeiling();
-        LevelChunk chunk = level.getChunk(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z));
+        net.minecraft.world.level.chunk.ChunkAccess chunk = level.moonrise$getChunkTaskScheduler().syncLoadNonFull(SectionPos.blockToSectionCoord(x), SectionPos.blockToSectionCoord(z), net.minecraft.world.level.chunk.status.ChunkStatus.SPAWN); // Folia - region threading
         int i = hasCeiling ? level.getChunkSource().getGenerator().getSpawnHeight(level) : chunk.getHeight(Heightmap.Types.MOTION_BLOCKING, x & 15, z & 15);
         if (i < level.getMinY()) {
             return null;
@@ -165,12 +168,12 @@ public class PlayerSpawnFinder {
 
                 for (int i1 = i + 1; i1 >= level.getMinY(); i1--) {
                     mutableBlockPos.set(x, i1, z);
-                    BlockState blockState = level.getBlockState(mutableBlockPos);
+                    BlockState blockState = chunk.getBlockState(mutableBlockPos); // Folia - region threading
                     if (!blockState.getFluidState().isEmpty()) {
                         break;
                     }
 
-                    if (Block.isFaceFull(blockState.getCollisionShape(level, mutableBlockPos), Direction.UP)) {
+                    if (Block.isFaceFull(blockState.getCollisionShape(chunk, mutableBlockPos), Direction.UP)) { // Folia - region threading
                         return mutableBlockPos.above().immutable();
                     }
                 }
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index af67b07722bb0125acd081dab767d7e7b360623b..79bc7b4f112f390592694e2d5c358f1c98e6c310 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -65,17 +65,14 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     public final ChunkMap chunkMap;
     private final DimensionDataStorage dataStorage;
     private final TicketStorage ticketStorage;
-    private long lastInhabitedUpdate;
+    //private long lastInhabitedUpdate; // Folia - region threading
     public boolean spawnEnemies = true;
     public boolean spawnFriendlies = true; // Paper - add back spawnFriendlies field
     private static final int CACHE_SIZE = 4;
     private final long[] lastChunkPos = new long[4];
     private final @Nullable ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
     private final @Nullable ChunkAccess[] lastChunk = new ChunkAccess[4];
-    private final List<LevelChunk> spawningChunks = new ObjectArrayList<>();
-    private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet<>();
-    @VisibleForDebug
-    private NaturalSpawner.@Nullable SpawnState lastSpawnState;
+    // Folia - moved to regionised world data
     // Paper start
     public final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<net.minecraft.world.level.chunk.LevelChunk> fullChunks = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
     public int getFullChunksCount() {
@@ -101,6 +98,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private ChunkAccess syncLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus) {
+        // Folia start - region threading
+        if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Cannot asynchronously load chunks");
+        }
+        // Folia end - region threading
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
         final CompletableFuture<ChunkAccess> completable = new CompletableFuture<>();
         chunkTaskScheduler.scheduleChunkLoad(
@@ -162,7 +164,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = world.getCurrentWorldData().getEntityTickingChunks(); // Folia - region threading
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
@@ -350,6 +352,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     public CompletableFuture<ChunkResult<ChunkAccess>> getChunkFuture(int x, int z, ChunkStatus chunkStatus, boolean requireChunk) {
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         boolean flag = Thread.currentThread() == this.mainThread;
         CompletableFuture<ChunkResult<ChunkAccess>> chunkFutureMainThread;
         if (flag) {
@@ -496,9 +499,10 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private void tickChunks() {
-        long gameTime = this.level.getGameTime();
-        long l = gameTime - this.lastInhabitedUpdate;
-        this.lastInhabitedUpdate = gameTime;
+        io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
+        //long gameTime = this.level.getGameTime(); // Folia - region threading
+        long l = 1L; // Folia - region threading
+        //this.lastInhabitedUpdate = gameTime; // Folia - region threading
         if (!this.level.isDebug()) {
             ProfilerFiller profilerFiller = Profiler.get();
             profilerFiller.push("pollingChunks");
@@ -514,27 +518,29 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private void broadcastChangedChunks(ProfilerFiller profiler) {
+        io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
         profiler.push("broadcast");
 
-        for (ChunkHolder chunkHolder : this.chunkHoldersToBroadcast) {
+        for (ChunkHolder chunkHolder : regionizedWorldData.chunkHoldersToBroadcast) { // Folia - region threading - note: do not need to thread check, as getChunkToSend is only non-null when the chunkholder is loaded
             LevelChunk tickingChunk = chunkHolder.getChunkToSend(); // Paper - rewrite chunk system
             if (tickingChunk != null) {
                 chunkHolder.broadcastChanges(tickingChunk);
             }
         }
 
-        this.chunkHoldersToBroadcast.clear();
+        regionizedWorldData.chunkHoldersToBroadcast.clear(); // Folia - region threading
         profiler.pop();
     }
 
     private void tickChunks(ProfilerFiller profiler, long timeInhabited) {
+        io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
         profiler.push("naturalSpawnCount");
         int naturalSpawnChunkCount = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
         NaturalSpawner.SpawnState spawnState;
         if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
             // re-set mob counts
-            for (ServerPlayer player : this.level.players) {
+            for (ServerPlayer player : this.level.getLocalPlayers()) { // Folia - region threading
                 // Paper start - per player mob spawning backoff
                 for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
                     player.mobCounts[ii] = 0;
@@ -547,31 +553,31 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
                 // Paper end - per player mob spawning backoff
             }
-            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true);
+            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, null, true); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
         } else {
-            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+            spawnState = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
         }
         // Paper end - Optional per player mob spawns
-        this.lastSpawnState = spawnState;
-        boolean flag = this.level.getGameRules().get(GameRules.SPAWN_MOBS) && !this.level.players().isEmpty(); // CraftBukkit
+        regionizedWorldData.lastSpawnState = spawnState; // Folia - region threading
+        boolean flag = this.level.getGameRules().get(GameRules.SPAWN_MOBS) && !this.level.getLocalPlayers().isEmpty(); // CraftBukkit // Folia - region threading
         int i = this.level.getGameRules().get(GameRules.RANDOM_TICK_SPEED);
         List<MobCategory> filteredSpawningCategories;
         if (flag && (this.spawnEnemies || this.spawnFriendlies)) { // Paper
             // Paper start - PlayerNaturallySpawnCreaturesEvent
-            for (ServerPlayer entityPlayer : this.level.players()) {
+            for (ServerPlayer entityPlayer : this.level.getLocalPlayers()) { // Folia - region threading
                 int chunkRange = Math.min(level.spigotConfig.mobSpawnRange, entityPlayer.getBukkitEntity().getViewDistance());
                 chunkRange = Math.min(chunkRange, 8);
                 entityPlayer.playerNaturallySpawnedEvent = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityPlayer.getBukkitEntity(), (byte) chunkRange);
                 entityPlayer.playerNaturallySpawnedEvent.callEvent();
             }
             // Paper end - PlayerNaturallySpawnCreaturesEvent
-            boolean flag1 = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
+            boolean flag1 = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getRedstoneGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit // Folia - region threading
             filteredSpawningCategories = NaturalSpawner.getFilteredSpawningCategories(spawnState, this.spawnFriendlies, this.spawnEnemies, flag1, this.level); // CraftBukkit
         } else {
             filteredSpawningCategories = List.of();
         }
 
-        List<LevelChunk> list = this.spawningChunks;
+        List<LevelChunk> list = regionizedWorldData.temporaryChunkTickList; // Folia - region threading
 
         try {
             profiler.popPush("filteringSpawningChunks");
@@ -656,18 +662,23 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         int sectionPosZ = SectionPos.blockToSectionCoord(pos.getZ());
         ChunkHolder visibleChunkIfPresent = this.getVisibleChunkIfPresent(ChunkPos.asLong(sectionPosX, sectionPosZ));
         if (visibleChunkIfPresent != null && visibleChunkIfPresent.blockChanged(pos)) {
-            this.chunkHoldersToBroadcast.add(visibleChunkIfPresent);
+            this.level.getCurrentWorldData().chunkHoldersToBroadcast.add(visibleChunkIfPresent); // Folia - region threading
         }
     }
 
     @Override
     public void onLightUpdate(LightLayer lightLayer, SectionPos pos) {
-        this.mainThreadProcessor.execute(() -> {
+        Runnable run = () -> { // Folia - region threading
             ChunkHolder visibleChunkIfPresent = this.getVisibleChunkIfPresent(pos.chunk().toLong());
             if (visibleChunkIfPresent != null && visibleChunkIfPresent.sectionLightChanged(lightLayer, pos.y())) {
-                this.chunkHoldersToBroadcast.add(visibleChunkIfPresent);
+                ServerChunkCache.this.level.getCurrentWorldData().chunkHoldersToBroadcast.add(visibleChunkIfPresent); // Folia - region threading
             }
-        });
+        }; // Folia - region threading
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(
+                this.level, pos.getX(), pos.getZ(), run
+        );
+        // Folia end - region threading
     }
 
     public boolean hasActiveTickets() {
@@ -772,7 +783,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     @VisibleForDebug
     public NaturalSpawner.@Nullable SpawnState getLastSpawnState() {
-        return this.lastSpawnState;
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
+        return worldData == null ? null : worldData.lastSpawnState; // Folia - region threading
     }
 
     public void deactivateTicketsOnClosing() {
@@ -781,7 +793,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     public void onChunkReadyToSend(ChunkHolder chunkHolder) {
         if (chunkHolder.hasChangesToBroadcast()) {
-            this.chunkHoldersToBroadcast.add(chunkHolder);
+            throw new UnsupportedOperationException(); // Folia - region threading
         }
     }
 
@@ -815,20 +827,76 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             return ServerChunkCache.this.mainThread;
         }
 
+        // Folia start - region threading
+        @Override
+        public <V> CompletableFuture<V> submit(Supplier<V> task) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            return super.submit(task);
+        }
+
+        @Override
+        public CompletableFuture<Void> submit(Runnable task) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            return super.submit(task);
+        }
+
+        @Override
+        public void schedule(Runnable runnable) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            super.schedule(runnable);
+        }
+
+        @Override
+        public void executeBlocking(Runnable runnable) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            super.executeBlocking(runnable);
+        }
+
+        @Override
+        public void execute(Runnable runnable) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            super.execute(runnable);
+        }
+
+        @Override
+        public void executeIfPossible(Runnable runnable) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            super.executeIfPossible(runnable);
+        }
+        // Folia end - region threading
+
         @Override
         protected void doRunTask(Runnable task) {
+            if (true) throw new UnsupportedOperationException(); // Folia - region threading
             Profiler.get().incrementCounter("runTask");
             super.doRunTask(task);
         }
 
         @Override
         public boolean pollTask() {
+            // Folia start - region threading
+            if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
+                throw new IllegalStateException("Polling tasks from non-owned region");
+            }
+            // Folia end - region threading
             // Paper start - rewrite chunk system
             final ServerChunkCache serverChunkCache = ServerChunkCache.this;
             if (serverChunkCache.runDistanceManagerUpdates()) {
                 return true;
             } else {
-                return super.pollTask() | ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)serverChunkCache.level).moonrise$getChunkTaskScheduler().executeMainThreadTask();
+                return io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion().getData().getTaskQueueData().executeChunkTask(); // Folia - region threading
             }
             // Paper end - rewrite chunk system
         }
diff --git a/net/minecraft/server/level/ServerEntityGetter.java b/net/minecraft/server/level/ServerEntityGetter.java
index 878000d1b5ec5d7944fc4da9ff9936fe78d044fc..c5f4273fe2985248894f3c679265601cb5e0ed31 100644
--- a/net/minecraft/server/level/ServerEntityGetter.java
+++ b/net/minecraft/server/level/ServerEntityGetter.java
@@ -15,15 +15,15 @@ public interface ServerEntityGetter extends EntityGetter {
     ServerLevel getLevel();
 
     default @Nullable Player getNearestPlayer(TargetingConditions targetingConditions, LivingEntity source) {
-        return this.getNearestEntity(this.players(), targetingConditions, source, source.getX(), source.getY(), source.getZ());
+        return this.getNearestEntity(this.getLocalPlayers(), targetingConditions, source, source.getX(), source.getY(), source.getZ()); // Folia - region threading
     }
 
     default @Nullable Player getNearestPlayer(TargetingConditions targetingConditions, LivingEntity source, double x, double y, double z) {
-        return this.getNearestEntity(this.players(), targetingConditions, source, x, y, z);
+        return this.getNearestEntity(this.getLocalPlayers(), targetingConditions, source, x, y, z); // Folia - region threading
     }
 
     default @Nullable Player getNearestPlayer(TargetingConditions targetingConditions, double x, double y, double z) {
-        return this.getNearestEntity(this.players(), targetingConditions, null, x, y, z);
+        return this.getNearestEntity(this.getLocalPlayers(), targetingConditions, null, x, y, z); // Folia - region threading
     }
 
     default <T extends LivingEntity> @Nullable T getNearestEntity(
@@ -73,7 +73,7 @@ public interface ServerEntityGetter extends EntityGetter {
     default List<Player> getNearbyPlayers(TargetingConditions targetingConditions, LivingEntity source, AABB area) {
         List<Player> list = new ArrayList<>();
 
-        for (Player player : this.players()) {
+        for (Player player : this.getLocalPlayers()) { // Folia - region threading
             if (area.contains(player.getX(), player.getY(), player.getZ()) && targetingConditions.test(this.getLevel(), source, player)) {
                 list.add(player);
             }
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index ab5efa15a1f56feda7d3e91009a517e98216e734..dd140762829f7311e04263e3ebf29e68192b8b28 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -190,11 +190,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList<>(); // Folia - region threading
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList = new EntityTickList();
+    //final EntityTickList entityTickList = new EntityTickList(); // Folia - region threading
     private final ServerWaypointManager waypointManager;
     private final EnvironmentAttributeSystem environmentAttributes;
     // Paper - rewrite chunk system
@@ -203,21 +203,21 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final SleepStatus sleepStatus;
     private int emptyTime;
     private final PortalForcer portalForcer;
-    private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
-    private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
-    private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
+    //private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded); // Folia - region threading
+    //private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded); // Folia - region threading
+    //private final PathTypeCache pathTypesByPosCache = new PathTypeCache(); // Folia - region threading
+    //final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>(); // Folia - region threading
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
-    private boolean handlingTick;
+    //private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>(); // Folia - region threading
+    //private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64); // Folia - region threading
+    //private boolean handlingTick; // Folia - region threading
     private final List<CustomSpawner> customSpawners;
     private @Nullable EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<EnderDragonPart> dragonParts = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>(); // Folia - region threading
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
-    private final boolean tickTime;
+    public final boolean tickTime; // Folia - region threading
     private final RandomSequences randomSequences;
     final LevelDebugSynchronizers debugSynchronizers = new LevelDebugSynchronizers(this);
 
@@ -225,9 +225,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public final LevelStorageSource.LevelStorageAccess levelStorageAccess;
     public final UUID uuid;
     public final net.minecraft.server.level.progress.LevelLoadListener levelLoadListener;
-    public boolean hasPhysicsEvent = true; // Paper - BlockPhysicsEvent
-    public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
-    private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
+    // Folia - region threading - move to regionised world data
 
     @Override
     public @Nullable LevelChunk getChunkIfLoaded(int x, int z) {
@@ -256,6 +254,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         int minChunkZ = minBlockZ >> 4;
         int maxChunkZ = maxBlockZ >> 4;
 
+        // Folia start - region threading
+        // don't let players move into regions not owned
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, minChunkX, minChunkZ, maxChunkX, maxChunkZ)) {
+            return false;
+        }
+        // Folia end - region threading
+
         ServerChunkCache chunkProvider = this.getChunkSource();
 
         for (int cx = minChunkX; cx <= maxChunkX; ++cx) {
@@ -311,11 +316,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler;
     private long lastMidTickFailure;
     private long tickedBlocksOrFluids;
-    private final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = new ca.spottedleaf.moonrise.common.misc.NearbyPlayers((ServerLevel)(Object)this);
-    private static final LevelChunk[] EMPTY_LEVEL_CHUNKS = new LevelChunk[0];
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> loadedChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> tickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
+    // Folia - region threading - move to regionized data
 
     @Override
     public final LevelChunk moonrise$getFullChunkIfLoaded(final int chunkX, final int chunkZ) {
@@ -373,7 +374,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public final int moonrise$getRegionChunkShift() {
-        return io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift();
+        return this.regioniser.sectionChunkShift; // Folia - region threading
     }
 
     @Override
@@ -486,22 +487,22 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public final ca.spottedleaf.moonrise.common.misc.NearbyPlayers moonrise$getNearbyPlayers() {
-        return this.nearbyPlayers;
+        return this.getCurrentWorldData().getNearbyPlayers(); // Folia - region threading
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getLoadedChunks() {
-        return this.loadedChunks;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getTickingChunks() {
-        return this.tickingChunks;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getEntityTickingChunks() {
-        return this.entityTickingChunks;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
@@ -527,74 +528,31 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
    }
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration
-    private final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_LEVEL_CHUNKS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+    // Folia - region threading
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> moonrise$getPlayerTickingChunks() {
-        return this.playerTickingChunks;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     @Override
     public final void moonrise$markChunkForPlayerTicking(final LevelChunk chunk) {
-        final ChunkPos pos = chunk.getPos();
-        if (!this.playerTickingRequests.containsKey(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos))) {
-            return;
-        }
-
-        this.playerTickingChunks.add(chunk);
+        // Folia - region threading
     }
 
     @Override
     public final void moonrise$removeChunkForPlayerTicking(final LevelChunk chunk) {
-        this.playerTickingChunks.remove(chunk);
+        // Folia - region threading
     }
 
     @Override
     public final void moonrise$addPlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot add ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
-            // already added
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.add((LevelChunk)chunkHolder.getCurrentChunk());
+        // Folia - region threading
     }
 
     @Override
     public final void moonrise$removePlayerTickingRequest(final int chunkX, final int chunkZ) {
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
-
-        final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
-
-        if (val <= 0) {
-            throw new IllegalStateException("Negative counter");
-        }
-
-        if (val != 1) {
-            // still has at least one request
-            return;
-        }
-
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)(ServerLevel)(Object)this).moonrise$getChunkTaskScheduler()
-            .chunkHolderManager.getChunkHolder(chunkKey);
-
-        if (chunkHolder == null || !chunkHolder.isTickingReady()) {
-            return;
-        }
-
-        this.playerTickingChunks.remove((LevelChunk)chunkHolder.getCurrentChunk());
+        // Folia - region threading
     }
     // Paper end - chunk tick iteration
 
@@ -693,7 +651,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.randomSequences = Objects.requireNonNullElseGet(randomSequences, () -> this.getDataStorage().computeIfAbsent(RandomSequences.TYPE));
         this.waypointManager = new ServerWaypointManager();
         this.environmentAttributes = EnvironmentAttributeSystem.builder().addDefaultLayers(this).build();
-        this.updateSkyBrightness();
+        //this.updateSkyBrightness(); // Folia - region threading - delay until first tick
         // Paper start - rewrite chunk system
         this.moonrise$setEntityLookup(new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup((ServerLevel)(Object)this, ((ServerLevel)(Object)this).new EntityCallbacks()));
         this.chunkTaskScheduler = new ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler((ServerLevel)(Object)this);
@@ -709,8 +667,62 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        this.updateTickData(); // Folia - region threading - make sure it is initialised before ticked
+    }
+
+    // Folia start - region threading
+    public final io.papermc.paper.threadedregions.TickRegions tickRegions = new io.papermc.paper.threadedregions.TickRegions();
+    public final io.papermc.paper.threadedregions.ThreadedRegionizer<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData> regioniser;
+    {
+        this.regioniser = new io.papermc.paper.threadedregions.ThreadedRegionizer<>(
+                (int)Math.max(1L, (8L * 16L * 16L) / (1L << (2 * (io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift())))),
+                (1.0 / 6.0),
+                Math.max(1, 8 / (1 << io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift())),
+                1,
+                io.papermc.paper.threadedregions.TickRegions.getRegionChunkShift(),
+                this,
+                this.tickRegions
+        );
+    }
+    public final io.papermc.paper.threadedregions.RegionizedTaskQueue.WorldRegionTaskData taskQueueRegionData = new io.papermc.paper.threadedregions.RegionizedTaskQueue.WorldRegionTaskData(this);
+
+    public static final record PendingTeleport(Entity.EntityTreeNode rootVehicle, Vec3 to) {}
+    private final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<PendingTeleport> pendingTeleports = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
+
+    public void pushPendingTeleport(final PendingTeleport teleport) {
+        synchronized (this.pendingTeleports) {
+            this.pendingTeleports.add(teleport);
+        }
+    }
+
+    public boolean removePendingTeleport(final PendingTeleport teleport) {
+        synchronized (this.pendingTeleports) {
+            return this.pendingTeleports.remove(teleport);
+        }
     }
 
+    public List<PendingTeleport> removeAllRegionTeleports() {
+        final List<PendingTeleport> ret = new ArrayList<>();
+
+        synchronized (this.pendingTeleports) {
+            for (final java.util.Iterator<net.minecraft.server.level.ServerLevel.PendingTeleport> iterator = this.pendingTeleports.iterator(); iterator.hasNext(); ) {
+                final PendingTeleport pendingTeleport = iterator.next();
+                if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, pendingTeleport.to())) {
+                    ret.add(pendingTeleport);
+                    iterator.remove();
+                }
+            }
+        }
+
+        return ret;
+    }
+    // Folia end - region threading
+    // Folia start - region threading
+    public void updateTickData() {
+        this.tickData = new io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData(this, this.serverLevelData.getGameTime(), this.serverLevelData.getDayTime());
+    }
+    // Folia end - region threading
+
     // Paper start
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
@@ -737,6 +749,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         return this.getChunkSource().getGenerator().getBiomeSource().getNoiseBiome(x, y, z, this.getChunkSource().randomState().sampler());
     }
 
+    @Override // Folia - region threading
     public StructureManager structureManager() {
         return this.structureManager;
     }
@@ -746,57 +759,34 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         return this.environmentAttributes;
     }
 
-    public void tick(BooleanSupplier hasTimeLeft) {
+    public void tick(BooleanSupplier hasTimeLeft, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - regionised ticking
+        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
         ProfilerFiller profilerFiller = Profiler.get();
-        this.handlingTick = true;
+        regionizedWorldData.setHandlingTick(true); // Folia - regionised ticking
         TickRateManager tickRateManager = this.tickRateManager();
         boolean runsNormally = tickRateManager.runsNormally();
         if (runsNormally) {
             profilerFiller.push("world border");
-            this.getWorldBorder().tick();
+            //this.getWorldBorder().tick(); // Folia - regionised ticking
             profilerFiller.popPush("weather");
-            this.advanceWeatherCycle();
+            //this.advanceWeatherCycle(); // Folia - regionised ticking
             profilerFiller.pop();
         }
 
-        int i = this.getGameRules().get(GameRules.PLAYERS_SLEEPING_PERCENTAGE);
-        if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
-            // Paper start - create time skip event - move up calculations
-            final long newDayTime = this.levelData.getDayTime() + 24000L;
-            org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(
-                this.getWorld(),
-                org.bukkit.event.world.TimeSkipEvent.SkipReason.NIGHT_SKIP,
-                (newDayTime - newDayTime % 24000L) - this.getDayTime()
-            );
-            // Paper end - create time skip event - move up calculations
-            if (this.getGameRules().get(GameRules.ADVANCE_TIME)) {
-                // Paper start - call time skip event if gamerule is enabled
-                // long l = this.levelData.getDayTime() + 24000L; // Paper - diff on change to above - newDayTime
-                // this.setDayTime(l - l % 24000L); // Paper - diff on change to above - event param
-                if (event.callEvent()) {
-                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
-                }
-                // Paper end - call time skip event if gamerule is enabled
-            }
-
-            if (!event.isCancelled()) this.wakeUpAllPlayers(); // Paper - only wake up players if time skip event is not cancelled
-            if (this.getGameRules().get(GameRules.ADVANCE_WEATHER) && this.isRaining()) {
-                this.resetWeatherCycle();
-            }
-        }
+        // Folia - region threading - move into tickSleep - handled by global region
 
-        this.updateSkyBrightness();
+        //this.updateSkyBrightness(); // Folia - region threading
         if (runsNormally) {
             this.tickTime();
         }
 
         profilerFiller.push("tickPending");
         if (!this.isDebug() && runsNormally) {
-            long l = this.getGameTime();
+            long l = regionizedWorldData.getRedstoneGameTime(); // Folia - region threading
             profilerFiller.push("blockTicks");
-            this.blockTicks.tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
+            regionizedWorldData.getBlockLevelTicks().tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks // Folia - region ticking
             profilerFiller.popPush("fluidTicks");
-            this.fluidTicks.tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks
+            regionizedWorldData.getFluidLevelTicks().tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks // Folia - region ticking
             profilerFiller.pop();
         }
 
@@ -812,9 +802,9 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.runBlockEvents();
         }
 
-        this.handlingTick = false;
+        regionizedWorldData.setHandlingTick(false); // Folia - regionised ticking
         profilerFiller.pop();
-        boolean hasActiveTickets = !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || this.chunkSource.hasActiveTickets(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this
+        boolean hasActiveTickets = true || !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || this.chunkSource.hasActiveTickets(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this // Folia - unrestore this, we always need to tick empty worlds
         if (hasActiveTickets) {
             this.resetEmptyTime();
         }
@@ -826,19 +816,29 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (this.emptyTime < 300) {
             profilerFiller.push("entities");
             if (this.dragonFight != null && runsNormally) {
+                if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, this.dragonFight.origin)) { // Folia - region threading
                 profilerFiller.push("dragonFight");
                 this.dragonFight.tick();
                 profilerFiller.pop();
+                } else { // Folia start - region threading
+                    // try to load dragon fight
+                    ChunkPos fightCenter = new ChunkPos(this.dragonFight.origin);
+                    this.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                            TicketType.UNKNOWN, fightCenter, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                            null
+                    );
+                } // Folia end - region threading
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
+            regionizedWorldData // Folia - regionised ticking
+                .forEachTickingEntity( // Folia - regionised ticking
                     entity -> {
                         if (!entity.isRemoved()) {
                             if (!tickRateManager.isEntityFrozen(entity)) {
                                 profilerFiller.push("checkDespawn");
                                 entity.checkDespawn();
+                                if (entity.isRemoved()) return; // Folia - region threading - if we despawned, DON'T TICK IT!
                                 profilerFiller.pop();
                                 if (true) { // Paper - rewrite chunk system
                                     Entity vehicle = entity.getVehicle();
@@ -868,10 +868,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         profilerFiller.pop();
         profilerFiller.push("debugSynchronizers");
         if (this.debugSynchronizers.hasAnySubscriberFor(DebugSubscriptions.NEIGHBOR_UPDATES)) {
-            this.neighborUpdater
+            regionizedWorldData.neighborUpdater // Folia - region threading
                 .setDebugListener(blockPos -> this.debugSynchronizers.broadcastEventToTracking(blockPos, DebugSubscriptions.NEIGHBOR_UPDATES, blockPos));
         } else {
-            this.neighborUpdater.setDebugListener(null);
+            regionizedWorldData.neighborUpdater.setDebugListener(null); // Folia - region threading
         }
 
         this.debugSynchronizers.tick(this.server.debugSubscribers());
@@ -879,6 +879,36 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.environmentAttributes().invalidateTickCache();
     }
 
+    // Folia start - region threading
+    public void tickSleep() {
+        int i = this.getGameRules().get(GameRules.PLAYERS_SLEEPING_PERCENTAGE);
+        if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
+            // Paper start - create time skip event - move up calculations
+            final long newDayTime = this.levelData.getDayTime() + 24000L;
+            org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(
+                this.getWorld(),
+                org.bukkit.event.world.TimeSkipEvent.SkipReason.NIGHT_SKIP,
+                (newDayTime - newDayTime % 24000L) - this.getDayTime()
+            );
+            // Paper end - create time skip event - move up calculations
+            if (this.getGameRules().get(GameRules.ADVANCE_TIME)) {
+                // Paper start - call time skip event if gamerule is enabled
+                // long l = this.levelData.getDayTime() + 24000L; // Paper - diff on change to above - newDayTime
+                // this.setDayTime(l - l % 24000L); // Paper - diff on change to above - event param
+                if (event.callEvent()) {
+                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                }
+                // Paper end - call time skip event if gamerule is enabled
+            }
+
+            if (!event.isCancelled()) this.wakeUpAllPlayers(); // Paper - only wake up players if time skip event is not cancelled
+            if (this.getGameRules().get(GameRules.ADVANCE_WEATHER) && this.isRaining()) {
+                this.resetWeatherCycle();
+            }
+        }
+    }
+    // Folia end - region threading
+
     @Override
     public boolean shouldTickBlocksAt(long chunkPos) {
         // Paper start - rewrite chunk system
@@ -889,12 +919,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     protected void tickTime() {
         if (this.tickTime) {
-            long l = this.levelData.getGameTime() + 1L;
-            this.serverLevelData.setGameTime(l);
+            io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - region threading
+            long l = regionizedWorldData.getRedstoneGameTime() + 1L; // Folia - region threading
+            regionizedWorldData.setRedstoneGameTime(l); // Folia - region threading
             Profiler.get().push("scheduledFunctions");
-            this.serverLevelData.getScheduledEvents().tick(this.server, l);
+            //this.serverLevelData.getScheduledEvents().tick(this.server, l); // Folia - region threading - TODO any way to bring this in?
             Profiler.get().pop();
-            if (this.getGameRules().get(GameRules.ADVANCE_TIME)) {
+            if (false && this.getGameRules().get(GameRules.ADVANCE_TIME)) { // Folia - region threading
                 this.setDayTime(this.levelData.getDayTime() + 1L);
             }
         }
@@ -916,16 +947,27 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
-        this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> player.stopSleepInBed(false, false));
+        // Folia start - region threading
+        this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach((ServerPlayer entityplayer) -> {
+                    // Folia start - region threading
+                    entityplayer.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+                        if (player.level() != ServerLevel.this || !player.isSleeping()) {
+                            return;
+                        }
+                        player.stopSleepInBed(false, false);
+                    }, null, 1L);
+                }
+        );
+        // Folia end - region threading
     }
 
     // Paper start - optimise random ticking
-    private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+    private final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource.INSTANCE; // Folia - region threading
 
     private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
         final LevelChunkSection[] sections = chunk.getSections();
         final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom;
+        final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Folia - region threading
         final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
 
         final ChunkPos cpos = chunk.getPos();
@@ -972,7 +1014,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     // Paper end - optimise random ticking
 
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom; // Paper - optimise random ticking
+        final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Folia - region threading
         ChunkPos pos = chunk.getPos();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
@@ -1106,7 +1148,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public boolean isHandlingTick() {
-        return this.handlingTick;
+        return this.getCurrentWorldData().isHandlingTick(); // Folia - regionised ticking
     }
 
     public boolean canSleepThroughNights() {
@@ -1132,6 +1174,14 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public void updateSleepingPlayerList() {
+        // Folia start - region threading
+        if (!io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) {
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+                ServerLevel.this.updateSleepingPlayerList();
+            });
+            return;
+        }
+        // Folia end - region threading
         if (!this.players.isEmpty() && this.sleepStatus.update(this.players)) {
             this.announceSleepStatus();
         }
@@ -1164,7 +1214,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         return DimensionType.MOON_BRIGHTNESS_PER_PHASE[moonPhase.index()];
     }
 
-    private void advanceWeatherCycle() {
+    public void advanceWeatherCycle() { // Folia - region threading - public
         boolean isRaining = this.isRaining();
         if (this.canHaveWeather()) {
             if (this.getGameRules().get(GameRules.ADVANCE_WEATHER)) {
@@ -1250,7 +1300,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel));
         }
         */
-        for (ServerPlayer player : this.players) {
+        ServerPlayer[] players = this.players.toArray(new ServerPlayer[0]); // Folia - region threading
+        for (ServerPlayer player : players) { // Folia - region threading
             if (player.level() == this) {
                 player.tickWeather();
             }
@@ -1258,13 +1309,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
         if (isRaining != this.isRaining()) {
             // Only send weather packets to those affected
-            for (ServerPlayer player : this.players) {
+            for (ServerPlayer player : players) { // Folia - region threading
                 if (player.level() == this) {
                     player.setPlayerWeather((!isRaining ? org.bukkit.WeatherType.DOWNFALL : org.bukkit.WeatherType.CLEAR), false);
                 }
             }
         }
-        for (ServerPlayer player : this.players) {
+        for (ServerPlayer player : players) { // Folia - region threading
             if (player.level() == this) {
                 player.updateWeather(this.oRainLevel, this.rainLevel, this.oThunderLevel, this.thunderLevel);
             }
@@ -1325,13 +1376,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     // Paper start - log detailed entity tick information
     // TODO replace with varhandle
-    static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
+    // Folia - region threading
 
     public static List<Entity> getCurrentlyTickingEntities() {
-        Entity ticking = currentlyTickingEntity.get();
-        List<Entity> ret = java.util.Arrays.asList(ticking == null ? new Entity[0] : new Entity[] { ticking });
-
-        return ret;
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
     // Paper end - log detailed entity tick information
 
@@ -1339,9 +1387,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // Paper start - log detailed entity tick information
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
         try {
-            if (currentlyTickingEntity.get() == null) {
-                currentlyTickingEntity.lazySet(entity);
-            }
+            // Folia - region threading
             // Paper end - log detailed entity tick information
         entity.setOldPosAndRot();
         ProfilerFiller profilerFiller = Profiler.get();
@@ -1352,7 +1398,16 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         final boolean isActive = io.papermc.paper.entity.activation.ActivationRange.checkIfActive(entity); // Paper - EAR 2
         if (isActive) { // Paper - EAR 2
         entity.tick();
-        entity.postTick(); // CraftBukkit
+        // Folia start - region threading
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity)) {
+            // removed from region while ticking
+            return;
+        }
+        if (entity.handlePortal()) {
+            // portalled
+            return;
+        }
+        // Folia end - region threading
         } else {entity.inactiveTick();} // Paper - EAR 2
         profilerFiller.pop();
 
@@ -1361,9 +1416,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
         // Paper start - log detailed entity tick information
         } finally {
-            if (currentlyTickingEntity.get() == entity) {
-                currentlyTickingEntity.lazySet(null);
-            }
+            // Folia - region threading
         }
         // Paper end - log detailed entity tick information
     }
@@ -1371,7 +1424,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private void tickPassenger(Entity ridingEntity, Entity passengerEntity, final boolean isActive) { // Paper - EAR 2
         if (passengerEntity.isRemoved() || passengerEntity.getVehicle() != ridingEntity) {
             passengerEntity.stopRiding();
-        } else if (passengerEntity instanceof Player || this.entityTickList.contains(passengerEntity)) {
+        } else if (passengerEntity instanceof Player || this.getCurrentWorldData().hasEntityTickingEntity(passengerEntity)) { // Folia - region threading
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
@@ -1381,7 +1434,16 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             // Paper start - EAR 2
             if (isActive) {
             passengerEntity.rideTick();
-            passengerEntity.postTick(); // CraftBukkit
+            // Folia start - region threading
+            if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(passengerEntity)) {
+                // removed from region while ticking
+                return;
+            }
+            if (passengerEntity.handlePortal()) {
+                // portalled
+                return;
+            }
+            // Folia end - region threading
             } else {
                 passengerEntity.setDeltaMovement(Vec3.ZERO);
                 passengerEntity.inactiveTick();
@@ -1467,18 +1529,19 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
         // Paper end - add close param
 
-        // CraftBukkit start - moved from MinecraftServer#saveAllChunks
-        ServerLevel serverLevel1 = this;
-
-        this.serverLevelData.setCustomBossEvents(this.server.getCustomBossEvents().save(this.registryAccess()));
-        this.levelStorageAccess.saveDataTag(this.server.registryAccess(), this.serverLevelData, this.server.getPlayerList().getSingleplayerData());
-        // CraftBukkit end
+        // Folia - move into saveLevelData
     }
 
-    private void saveLevelData(boolean join) {
+    public void saveLevelData(boolean join) { // Folia - public
         if (this.dragonFight != null) {
             this.serverLevelData.setEndDragonFightData(this.dragonFight.saveData()); // CraftBukkit
         }
+        // Folia start - moved into saveLevelData
+        ServerLevel serverLevel1 = this;
+
+        this.serverLevelData.setCustomBossEvents(this.server.getCustomBossEvents().save(this.registryAccess()));
+        this.levelStorageAccess.saveDataTag(this.server.registryAccess(), this.serverLevelData, this.server.getPlayerList().getSingleplayerData());
+        // Folia end - moved into saveLevelData
 
         DimensionDataStorage dataStorage = this.getChunkSource().getDataStorage();
         if (join) {
@@ -1534,6 +1597,19 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         return list;
     }
 
+    // Folia start - region threading
+    @Nullable
+    public ServerPlayer getRandomLocalPlayer() {
+        List<ServerPlayer> list = this.getLocalPlayers();
+        list = new java.util.ArrayList<>(list);
+        list.removeIf((ServerPlayer player) -> {
+            return !player.isAlive();
+        });
+
+        return list.isEmpty() ? null : (ServerPlayer) list.get(this.random.nextInt(list.size()));
+    }
+    // Folia end - region threading
+
     public @Nullable ServerPlayer getRandomPlayer() {
         List<ServerPlayer> players = this.getPlayers(LivingEntity::isAlive);
         return players.isEmpty() ? null : players.get(this.random.nextInt(players.size()));
@@ -1614,8 +1690,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         } else {
             if (entity instanceof net.minecraft.world.entity.item.ItemEntity itemEntity && itemEntity.getItem().isEmpty()) return false; // Paper - Prevent empty items from being added
             // Paper start - capture all item additions to the world
-            if (captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) {
-                captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity);
+            if (this.getCurrentWorldData().captureDrops != null && entity instanceof net.minecraft.world.entity.item.ItemEntity) { // Folia - region threading
+                this.getCurrentWorldData().captureDrops.add((net.minecraft.world.entity.item.ItemEntity) entity); // Folia - region threading
                 return true;
             }
             // Paper end - capture all item additions to the world
@@ -1807,13 +1883,14 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - region threading
+        if (false && this.isUpdatingNavigations) { // Folia - region threading
             String string = "recursive call to sendBlockUpdated";
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
 
         this.getChunkSource().blockChanged(pos);
-        this.pathTypesByPosCache.invalidate(pos);
+        regionizedWorldData.pathTypesByPosCache.invalidate(pos); // Folia - region threading
         if (this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
         VoxelShape collisionShape = oldState.getCollisionShape(this, pos);
         VoxelShape collisionShape1 = newState.getCollisionShape(this, pos);
@@ -1821,7 +1898,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             List<PathNavigation> list = new ObjectArrayList<>();
 
             try { // Paper - catch CME see below why
-            for (Mob mob : this.navigatingMobs) {
+            for (java.util.Iterator<Mob> iterator = regionizedWorldData.getNavigatingMobs(); iterator.hasNext();) { // Folia - region threading
+                Mob mob = iterator.next(); // Folia - region threading
                 PathNavigation navigation = mob.getNavigation();
                 if (navigation.shouldRecomputePath(pos)) {
                     list.add(navigation);
@@ -1838,13 +1916,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             // Paper end - catch CME see below why
 
             try {
-                this.isUpdatingNavigations = true;
+                //this.isUpdatingNavigations = true; // Folia - region threading
 
                 for (PathNavigation pathNavigation : list) {
                     pathNavigation.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                //this.isUpdatingNavigations = false; // Folia - region threading
             }
         }
         } // Paper - option to disable pathfinding updates
@@ -1853,33 +1931,33 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block) {
         // CraftBukkit start
-        if (this.populating) {
+        if (this.getCurrentWorldData().populating) { // Folia - region threading
             return;
         }
         // CraftBukkit end
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (this.getCurrentWorldData().captureBlockStates) { return; } // Paper - Cancel all physics during placement // Folia - region threading
         this.updateNeighborsAt(pos, block, ExperimentalRedstoneUtils.initialOrientation(this, null, null));
     }
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation);
+        if (this.getCurrentWorldData().captureBlockStates) { return; } // Paper - Cancel all physics during placement // Folia - region threading
+        this.getCurrentWorldData().neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation); // Folia - region threading
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block block, Direction facing, @Nullable Orientation orientation) {
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, facing, orientation);
+        this.getCurrentWorldData().neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, facing, orientation); // Folia - region threading
     }
 
     @Override
     public void neighborChanged(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        this.neighborUpdater.neighborChanged(pos, block, orientation);
+        this.getCurrentWorldData().neighborUpdater.neighborChanged(pos, block, orientation); // Folia - region threading
     }
 
     @Override
     public void neighborChanged(BlockState state, BlockPos pos, Block block, @Nullable Orientation orientation, boolean movedByPiston) {
-        this.neighborUpdater.neighborChanged(state, pos, block, orientation, movedByPiston);
+        this.getCurrentWorldData().neighborUpdater.neighborChanged(state, pos, block, orientation, movedByPiston); // Folia - region threading
     }
 
     @Override
@@ -1972,7 +2050,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // CraftBukkit end
         ParticleOptions particleOptions = serverExplosion.isSmall() ? smallExplosionParticles : largeExplosionParticles;
 
-        for (ServerPlayer serverPlayer : this.players) {
+        for (ServerPlayer serverPlayer : this.getLocalPlayers()) { // Folia - region thraeding
             if (serverPlayer.distanceToSqr(vec3) < 4096.0) {
                 Optional<Vec3> optional = Optional.ofNullable(serverExplosion.getHitPlayers().get(serverPlayer));
                 serverPlayer.connection.send(new ClientboundExplodePacket(vec3, radius, i, optional, particleOptions, explosionSound, blockParticles));
@@ -1988,14 +2066,17 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public void blockEvent(BlockPos pos, Block block, int eventId, int eventParam) {
-        this.blockEvents.add(new BlockEventData(pos, block, eventId, eventParam));
+        this.getCurrentWorldData().pushBlockEvent(new BlockEventData(pos, block, eventId, eventParam)); // Folia - regionised ticking
     }
 
     private void runBlockEvents() {
-        this.blockEventsToReschedule.clear();
+        List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64); // Folia - regionised ticking
 
-        while (!this.blockEvents.isEmpty()) {
-            BlockEventData blockEventData = this.blockEvents.removeFirst();
+        // Folia start - regionised ticking
+        io.papermc.paper.threadedregions.RegionizedWorldData worldRegionData = this.getCurrentWorldData();
+        BlockEventData blockEventData;
+        while ((blockEventData = worldRegionData.removeFirstBlockEvent()) != null) {
+            // Folia end - regionised ticking
             if (this.shouldTickBlocksAt(blockEventData.pos())) {
                 if (this.doBlockEvent(blockEventData)) {
                     this.server
@@ -2011,11 +2092,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                         );
                 }
             } else {
-                this.blockEventsToReschedule.add(blockEventData);
+                blockEventsToReschedule.add(blockEventData); // Folia - regionised ticking
             }
         }
 
-        this.blockEvents.addAll(this.blockEventsToReschedule);
+        worldRegionData.pushBlockEvents(blockEventsToReschedule); // Folia - regionised ticking
     }
 
     private boolean doBlockEvent(BlockEventData event) {
@@ -2025,12 +2106,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public LevelTicks<Block> getBlockTicks() {
-        return this.blockTicks;
+        return this.getCurrentWorldData().getBlockLevelTicks(); // Folia - region ticking
     }
 
     @Override
     public LevelTicks<Fluid> getFluidTicks() {
-        return this.fluidTicks;
+        return this.getCurrentWorldData().getFluidLevelTicks(); // Folia - region ticking
     }
 
     @Override
@@ -2072,7 +2153,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         double zDist,
         double speed
     ) {
-        return sendParticlesSource(this.players, sender, options, overrideLimiter, alwaysShow, x, y, z, count, xDist, yDist, zDist, speed);
+        return sendParticlesSource(this.getLocalPlayers(), sender, options, overrideLimiter, alwaysShow, x, y, z, count, xDist, yDist, zDist, speed); // Folia - region threading
     }
     public <T extends ParticleOptions> int sendParticlesSource(
         List<ServerPlayer> receivers,
@@ -2172,12 +2253,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     @Deprecated
     public @Nullable Entity getEntityOrPart(int id) {
         Entity entity = this.getEntities().get(id);
-        return entity != null ? entity : this.dragonParts.get(id);
+        return entity != null ? entity : this.dragonParts.get((long)id); // Folia - diff on change
     }
 
     @Override
     public Collection<EnderDragonPart> dragonParts() {
-        return this.dragonParts.values();
+        return this.dragonParts.values(); // Folia - diff on change
     }
 
     public @Nullable BlockPos findNearestMapStructure(TagKey<Structure> structureTag, BlockPos pos, int radius, boolean skipKnownStructures) {
@@ -2236,6 +2317,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // Paper start - Call missing map initialize event and set id
         final DimensionDataStorage storage = this.getServer().overworld().getDataStorage();
 
+        synchronized (storage.cache) { // Folia - region threading
         final Optional<net.minecraft.world.level.saveddata.SavedData> cacheEntry = storage.cache.get(MapItemSavedData.type(mapId));
         if (cacheEntry == null) { // Cache did not contain, try to load and may init
             final MapItemSavedData mapData = storage.get(MapItemSavedData.type(mapId)); // get populates the cache
@@ -2254,6 +2336,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
 
         return null;
+        } // Folia - region threading
         // Paper end - Call missing map initialize event and set id
     }
 
@@ -2299,7 +2382,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public boolean setChunkForced(int chunkX, int chunkZ, boolean add) {
         boolean flag = this.chunkSource.updateChunkForced(new ChunkPos(chunkX, chunkZ), add);
         if (add && flag) {
-            this.getChunk(chunkX, chunkZ);
+            //this.getChunk(chunkX, chunkZ); // Folia - region threading - we must let the chunk load asynchronously
         }
 
         return flag;
@@ -2316,11 +2399,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         Optional<Holder<PoiType>> optional1 = PoiTypes.forState(newState);
         if (!Objects.equals(optional, optional1)) {
             BlockPos blockPos = pos.immutable();
-            optional.ifPresent(holder -> this.getServer().execute(() -> {
+            optional.ifPresent(holder -> io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> { // Folia - region threading
                 this.getPoiManager().remove(blockPos);
                 this.debugSynchronizers.dropPoi(blockPos);
             }));
-            optional1.ifPresent(holder -> this.getServer().execute(() -> {
+            optional1.ifPresent(holder -> io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> { // Folia - region threading
                 // Paper start - Remove stale POIs
                 if (optional.isEmpty() && this.getPoiManager().exists(blockPos, ignored -> true)) {
                     this.getPoiManager().remove(blockPos);
@@ -2359,7 +2442,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public @Nullable Raid getRaidAt(BlockPos pos) {
-        return this.raids.getNearbyRaid(pos, 9216);
+        return this.raids.getNearbyRaid(this, pos, 9216); // Folia - make raids thread-safe - add ServerLevel param
     }
 
     public boolean isRaided(BlockPos pos) {
@@ -2383,7 +2466,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
 
             bufferedWriter.write(String.format(Locale.ROOT, "entities: %s\n", this.moonrise$getEntityLookup().getDebugInfo()));  // Paper - rewrite chunk system
-            bufferedWriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size()));
+            //bufferedWriter.write(String.format(Locale.ROOT, "block_entity_tickers: %d\n", this.blockEntityTickers.size())); // Folia - region threading
             bufferedWriter.write(String.format(Locale.ROOT, "block_ticks: %d\n", this.getBlockTicks().count()));
             bufferedWriter.write(String.format(Locale.ROOT, "fluid_ticks: %d\n", this.getFluidTicks().count()));
             bufferedWriter.write("distance_manager: " + chunkMap.getDistanceManager().getDebugStatus() + "\n");
@@ -2453,7 +2536,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private void dumpBlockEntityTickers(Writer output) throws IOException {
         CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
 
-        for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
+        for (TickingBlockEntity tickingBlockEntity : (Iterable<? extends net.minecraft.world.level.block.entity.TickingBlockEntity>)null) { // Folia - region threading
             BlockPos pos = tickingBlockEntity.getPos();
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
@@ -2461,7 +2544,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @VisibleForTesting
     public void clearBlockEvents(BoundingBox boundingBox) {
-        this.blockEvents.removeIf(blockEventData -> boundingBox.isInside(blockEventData.pos()));
+        this.getCurrentWorldData().removeIfBlockEvents(blockEventData -> boundingBox.isInside(blockEventData.pos())); // Folia - regionised ticking
     }
 
     @Override
@@ -2504,8 +2587,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.players.size(),
             this.moonrise$getEntityLookup().getDebugInfo(), // Paper - rewrite chunk system
             getTypeCount(this.moonrise$getEntityLookup().getAll(), entity -> BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString()), // Paper - rewrite chunk system
-            this.blockEntityTickers.size(),
-            getTypeCount(this.blockEntityTickers, TickingBlockEntity::getType),
+            0, // Folia - region threading
+            "null", // Folia - region threading
             this.getBlockTicks().count(),
             this.getFluidTicks().count(),
             this.gatherChunkSourceStats()
@@ -2557,15 +2640,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public void startTickingChunk(LevelChunk chunk) {
-        chunk.unpackTicks(this.getGameTime());
+        chunk.unpackTicks(this.getRedstoneGameTime()); // Folia - region threading
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
+        this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()); // Folia - region threading
     }
 
     public PathTypeCache getPathTypeCache() {
-        return this.pathTypesByPosCache;
+        return this.getCurrentWorldData().pathTypesByPosCache; // Folia - region threading
     }
 
     public void waitForEntities(ChunkPos chunkPos, int radius) {
@@ -2720,7 +2803,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     // Paper start - optimize redstone (Alternate Current)
     @Override
     public alternate.current.wire.WireHandler getWireHandler() {
-        return wireHandler;
+        return this.getCurrentWorldData().wireHandler; // Folia - region threading
     }
     // Paper end - optimize redstone (Alternate Current)
 
@@ -2755,18 +2838,18 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 ServerLevel.this.getWaypointManager().untrackWaypoint(waypointTransmitter);
             }
 
-            ServerLevel.this.getScoreboard().entityRemoved(entity);
+            //ServerLevel.this.getScoreboard().entityRemoved(entity); // Folia - region threading
         }
 
         @Override
         public void onTickingStart(Entity entity) {
             if (entity instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
-            ServerLevel.this.entityTickList.add(entity);
+            ServerLevel.this.getCurrentWorldData().addEntityTickingEntity(entity); // Folia - region threading
         }
 
         @Override
         public void onTickingEnd(Entity entity) {
-            ServerLevel.this.entityTickList.remove(entity);
+            ServerLevel.this.getCurrentWorldData().removeEntityTickingEntity(entity); // Folia - region threading
             // Paper start - Reset pearls when they stop being ticked
             if (ServerLevel.this.paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && ServerLevel.this.paperConfig().misc.legacyEnderPearlBehavior && entity instanceof net.minecraft.world.entity.projectile.throwableitemprojectile.ThrownEnderpearl pearl) {
                 pearl.setOwner(null);
@@ -2777,6 +2860,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         @Override
         public void onTrackingStart(Entity entity) {
             org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            ServerLevel.this.getCurrentWorldData().addLoadedEntity(entity); // Folia - region threading
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
@@ -2799,12 +2883,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.add(mob);
+                ServerLevel.this.getCurrentWorldData().addNavigatingMob(mob); // Folia - region threading
             }
 
             if (entity instanceof EnderDragon enderDragon) {
                 for (EnderDragonPart enderDragonPart : enderDragon.getSubEntities()) {
-                    ServerLevel.this.dragonParts.put(enderDragonPart.getId(), enderDragonPart);
+                    ServerLevel.this.dragonParts.put((long)enderDragonPart.getId(), enderDragonPart); // Folia - diff on change
                 }
             }
 
@@ -2827,18 +2911,27 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         @Override
         public void onTrackingEnd(Entity entity) {
             org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            ServerLevel.this.getCurrentWorldData().removeLoadedEntity(entity); // Folia - region threading
             // Spigot start // TODO I don't think this is needed anymore
             if (entity instanceof Player player) {
                 for (final ServerLevel level : ServerLevel.this.getServer().getAllLevels()) {
-                    for (final Optional<net.minecraft.world.level.saveddata.SavedData> savedData : level.getDataStorage().cache.values()) {
+                    // Folia start - make map data thread-safe
+                    List<Optional<net.minecraft.world.level.saveddata.SavedData>> worldDataCache;
+                    synchronized (level.getDataStorage().cache) {
+                        worldDataCache = new java.util.ArrayList<>(level.getDataStorage().cache.values());
+                    }
+                    for (final Optional<net.minecraft.world.level.saveddata.SavedData> savedData : worldDataCache) {
+                        // Folia end - make map data thread-safe
                         if (savedData.isEmpty() || !(savedData.get() instanceof MapItemSavedData map)) {
                             continue;
                         }
 
+                        synchronized (map) { // Folia - make map data thread-safe
                         map.carriedByPlayers.remove(player);
                         if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer.player == player)) {
                             map.decorations.remove(player.getName().getString());
                         }
+                        } // Folia - make map data thread-safe
                     }
                 }
             }
@@ -2870,12 +2963,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.remove(mob);
+                ServerLevel.this.getCurrentWorldData().removeNavigatingMob(mob); // Folia - region threading
             }
 
             if (entity instanceof EnderDragon enderDragon) {
                 for (EnderDragonPart enderDragonPart : enderDragon.getSubEntities()) {
-                    ServerLevel.this.dragonParts.remove(enderDragonPart.getId());
+                    ServerLevel.this.dragonParts.remove((long)enderDragonPart.getId()); // Folia - diff on change
                 }
             }
 
@@ -2883,6 +2976,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             ServerLevel.this.debugSynchronizers.dropEntity(entity);
             // CraftBukkit start
             entity.valid = false;
+            // Folia - region threading - TODO THIS SHIT
             if (!(entity instanceof ServerPlayer)) {
                 for (ServerPlayer player : ServerLevel.this.server.getPlayerList().players) { // Paper - call onEntityRemove for all online players
                     player.getBukkitEntity().onEntityRemove(entity);
@@ -2910,11 +3004,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private long lagCompensationTick = MinecraftServer.SERVER_INIT;
 
     public long getLagCompensationTick() {
-        return this.lagCompensationTick;
+        return this.getCurrentWorldData().getLagCompensationTick(); // Folia - region threading
     }
 
     public void updateLagCompensationTick() {
-        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / (java.util.concurrent.TimeUnit.MILLISECONDS.toNanos(50L));
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
     // Paper end - lag compensation
 }
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index c855c48ede60eb744cc65e1b560b9a7a3417d8aa..15c9862f76185a8e852a2bce43f31a581fe82a80 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -203,7 +203,7 @@ import org.slf4j.Logger;
 
 public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer { // Paper - rewrite chunk system
     private static final Logger LOGGER = LogUtils.getLogger();
-    public long lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
+    public static final long LAST_SAVE_ABSENT = Long.MIN_VALUE; public long lastSave = LAST_SAVE_ABSENT; // Paper // Folia - threaded regions - changed to nanoTime
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
     private static final int FLY_STAT_RECORDING_SPEED = 25;
@@ -483,8 +483,152 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         // CraftBukkit end
     }
 
+    // Folia start - region threading
+    private static final int SPAWN_RADIUS_SELECTION_SEARCH = 5;
+
+    private static BlockPos getRandomSpawn(ServerLevel world, net.minecraft.util.RandomSource random) {
+        BlockPos spawn = world.getLevelData().getRespawnData().pos();
+        double radius = Math.max(0.0, world.getGameRules().get(GameRules.RESPAWN_RADIUS).doubleValue());
+
+        double spawnX = (double)spawn.getX() + 0.5;
+        double spawnZ = (double)spawn.getZ() + 0.5;
+
+        net.minecraft.world.level.border.WorldBorder worldBorder = world.getWorldBorder();
+
+        double selectMinX = Math.max(worldBorder.getMinX() + 1.0, spawnX - radius);
+        double selectMinZ = Math.max(worldBorder.getMinZ() + 1.0, spawnZ - radius);
+        double selectMaxX = Math.min(worldBorder.getMaxX() - 1.0, spawnX + radius);
+        double selectMaxZ = Math.min(worldBorder.getMaxZ() - 1.0, spawnZ + radius);
+
+        double amountX = selectMaxX - selectMinX;
+        double amountZ = selectMaxZ - selectMinZ;
+
+        int selectX = amountX < 1.0 ? Mth.floor(worldBorder.getCenterX()) : (int)Mth.floor((amountX + 1.0) * random.nextDouble() + selectMinX);
+        int selectZ = amountZ < 1.0 ? Mth.floor(worldBorder.getCenterZ()) : (int)Mth.floor((amountZ + 1.0) * random.nextDouble() + selectMinZ);
+
+        return new BlockPos(selectX, 0, selectZ);
+    }
+
+    private static void completeSpawn(ServerLevel world, BlockPos selected,
+                                      ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> toComplete) {
+        toComplete.complete(io.papermc.paper.util.MCUtil.toLocation(world, Vec3.atBottomCenterOf(selected), world.getLevelData().getRespawnData().yaw(), world.getLevelData().getRespawnData().pitch()));
+    }
+
+    private static BlockPos findSpawnAround(ServerLevel world, BlockPos selected) {
+        // try hard to find, so that we don't attempt another chunk load
+        for (int dz = -SPAWN_RADIUS_SELECTION_SEARCH; dz <= SPAWN_RADIUS_SELECTION_SEARCH; ++dz) {
+            for (int dx = -SPAWN_RADIUS_SELECTION_SEARCH; dx <= SPAWN_RADIUS_SELECTION_SEARCH; ++dx) {
+                BlockPos inChunk = PlayerSpawnFinder.getOverworldRespawnPos(world, selected.getX() + dx, selected.getZ() + dz);
+                if (inChunk == null) {
+                    continue;
+                }
+
+                AABB checkVolume = PlayerSpawnFinder.PLAYER_DIMENSIONS.makeBoundingBox((double)inChunk.getX() + 0.5, (double)inChunk.getY(), (double)inChunk.getZ() + 0.5);
+
+                if (!world.noCollision(null, checkVolume, true)) {
+                    continue;
+                }
+
+                return inChunk;
+            }
+        }
+
+        return null;
+    }
+
+    // rets false when another attempt is required
+    private static boolean trySpawnOrSchedule(ServerLevel world, net.minecraft.util.RandomSource random, int[] attemptCount, int maxAttempts,
+                                              ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> toComplete) {
+        ++attemptCount[0];
+
+        BlockPos rough = getRandomSpawn(world, random);
+
+        // add 2 to ensure that the chunks are loaded for collision checks
+        int minX = (rough.getX() - (SPAWN_RADIUS_SELECTION_SEARCH + 2)) >> 4;
+        int minZ = (rough.getZ() - (SPAWN_RADIUS_SELECTION_SEARCH + 2)) >> 4;
+        int maxX = (rough.getX() + (SPAWN_RADIUS_SELECTION_SEARCH + 2)) >> 4;
+        int maxZ = (rough.getZ() + (SPAWN_RADIUS_SELECTION_SEARCH + 2)) >> 4;
+
+        // we could short circuit this check, but it would possibly recurse. Then, it could end up causing a stack overflow
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(world, minX, minZ, maxX, maxZ) || !world.moonrise$areChunksLoaded(minX, minZ, maxX, maxZ)) {
+            world.moonrise$loadChunksAsync(minX, maxX, minZ, maxZ, ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
+                    (unused) -> {
+                        BlockPos selected = findSpawnAround(world, rough);
+                        if (selected == null) {
+                            // run more spawn attempts
+                            selectSpawn(world, random, attemptCount, maxAttempts, toComplete);
+                            return;
+                        }
+
+                        completeSpawn(world, selected, toComplete);
+                        return;
+                    }
+            );
+            return true;
+        }
+
+        BlockPos selected = findSpawnAround(world, rough);
+        if (selected == null) {
+            return false;
+        }
+
+        completeSpawn(world, selected, toComplete);
+        return true;
+    }
+
+    private static void selectSpawn(ServerLevel world, net.minecraft.util.RandomSource random, int[] attemptCount, int maxAttempts,
+                                    ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> toComplete) {
+        do {
+            if (attemptCount[0] >= maxAttempts) {
+                BlockPos sharedSpawn = world.getLevelData().getRespawnData().pos();
+
+                LOGGER.warn("Found no spawn in radius, ignoring radius");
+
+                selectSpawnWithoutRadius(world, sharedSpawn, toComplete);
+                return;
+            }
+        } while (!trySpawnOrSchedule(world, random, attemptCount, maxAttempts, toComplete));
+    }
+
+    private static void selectSpawnWithoutRadius(ServerLevel world, BlockPos spawn, ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> toComplete) {
+        world.loadChunksForMoveAsync(PlayerSpawnFinder.PLAYER_DIMENSIONS.makeBoundingBox(spawn.getX() + 0.5, spawn.getY(), spawn.getZ() + 0.5),
+                ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
+                (c) -> {
+                    BlockPos ret = spawn;
+                    while (!world.noCollision(null, PlayerSpawnFinder.PLAYER_DIMENSIONS.makeBoundingBox(ret.getX() + 0.5, ret.getY(), ret.getZ() + 0.5), true) && ret.getY() < (double)world.getMaxY()) {
+                        ret = ret.above();
+                    }
+                    while (world.noCollision(null, PlayerSpawnFinder.PLAYER_DIMENSIONS.makeBoundingBox(ret.getX() + 0.5, ret.getY() - 1, ret.getZ() + 0.5), true) && ret.getY() > (double)(world.getMinY() + 1)) {
+                        ret = ret.below();
+                    }
+                    toComplete.complete(io.papermc.paper.util.MCUtil.toLocation(world, Vec3.atBottomCenterOf(ret), world.getLevelData().getRespawnData().yaw(), world.getLevelData().getRespawnData().pitch()));
+                }
+        );
+    }
+
+    public static void fudgeSpawnLocation(ServerLevel world, ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> toComplete) { // Folia - region threading
+        if (world.dimensionType().hasSkyLight() && world.serverLevelData.getGameType() != GameType.ADVENTURE) { // CraftBukkit
+            selectSpawn(world, world.random, new int[1], 500, toComplete);
+        } else {
+            selectSpawnWithoutRadius(world, world.getLevelData().getRespawnData().pos(), toComplete);
+        }
+
+    }
+
+    public void queuePacketTask(Runnable run) {
+        this.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
+            run.run();
+        }, null, 1L);
+    }
+    // Folia end - region threading
+
     @Override
     public BlockPos adjustSpawnLocation(ServerLevel level, BlockPos pos) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException();
+        }
+        // Folia end - region threading
         CompletableFuture<Vec3> completableFuture = PlayerSpawnFinder.findSpawn(level, pos);
         level.chunkSource.mainThreadProcessor.managedBlock(completableFuture::isDone); // Paper - rewrite chunk system
         return BlockPos.containing(completableFuture.join());
@@ -500,7 +644,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
             .ifPresent(packed -> this.recipeBook.loadUntrusted(packed, key -> this.server.getRecipeManager().byKey(key).isPresent()));
         this.getBukkitEntity().readExtraData(input); // CraftBukkit
         if (this.isSleeping()) {
-            this.stopSleeping();
+            this.stopSleepingRaw(); // Folia - do not modify or read worldstate during data deserialization
         }
 
         this.respawnConfig = input.read("respawn", ServerPlayer.RespawnConfig.CODEC).orElse(null);
@@ -628,9 +772,16 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         if (!optional.isEmpty()) {
             ServerLevel level = this.level().getServer().getLevel(optional.get());
             if (level != null) {
-                Entity entity = EntityType.loadEntityRecursive(input, level, EntitySpawnReason.LOAD, entity1 -> !level.addWithUUID(entity1) ? null : entity1);
+                Entity entity = EntityType.loadEntityRecursive(input, level, EntitySpawnReason.LOAD, net.minecraft.world.entity.EntityProcessor.NOP); // Folia - region threading - delay world add
                 if (entity != null) {
-                    placeEnderPearlTicket(level, entity.chunkPosition());
+                    // Folia start - region threading
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                            level, entity.chunkPosition().x, entity.chunkPosition().z, () -> {
+                                level.addFreshEntityWithPassengers(entity);
+                                ServerPlayer.placeEnderPearlTicket(level, entity.chunkPosition());
+                            }
+                    );
+                    // Folia end - region threading
                 } else {
                     LOGGER.warn("Failed to spawn player ender pearl in level ({}), skipping", optional.get());
                 }
@@ -743,12 +894,23 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
         Entity camera = this.getCamera();
         if (camera != this) {
-            if (camera.isAlive()) {
+            if (camera.canBeSpectated()) { // Folia - region threading - replace removed check
+                if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(camera) && !camera.isRemoved()) { // Folia - region threading
                 this.absSnapTo(camera.getX(), camera.getY(), camera.getZ(), camera.getYRot(), camera.getXRot());
                 this.level().getChunkSource().move(this);
                 if (this.wantsToStopRiding()) {
                     this.setCamera(this);
                 }
+                } else { // Folia start - region threading
+                    Entity realCamera = camera.getBukkitEntity().getHandleRaw();
+                    if (realCamera != camera) {
+                        this.setCamera(this);
+                        this.setCamera(realCamera);
+                    } else {
+                        this.teleportToCameraOffRegion();
+                    }
+                }
+                // Folia end - region threading
             } else {
                 this.setCamera(this);
             }
@@ -1469,8 +1631,322 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         }
     }
 
+    // Folia start - region threading
+    /**
+     * Teleport flag indicating that the player is to be respawned, expected to only be used
+     * internally for {@link #respawn(java.util.function.Consumer, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason)}
+     */
+    public static final long TELEPORT_FLAGS_PLAYER_RESPAWN    = Long.MIN_VALUE >>> 0;
+
+    public void exitEndCredits() {
+        if (!this.wonGame) {
+            // not in the end credits anymore
+            return;
+        }
+        this.wonGame = false;
+
+        this.respawn((player) -> {
+            CriteriaTriggers.CHANGED_DIMENSION.trigger(player, Level.END, Level.OVERWORLD);
+        }, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.END_PORTAL, true);
+    }
+
+    public void respawn(java.util.function.Consumer<ServerPlayer> respawnComplete, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason reason) {
+        this.respawn(respawnComplete, reason, false);
+    }
+
+    private void respawn(java.util.function.Consumer<ServerPlayer> respawnComplete, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason reason, boolean alive) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot respawn entity async");
+
+        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        if (alive != this.isAlive()) {
+            throw new IllegalStateException("isAlive expected = " + alive);
+        }
+
+        if (!this.hasNullCallback()) {
+            this.unRide();
+        }
+
+        if (this.isVehicle() || this.isPassenger()) {
+            throw new IllegalStateException("Dead player should not be a vehicle or passenger");
+        }
+
+        ServerLevel origin = this.level();
+        ServerPlayer.RespawnConfig respawnConfig = this.getRespawnConfig();
+        ServerLevel respawnWorld = this.server.getLevel(ServerPlayer.RespawnConfig.getDimensionOrDefault(respawnConfig));
+
+        // modified based off PlayerList#respawn
+
+        EntityTreeNode passengerTree = this.makePassengerTree();
+
+        this.isChangingDimension = true;
+        origin.removePlayerImmediately(this, RemovalReason.CHANGED_DIMENSION);
+        // reset player if needed, only after removal from world
+        if (!alive) {
+            ServerPlayer.this.reset();
+        }
+        // must be manually removed from connections, delay until after reset() so that we do not trip any thread checks
+        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+
+        ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> spawnPosComplete =
+            new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+        boolean[] usedRespawnAnchor = new boolean[1];
+
+        // set up post spawn location logic
+        spawnPosComplete.addWaiter((spawnLoc, throwable) -> {
+            // update pos and velocity
+            ServerPlayer.this.setPosRaw(spawnLoc.getX(), spawnLoc.getY(), spawnLoc.getZ());
+            ServerPlayer.this.setYRot(spawnLoc.getYaw());
+            ServerPlayer.this.setYHeadRot(spawnLoc.getYaw());
+            ServerPlayer.this.setXRot(spawnLoc.getPitch());
+            ServerPlayer.this.setDeltaMovement(Vec3.ZERO);
+            // placeInAsync will update the world
+
+            this.placeInAsync(
+                origin,
+                // use the load chunk flag just in case the spawn loc isn't loaded, and to ensure the chunks
+                // stay loaded for a bit with the teleport ticket
+                ((org.bukkit.craftbukkit.CraftWorld)spawnLoc.getWorld()).getHandle(),
+                TELEPORT_FLAG_LOAD_CHUNK | TELEPORT_FLAGS_PLAYER_RESPAWN,
+                passengerTree, // note: we expect this to just be the player, no passengers
+                (entity) -> {
+                    // now the player is in the world, and can receive sound
+                    if (usedRespawnAnchor[0]) {
+                        ServerPlayer.this.connection.send(
+                            new net.minecraft.network.protocol.game.ClientboundSoundPacket(
+                                net.minecraft.sounds.SoundEvents.RESPAWN_ANCHOR_DEPLETE, net.minecraft.sounds.SoundSource.BLOCKS,
+                                ServerPlayer.this.getX(), ServerPlayer.this.getY(), ServerPlayer.this.getZ(),
+                                1.0F, 1.0F, ServerPlayer.this.level().getRandom().nextLong()
+                            )
+                        );
+                    }
+                    ServerPlayer.this.connection.restartClientLoadTimerAfterRespawn();
+                    // now the respawn logic is complete
+
+                    // last, call the function callback
+                    if (respawnComplete != null) {
+                        respawnComplete.accept(ServerPlayer.this);
+                    }
+                }
+            );
+        });
+
+        // find and modify respawn block state
+        if (respawnWorld == null || respawnConfig == null) {
+            // default to regular spawn
+            fudgeSpawnLocation(this.server.getLevel(Level.OVERWORLD), spawnPosComplete);
+        } else {
+            // load chunk for block
+            // give at least 1 radius of loaded chunks so that we do not sync load anything
+            int radiusBlocks = 16;
+            respawnWorld.moonrise$loadChunksAsync(respawnConfig.respawnData.pos(), radiusBlocks,
+                ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
+                (chunks) -> {
+                    ServerPlayer.RespawnPosAngle spawnPos = ServerPlayer.findRespawnAndUseSpawnBlock(
+                        respawnWorld, respawnConfig, !alive
+                    ).orElse(null);
+                    if (spawnPos == null) {
+                        // no spawn
+                        ServerPlayer.this.connection.send(
+                            new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F)
+                        );
+                        ServerPlayer.this.setRespawnPosition(
+                            null, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN
+                        );
+                        // default to regular spawn
+                        fudgeSpawnLocation(this.server.getLevel(Level.OVERWORLD), spawnPosComplete);
+                        return;
+                    }
+
+                    boolean isRespawnAnchor = respawnWorld.getBlockState(respawnConfig.respawnData.pos()).is(net.minecraft.world.level.block.Blocks.RESPAWN_ANCHOR);
+                    boolean isBed = respawnWorld.getBlockState(respawnConfig.respawnData.pos()).is(net.minecraft.tags.BlockTags.BEDS);
+                    usedRespawnAnchor[0] = !alive && isRespawnAnchor;
+
+                    // finished now, pass the location on
+                    spawnPosComplete.complete(
+                        io.papermc.paper.util.MCUtil.toLocation(respawnWorld, spawnPos.position(), spawnPos.yaw(), 0.0f)
+                    );
+                    return;
+                }
+            );
+        }
+    }
+
+    @Override
+    protected void teleportSyncSameRegion(Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
+        if (yaw != null) {
+            this.setYRot(yaw.floatValue());
+            this.setYHeadRot(yaw.floatValue());
+        }
+        if (pitch != null) {
+            this.setXRot(pitch.floatValue());
+        }
+        if (velocity != null) {
+            this.setDeltaMovement(velocity);
+        }
+        this.connection.internalTeleport(
+            new net.minecraft.world.entity.PositionMoveRotation(
+                pos, this.getDeltaMovement(), this.getYRot(), this.getXRot()
+            ),
+            java.util.Collections.emptySet()
+        );
+        this.connection.resetPosition();
+        this.setOldPosAndRot();
+        this.resetStoredPositions();
+    }
+
+    @Override
+    protected ServerPlayer transformForAsyncTeleport(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
+        // must be manually removed from connections
+        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+        this.level().removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
+
+        this.spawnIn(destination);
+        this.transform(pos, yaw, pitch, velocity);
+
+        return this;
+    }
+
+    @Override
+    public void preChangeDimension() {
+        super.preChangeDimension();
+        this.stopUsingItem();
+    }
+
+    @Override
+    protected void placeSingleSync(ServerLevel originWorld, ServerLevel destination, EntityTreeNode treeNode, long teleportFlags) {
+        if (destination == originWorld && (teleportFlags & TELEPORT_FLAGS_PLAYER_RESPAWN) == 0L) {
+            this.unsetRemoved();
+            destination.addDuringTeleport(this);
+
+            // must be manually added to connections
+            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+
+            // required to set up the pending teleport stuff to the client, and to actually update
+            // the player's position clientside
+            this.connection.internalTeleport(
+                new net.minecraft.world.entity.PositionMoveRotation(
+                    this.position(), this.getDeltaMovement(), this.getYRot(), this.getXRot()
+                ),
+                java.util.Collections.emptySet()
+            );
+            this.connection.resetPosition();
+
+            this.postChangeDimension();
+        } else {
+            // Modelled after PlayerList#respawn
+
+            // We avoid checking for disconnection here, which means we do not have to add/remove from
+            // the player list here. We can let this be properly handled by the connection handler
+
+            // pre-add logic
+            PlayerList playerlist = this.server.getPlayerList();
+            net.minecraft.world.level.storage.LevelData worlddata = destination.getLevelData();
+            this.connection.send(
+                new ClientboundRespawnPacket(
+                    this.createCommonSpawnInfo(destination),
+                    (teleportFlags & TELEPORT_FLAGS_PLAYER_RESPAWN) == 0L ? (byte)1 : (byte)0
+                )
+            );
+            // don't bother with the chunk cache radius and simulation distance packets, they are handled
+            // by the chunk loader
+            this.spawnIn(destination); // important that destination != null
+            // we can delay teleport until later, the player position is already set up at the target
+            this.setShiftKeyDown(false);
+
+            this.connection.send(new net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket(
+                destination.getRespawnData()
+            ));
+            this.connection.send(new ClientboundChangeDifficultyPacket(
+                worlddata.getDifficulty(), worlddata.isDifficultyLocked()
+            ));
+            this.connection.send(new ClientboundSetExperiencePacket(
+                this.experienceProgress, this.totalExperience, this.experienceLevel
+            ));
+
+            playerlist.sendActivePlayerEffects(this);
+            playerlist.sendLevelInfo(this, destination);
+            playerlist.sendPlayerPermissionLevel(this);
+
+            // regular world add logic
+            this.unsetRemoved();
+            destination.addDuringTeleport(this);
+
+            // must be manually added to connections
+            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+
+            // required to set up the pending teleport stuff to the client, and to actually update
+            // the player's position clientside
+            this.connection.internalTeleport(
+                new net.minecraft.world.entity.PositionMoveRotation(
+                    this.position(), this.getDeltaMovement(), this.getYRot(), this.getXRot()
+                ),
+                java.util.Collections.emptySet()
+            );
+            this.connection.resetPosition();
+            this.stopUsingItem();
+
+            // delay callback until after post add logic
+
+            // post add logic
+
+            // "Added from changeDimension"
+            this.setHealth(this.getHealth());
+            playerlist.sendAllPlayerInfo(this);
+            this.onUpdateAbilities();
+            /*for (MobEffectInstance mobEffect : this.getActiveEffects()) {
+                this.connection.send(new ClientboundUpdateMobEffectPacket(this.getId(), mobEffect, false));
+            }*/ // handled by sendActivePlayerEffects
+
+            this.lastSentExp = -1;
+            this.lastSentHealth = -1.0F;
+            this.lastSentFood = -1;
+
+            this.triggerDimensionChangeTriggers(originWorld);
+
+            // finished
+
+            this.postChangeDimension();
+        }
+    }
+
+    @Override
+    public boolean endPortalLogicAsync(BlockPos portalPos) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+
+        if (this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END) {
+            if (!this.canPortalAsync(null, false)) {
+                return false;
+            }
+            this.wonGame = true;
+            // TODO is there a better solution to this that DOESN'T skip the credits?
+            this.seenCredits = true;
+            if (!this.seenCredits) {
+                this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
+            }
+            this.exitEndCredits();
+            return true;
+        } else {
+            return super.endPortalLogicAsync(portalPos);
+        }
+    }
+
+    @Override
+    protected void prePortalLogic(ServerLevel origin, ServerLevel destination, PortalType type) {
+        super.prePortalLogic(origin, destination, type);
+        if (origin.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.OVERWORLD && destination.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER) {
+            this.enteredNetherPosition = this.position();
+        }
+    }
+    // Folia end - region threading
+
     @Override
     public @Nullable ServerPlayer teleport(TeleportTransition teleportTransition) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        }
+        // Folia end - region threading
         if (this.isSleeping()) return null; // CraftBukkit - SPIGOT-3154
         if (this.isRemoved()) {
             return null;
@@ -2516,7 +2992,30 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         return (Entity)(this.camera == null ? this : this.camera);
     }
 
+    // Folia start - region threading
+    private void teleportToCameraOffRegion() {
+        Entity cameraFinal = this.camera;
+        // use the task scheduler, as we don't know where the caller is invoking from
+        if (this != cameraFinal) {
+            this.getBukkitEntity().taskScheduler.schedule((final ServerPlayer newPlayer) -> {
+                io.papermc.paper.threadedregions.TeleportUtils.teleport(
+                        newPlayer, false, cameraFinal, null, null, 0L,
+                        org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE, null,
+                        (final ServerPlayer newerPlayer) -> {
+                            return newerPlayer.camera == cameraFinal;
+                        }
+                );
+            }, null, 1L);
+        } // else: do not bother teleporting to self
+    }
+    // Folia end - region threading
+
     public void setCamera(@Nullable Entity entityToSpectate) {
+        // Folia start - region threading
+        if (entityToSpectate != null && (entityToSpectate != this && !entityToSpectate.canBeSpectated())) {
+            return;
+        }
+        // Folia end - region threading
         Entity camera = this.getCamera();
         this.camera = (Entity)(entityToSpectate == null ? this : entityToSpectate);
         if (camera != this.camera) {
@@ -2535,16 +3034,19 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 }
             }
             // Paper end - Add PlayerStartSpectatingEntityEvent and PlayerStopSpectatingEntity
-            if (this.camera.level() instanceof ServerLevel serverLevel) {
-                this.teleportTo(serverLevel, this.camera.getX(), this.camera.getY(), this.camera.getZ(), Set.of(), this.getYRot(), this.getXRot(), false, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
-            }
+            // Folia - region threading - move down
 
-            if (entityToSpectate != null) {
-                this.level().getChunkSource().move(this);
-            }
+            // Folia - region threading - not needed
 
+            // Folia start - region threading - handle camera setting better
+            if (this.camera == this
+                || (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.camera) && this.camera.moonrise$getTrackedEntity() != null
+                    && this.camera.moonrise$getTrackedEntity().seenBy.contains(this.connection))) {
+                // Folia end - region threading - handle camera setting better
             this.connection.send(new ClientboundSetCameraPacket(this.camera));
-            this.connection.resetPosition();
+            } // Folia - region threading - handle camera setting better
+            //this.connection.resetPosition(); // Folia - region threading - not needed
+            this.teleportToCameraOffRegion(); // Folia - region threading - moved down
         }
     }
 
@@ -2902,11 +3404,11 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     }
 
     public void registerEnderPearl(ThrownEnderpearl enderPearl) {
-        this.enderPearls.add(enderPearl);
+        //this.enderPearls.add(enderPearl); // Folia - region threading - do not track ender pearls
     }
 
     public void deregisterEnderPearl(ThrownEnderpearl enderPearl) {
-        this.enderPearls.remove(enderPearl);
+        //this.enderPearls.remove(enderPearl); // Folia - region threading - do not track ender pearls
     }
 
     public Set<ThrownEnderpearl> getEnderPearls() {
@@ -3101,7 +3603,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.experienceLevel = this.newLevel;
         this.totalExperience = this.newTotalExp;
         this.experienceProgress = 0;
-        this.deathTime = 0;
+        this.deathTime = 0; this.broadcastedDeath = false; // Folia - region threading
         this.setStingerCount(0);
         this.removeStingerTime = 0;
         this.setArrowCount(0, true); // CraftBukkit - ArrowBodyCountChangeEvent
diff --git a/net/minecraft/server/level/ServerPlayerGameMode.java b/net/minecraft/server/level/ServerPlayerGameMode.java
index 6771cbbae863fa181e19c5fb74d2018d3559ef4e..8d28b29348c255c901375af161210a2041de1985 100644
--- a/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -129,7 +129,7 @@ public class ServerPlayerGameMode {
         // this.gameTicks = net.minecraft.server.MinecraftServer.currentTick; // CraftBukkit
         this.gameTicks = (int) this.level.getLagCompensationTick(); // Paper - lag compensate eating
         if (this.hasDelayedDestroy) {
-            BlockState blockState = this.level.getBlockStateIfLoaded(this.delayedDestroyPos); // Paper - Don't allow digging into unloaded chunks
+            BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level, this.delayedDestroyPos) ? null : this.level.getBlockStateIfLoaded(this.delayedDestroyPos); // Paper - Don't allow digging into unloaded chunks // Folia - region threading - don't destroy blocks not owned
             if (blockState == null || blockState.isAir()) { // Paper - Don't allow digging into unloaded chunks
                 this.hasDelayedDestroy = false;
             } else {
@@ -141,7 +141,7 @@ public class ServerPlayerGameMode {
             }
         } else if (this.isDestroyingBlock) {
             // Paper start - Don't allow digging into unloaded chunks; don't want to do same logic as above, return instead
-            BlockState blockState = this.level.getBlockStateIfLoaded(this.destroyPos);
+            BlockState blockState = !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level, this.destroyPos) ? null : this.level.getBlockStateIfLoaded(this.destroyPos); // Folia - region threading - don't destroy blocks not owned
             if (blockState == null) {
                 this.isDestroyingBlock = false;
                 return;
@@ -383,7 +383,7 @@ public class ServerPlayerGameMode {
             } else {
                 // CraftBukkit start
                 org.bukkit.block.BlockState state = bblock.getState();
-                this.level.captureDrops = new java.util.ArrayList<>();
+                this.level.getCurrentWorldData().captureDrops = new java.util.ArrayList<>(); // Folia - region threading
                 // CraftBukkit end
                 BlockState blockState1 = block.playerWillDestroy(this.level, pos, blockState, this.player);
                 boolean flag = this.level.removeBlock(pos, false);
@@ -413,8 +413,8 @@ public class ServerPlayerGameMode {
                     // return true; // CraftBukkit
                 }
                 // CraftBukkit start
-                java.util.List<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = this.level.captureDrops; // Paper - capture all item additions to the world
-                this.level.captureDrops = null; // Paper - capture all item additions to the world; Remove this earlier so that we can actually drop stuff
+                java.util.List<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = this.level.getCurrentWorldData().captureDrops; // Paper - capture all item additions to the world  // Folia - region threading
+                this.level.getCurrentWorldData().captureDrops = null; // Paper - capture all item additions to the world; Remove this earlier so that we can actually drop stuff  // Folia - region threading
                 if (event.isDropItems()) {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockDropItemEvent(bblock, state, this.player, itemsToDrop); // Paper - capture all item additions to the world
                 }
diff --git a/net/minecraft/server/level/TicketType.java b/net/minecraft/server/level/TicketType.java
index b2914cbe1ba89ef23f3ca41a98d0c8679198ce4c..f94f2b752f2c70a7731c28e8a1af9eec0d3a8410 100644
--- a/net/minecraft/server/level/TicketType.java
+++ b/net/minecraft/server/level/TicketType.java
@@ -68,6 +68,13 @@ public final class TicketType<T> implements ca.spottedleaf.moonrise.patches.chun
     public static final TicketType PLUGIN_TICKET = register("plugin_ticket", NO_TIMEOUT, FLAG_LOADING | FLAG_SIMULATION); static { ((TicketType<org.bukkit.plugin.Plugin>)PLUGIN_TICKET).moonrise$setIdentifierComparator((org.bukkit.plugin.Plugin p1, org.bukkit.plugin.Plugin p2) -> p1.getName().compareTo(p2.getName())); } // Paper // Paper - rewrite chunk system
     public static final TicketType FUTURE_AWAIT = register("future_await", NO_TIMEOUT, FLAG_LOADING | FLAG_SIMULATION); // Paper
     public static final TicketType CHUNK_LOAD = register("chunk_load", NO_TIMEOUT, FLAG_LOADING); // Paper - moonrise
+    // Folia start - region threading
+    public static final TicketType DELAYED = register("folia:delay", 5L, FLAG_LOADING | FLAG_SIMULATION);
+    public static final TicketType<Long> END_GATEWAY_EXIT_SEARCH = ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType.create("folia:end_gateway_exit_search", Long::compareTo);
+    public static final TicketType<Long> NETHER_PORTAL_DOUBLE_CHECK = ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType.create("folia:nether_portal_double_check", Long::compareTo);
+    public static final TicketType<Long> TELEPORT_HOLD_TICKET = ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType.create("folia:teleport_hold_ticket", Long::compareTo);
+    public static final TicketType REGION_SCHEDULER_API_HOLD = register("folia:region_scheduler_api_hold", 0L, FLAG_LOADING | FLAG_SIMULATION);
+    // Folia end - region threading
 
     private static TicketType register(String name, long timeout, @TicketType.Flags int flags) {
         return Registry.register(BuiltInRegistries.TICKET_TYPE, name, new TicketType(timeout, flags));
diff --git a/net/minecraft/server/level/WorldGenRegion.java b/net/minecraft/server/level/WorldGenRegion.java
index bf5e460b89d7c0fcdcb8826ba693bd23761df430..faf1505b0424c609552b5f015df4e9bb2c0c6bf2 100644
--- a/net/minecraft/server/level/WorldGenRegion.java
+++ b/net/minecraft/server/level/WorldGenRegion.java
@@ -107,6 +107,13 @@ public class WorldGenRegion implements WorldGenLevel {
         return this.getLightEngine().getRawBrightness(blockPos, subtract);
     }
     // Paper end - rewrite chunk system
+    // Folia start - region threading
+    private final net.minecraft.world.level.StructureManager structureManager;
+    @Override
+    public net.minecraft.world.level.StructureManager structureManager() {
+        return this.structureManager;
+    }
+    // Folia end - region threading
 
     public WorldGenRegion(ServerLevel level, StaticCache2D<GenerationChunkHolder> cache, ChunkStep generatingStep, ChunkAccess center) {
         this.generatingStep = generatingStep;
@@ -118,6 +125,7 @@ public class WorldGenRegion implements WorldGenLevel {
         this.random = level.getChunkSource().randomState().getOrCreateRandomFactory(WORLDGEN_REGION_RANDOM).at(this.center.getPos().getWorldPosition());
         this.dimensionType = level.dimensionType();
         this.biomeManager = new BiomeManager(this, BiomeManager.obfuscateSeed(this.seed));
+        this.structureManager = level.structureManager().forWorldGenRegion(this); // Folia - region threading
     }
 
     public boolean isOldChunkAround(ChunkPos pos, int radius) {
diff --git a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index b8a4b4cc02a2fc6b70f4b840796eed501aad6239..0bf2173c5445de021090c2d0264afc440b005bdc 100644
--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -86,8 +86,19 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         }
     }
 
+    // Folia start - region threading
+    public boolean handledDisconnect = false;
+    // Folia end - region threading
+
     @Override
     public void onDisconnect(DisconnectionDetails details) {
+        // Folia start - region threading
+        if (this.handledDisconnect) {
+            // avoid retiring scheduler twice
+            return;
+        }
+        this.handledDisconnect = true;
+        // Folia end - region threading
         if (this.isSingleplayerOwner()) {
             LOGGER.info("Stopping singleplayer server as player logged out");
             this.server.halt(false);
@@ -351,24 +362,19 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         if (this.processedDisconnect) {
             return;
         }
-        if (!this.cserver.isPrimaryThread()) {
-            org.bukkit.craftbukkit.util.Waitable waitable = new org.bukkit.craftbukkit.util.Waitable() {
-                @Override
-                protected Object evaluate() {
-                    ServerCommonPacketListenerImpl.this.disconnect(disconnectionDetails);
-                    return null;
-                }
-            };
-
-            this.server.processQueue.add(waitable);
-
-            try {
-                waitable.get();
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-            } catch (java.util.concurrent.ExecutionException e) {
-                throw new RuntimeException(e);
-            }
+        // Folia start - region threading
+        boolean onMain;
+        if (this instanceof ServerGamePacketListenerImpl serverGamePacketListener) {
+            onMain = ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverGamePacketListener.player);
+        } else if (this instanceof ServerConfigurationPacketListenerImpl configurationPacketListener) {
+            net.minecraft.server.level.ServerPlayer player = configurationPacketListener.switchToMain;
+            onMain = player == null ? io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread() : ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player);
+        } else {
+            onMain = io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread();
+        }
+        if (!onMain) {
+            this.connection.disconnectSafely(disconnectionDetails); // it HAS to be delayed/async to avoid deadlock if we try to wait for another region
+            // Folia end - region threading
             return;
         }
 
@@ -422,7 +428,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         this.onDisconnect(disconnectionDetails);
         this.connection.setReadOnly();
         // CraftBukkit - Don't wait
-        this.server.scheduleOnMain(this.connection::handleDisconnection); // Paper
+        //this.server.scheduleOnMain(this.connection::handleDisconnection); // Paper // Folia - region threading
     }
 
     // Paper start - add proper async disconnect
diff --git a/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java b/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
index a3645322be006d5501fa7fb8944509a9c6b58e32..2cc3dd1f267ae78d3aacb84509d4bf668235688f 100644
--- a/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
@@ -53,6 +53,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
     private @Nullable SynchronizeRegistriesTask synchronizeRegistriesTask;
     private @Nullable PrepareSpawnTask prepareSpawnTask;
     public io.papermc.paper.connection.PaperPlayerConfigurationConnection paperConnection; // Paper
+    public net.minecraft.server.level.ServerPlayer switchToMain; // Folia - region threading - rewrite login process
 
     public ServerConfigurationPacketListenerImpl(MinecraftServer server, Connection connection, CommonListenerCookie cookie) {
         super(server, connection, cookie);
@@ -198,13 +199,40 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
                 return;
             }
 
-            Component component = org.bukkit.craftbukkit.event.CraftEventFactory.handleLoginResult(playerList.canPlayerLogin(this.connection.getRemoteAddress(), new NameAndId(this.gameProfile)), this.paperConnection, this.connection, this.gameProfile, this.server, false); // Paper - Login event logic
+            Component component = org.bukkit.craftbukkit.event.CraftEventFactory.handleLoginResult(playerList.canPlayerLogin(this.connection.getRemoteAddress(), new NameAndId(this.gameProfile), this.connection), this.paperConnection, this.connection, this.gameProfile, this.server, false); // Paper - Login event logic // Folia - region threading - add connection parameter
             if (component != null) {
                 this.disconnect(component);
                 return;
             }
 
-            Objects.requireNonNull(this.prepareSpawnTask).spawnPlayer(this.connection, this.createCookie(this.clientInformation));
+            // Folia start - region threading
+            final Connection connection = this.connection;
+            final CommonListenerCookie commonListenerCookie = this.createCookie(this.clientInformation);
+            final net.minecraft.server.level.ServerPlayer serverPlayer = this.prepareSpawnTask.createPlayer(connection, commonListenerCookie);
+
+            this.switchToMain = serverPlayer;
+            // now the connection responsibility is transferred to the region
+            final net.minecraft.server.level.ServerLevel world = this.prepareSpawnTask.getSpawnWorld();
+            final net.minecraft.world.level.ChunkPos chunkPos = new net.minecraft.world.level.ChunkPos(net.minecraft.core.BlockPos.containing(this.prepareSpawnTask.getSpawnPosition()));
+            world.moonrise$getChunkTaskScheduler().scheduleTickingState(
+                    chunkPos.x, chunkPos.z, net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING, true,
+                    ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
+                    (final net.minecraft.world.level.chunk.LevelChunk chunk) -> {
+                        world.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                                net.minecraft.server.level.TicketType.PLAYER_SPAWN, chunkPos,
+                                ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.ENTITY_TICKING_TICKET_LEVEL,
+                                null
+                        );
+                        io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                                world, chunkPos.x, chunkPos.z, () -> {
+                                    net.minecraft.server.network.ServerConfigurationPacketListenerImpl.this.prepareSpawnTask.spawnPlayer(
+                                            this.connection, commonListenerCookie, serverPlayer
+                                    );
+                                }
+                        );
+                    }
+            );
+            // Folia end - region threading - rewrite login process
         } catch (Exception var4) {
             LOGGER.error("Couldn't place player in world", (Throwable)var4);
             this.disconnect(DISCONNECT_REASON_INVALID_DATA);
diff --git a/net/minecraft/server/network/ServerConnectionListener.java b/net/minecraft/server/network/ServerConnectionListener.java
index 33e1cdb00d648c992af03a976899253141314b27..7f86b3538449616a7fa8423e86897364563af957 100644
--- a/net/minecraft/server/network/ServerConnectionListener.java
+++ b/net/minecraft/server/network/ServerConnectionListener.java
@@ -134,12 +134,15 @@ public class ServerConnectionListener {
                                     }
                                     // Paper end - Add support for proxy protocol
                                     // ServerConnectionListener.this.connections.add(connection); // Paper - prevent blocking on adding a new connection while the server is ticking
-                                    ServerConnectionListener.this.pending.add(connection); // Paper - prevent blocking on adding a new connection while the server is ticking
+                                    //ServerConnectionListener.this.pending.add(connection); // Paper - prevent blocking on adding a new connection while the server is ticking // Folia - connection fixes - move down
                                     connection.configurePacketHandler(channelPipeline);
                                     connection.setListenerForServerboundHandshake(
                                         new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, connection)
                                     );
                                     io.papermc.paper.network.ChannelInitializeListenerHolder.callListeners(channel); // Paper - Add Channel initialization listeners
+                                    // Folia start - regionised threading
+                                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().addConnection(connection);
+                                    // Folia end - regionised threading
                                 }
                             }
                         )
@@ -216,7 +219,7 @@ public class ServerConnectionListener {
             // Spigot start
             this.addPending(); // Paper - prevent blocking on adding a new connection while the server is ticking
             // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
-            if (org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0) {
+            if (org.spigotmc.SpigotConfig.playerShuffle > 0 && 0 % org.spigotmc.SpigotConfig.playerShuffle == 0) { // Folia - region threading
                 Collections.shuffle(this.connections);
             }
             // Spigot end
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 478a4a66fd8dc9e102c5f202d0bb00ca81308218..070d1c2652471f531c95821685c133feecce6e29 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -293,10 +293,10 @@ public class ServerGamePacketListenerImpl
     private int knownMovePacketCount;
     private boolean receivedMovementThisTick;
     // CraftBukkit start - add fields
-    private int lastTick = MinecraftServer.currentTick;
+    private long lastTick = Util.getMillis() / 50L; // Folia - region threading
     private int allowedPlayerTicks = 1;
-    private int lastDropTick = MinecraftServer.currentTick;
-    private int lastBookTick  = MinecraftServer.currentTick;
+    private long lastDropTick = Util.getMillis() / 50L; // Folia - region threading
+    private long lastBookTick  = Util.getMillis() / 50L; // Folia - region threading
     private int dropCount = 0;
 
     private boolean hasMoved = false;
@@ -314,13 +314,20 @@ public class ServerGamePacketListenerImpl
     private int nextChatIndex;
     private final MessageSignatureCache messageSignatureCache = MessageSignatureCache.createDefault();
     private final FutureChain chatMessageChain;
-    private boolean waitingForSwitchToConfig;
+    public volatile boolean waitingForSwitchToConfig; // Folia - rewrite login process - fix bad ordering of this field write + public
     private boolean waitingForRespawn;
     private int clientLoadedTimeoutTimer;
     private static final int MAX_SIGN_LINE_LENGTH = Integer.getInteger("Paper.maxSignLength", 80); // Paper - Limit client sign length
     private final io.papermc.paper.event.packet.ClientTickEndEvent tickEndEvent; // Paper - add client tick end event
     public final io.papermc.paper.connection.PaperPlayerGameConnection playerGameConnection; // Paper
 
+    // Folia start - region threading
+    public net.minecraft.world.level.ChunkPos disconnectPos;
+    private static final java.util.concurrent.atomic.AtomicLong DISCONNECT_TICKET_ID_GENERATOR = new java.util.concurrent.atomic.AtomicLong();
+    public static final net.minecraft.server.level.TicketType<Long> DISCONNECT_TICKET = ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType.create("disconnect_ticket", Long::compareTo);
+    public final Long disconnectTicketId = Long.valueOf(DISCONNECT_TICKET_ID_GENERATOR.getAndIncrement());
+    // Folia end - region threading
+
     public ServerGamePacketListenerImpl(MinecraftServer server, Connection connection, ServerPlayer player, CommonListenerCookie cookie) {
         super(server, connection, cookie);
         this.restartClientLoadTimerAfterRespawn();
@@ -348,13 +355,19 @@ public class ServerGamePacketListenerImpl
 
     @Override
     public void tick() {
+        // Folia start - region threading
+        this.keepConnectionAlive();
+        if (this.processedDisconnect || this.player.wonGame) {
+            return;
+        }
+        // Folia end - region threading
         if (this.ackBlockChangesUpTo > -1) {
             this.send(new ClientboundBlockChangedAckPacket(this.ackBlockChangesUpTo));
             this.ackBlockChangesUpTo = -1;
         }
 
         if (this.server.isPaused() || !this.tickPlayer()) {
-            this.keepConnectionAlive();
+            //this.keepConnectionAlive(); // Folia - region threading - moved to beginning of method
             this.chatSpamThrottler.tick();
             this.dropSpamThrottler.tick();
             this.tabSpamThrottler.tick(); // Paper - configurable tab spam limits
@@ -443,6 +456,19 @@ public class ServerGamePacketListenerImpl
         this.lastGoodX = this.player.getX();
         this.lastGoodY = this.player.getY();
         this.lastGoodZ = this.player.getZ();
+        // Folia start - support vehicle teleportations
+        this.lastVehicle = this.player.getRootVehicle();
+        if (this.lastVehicle != this.player && this.lastVehicle.getControllingPassenger() == this.player) {
+            this.vehicleFirstGoodX = this.lastVehicle.getX();
+            this.vehicleFirstGoodY = this.lastVehicle.getY();
+            this.vehicleFirstGoodZ = this.lastVehicle.getZ();
+            this.vehicleLastGoodX = this.lastVehicle.getX();
+            this.vehicleLastGoodY = this.lastVehicle.getY();
+            this.vehicleLastGoodZ = this.lastVehicle.getZ();
+        } else {
+            this.lastVehicle = null;
+        }
+        // Folia end - support vehicle teleportations
     }
 
     @Override
@@ -573,9 +599,10 @@ public class ServerGamePacketListenerImpl
                 d7 = Math.max(d7, (otherFieldX * otherFieldX + otherFieldY * otherFieldY + otherFieldZ * otherFieldZ) - 1);
                 // Paper end - fix large move vectors killing the server
 
-                this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                int currTick = (int)(Util.getMillis() / 50); // Folia - region threading
+                this.allowedPlayerTicks += currTick - this.lastTick; // Folia - region threading
                 this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
-                this.lastTick = (int) (System.currentTimeMillis() / 50);
+                this.lastTick = (int) currTick; // Folia - region threading
 
                 ++this.receivedMovePacketCount;
                 int i = this.receivedMovePacketCount - this.knownMovePacketCount;
@@ -658,7 +685,13 @@ public class ServerGamePacketListenerImpl
 
                 rootVehicle.absSnapTo(d, d1, d2, f, f1);
                 // CraftBukkit start - fire PlayerMoveEvent TODO: this should be removed.
-                this.player.absSnapTo(d, d1, d2, this.player.getYRot(), this.player.getXRot()); // Paper - TODO: This breaks alot of stuff
+                // Folia start - move to positionRider
+                // this correction is required on folia since we move the connection tick to the beginning of the server
+                // tick, which would make any desync here visible
+                // this will correctly update the passenger positions for all mounted entities
+                // this prevents desync and ensures that all passengers have the correct rider-adjusted position
+                rootVehicle.repositionAllPassengers(false);
+                // Folia end - move to positionRider
                 org.bukkit.entity.Player player = this.getCraftPlayer();
                 if (!this.hasMoved) {
                     this.lastPosX = prevX;
@@ -688,7 +721,7 @@ public class ServerGamePacketListenerImpl
 
                     // If the event is cancelled we move the player back to their old location.
                     if (event.isCancelled()) {
-                        this.internalTeleport(from);
+                        this.player.getBukkitEntity().teleportAsync(from, PlayerTeleportEvent.TeleportCause.PLUGIN); // Folia - region threading
                         return;
                     }
 
@@ -696,7 +729,7 @@ public class ServerGamePacketListenerImpl
                     // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
                     // We only do this if the Event was not cancelled.
                     if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
-                        this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
+                        this.player.getBukkitEntity().teleportAsync(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN); // Folia - region threading
                         return;
                     }
 
@@ -870,7 +903,7 @@ public class ServerGamePacketListenerImpl
             }
 
             // This needs to be on main
-            this.server.scheduleOnMain(() -> this.sendServerSuggestions(packet, stringReader));
+            this.player.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> this.sendServerSuggestions(packet, stringReader), null, 1L); // Folia - region threading
         } else if (!completions.isEmpty()) {
             final com.mojang.brigadier.suggestion.SuggestionsBuilder builder0 = new com.mojang.brigadier.suggestion.SuggestionsBuilder(packet.getCommand(), stringReader.getTotalLength());
             final com.mojang.brigadier.suggestion.SuggestionsBuilder builder = builder0.createOffset(builder0.getInput().lastIndexOf(' ') + 1);
@@ -1332,11 +1365,11 @@ public class ServerGamePacketListenerImpl
         }
         // Paper end - Book size limits
         // CraftBukkit start
-        if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+        if (this.lastBookTick + 20 > this.lastTick) { // Folia - region threading
             this.disconnectAsync(Component.literal("Book edited too quickly!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
             return;
         }
-        this.lastBookTick = MinecraftServer.currentTick;
+        this.lastBookTick = this.lastTick; // Folia - region threading
         // CraftBukkit end
         int slot = packet.slot();
         if (Inventory.isHotbarSlot(slot) || slot == 40) {
@@ -1347,7 +1380,13 @@ public class ServerGamePacketListenerImpl
             Consumer<List<FilteredText>> consumer = optional.isPresent()
                 ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot)
                 : list1 -> this.updateBookContents(list1, slot);
-            this.filterTextPacket(list).thenAcceptAsync(consumer, this.server);
+            // Folia start - region threading
+            this.filterTextPacket(list).thenAcceptAsync(consumer, this.player::queuePacketTask).whenComplete((Object res, Throwable thr) -> {
+                if (thr != null) {
+                    LOGGER.error("Failed to handle book update packet", thr);
+                }
+            });
+            // Folia end - region threading
         }
     }
 
@@ -1478,9 +1517,10 @@ public class ServerGamePacketListenerImpl
                                     this.receivedMovePacketCount++;
                                     int i = this.receivedMovePacketCount - this.knownMovePacketCount;
                                     // CraftBukkit start - handle custom speeds and skipped ticks
-                                    this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                                    int currTick = (int)(Util.getMillis() / 50); // Folia - region threading
+                                    this.allowedPlayerTicks += currTick - this.lastTick; // Folia - region threading
                                     this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
-                                    this.lastTick = (int) (System.currentTimeMillis() / 50);
+                                    this.lastTick = currTick; // Folia - region threading
 
                                     if (i > Math.max(this.allowedPlayerTicks, 5)) {
                                     // CraftBukkit end
@@ -1674,7 +1714,7 @@ public class ServerGamePacketListenerImpl
 
                                         // If the event is cancelled we move the player back to their old location.
                                         if (event.isCancelled()) {
-                                            this.internalTeleport(from);
+                                            this.player.getBukkitEntity().teleportAsync(from, PlayerTeleportEvent.TeleportCause.PLUGIN); // Folia - region threading
                                             return;
                                         }
 
@@ -1682,7 +1722,7 @@ public class ServerGamePacketListenerImpl
                                         // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
                                         // We only do this if the Event was not cancelled.
                                         if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
-                                            this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
+                                            this.player.getBukkitEntity().teleportAsync(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN); // Folia - region threading
                                             return;
                                         }
 
@@ -1959,9 +1999,9 @@ public class ServerGamePacketListenerImpl
                     if (!this.player.isSpectator()) {
                         // limit how quickly items can be dropped
                         // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
-                        if (this.lastDropTick != MinecraftServer.currentTick) {
+                        if (this.lastDropTick != io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick()) { // Folia - region threading
                             this.dropCount = 0;
-                            this.lastDropTick = MinecraftServer.currentTick;
+                            this.lastDropTick = io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - region threading
                         } else {
                             // Else we increment the drop count and check the amount.
                             this.dropCount++;
@@ -1992,7 +2032,7 @@ public class ServerGamePacketListenerImpl
                 case ABORT_DESTROY_BLOCK:
                 case STOP_DESTROY_BLOCK:
                     // Paper start - Don't allow digging into unloaded chunks
-                    if (this.player.level().getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) == null || !this.player.isWithinBlockInteractionRange(pos, 1.0)) {
+                    if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.player.level(), pos.getX() >> 4, pos.getZ() >> 4, 8) || this.player.level().getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) == null || !this.player.isWithinBlockInteractionRange(pos, 1.0)) { // Folia - region threading - don't destroy blocks not owned
                         this.player.connection.ackBlockChangesUpTo(packet.getSequence());
                         return;
                     }
@@ -2076,7 +2116,7 @@ public class ServerGamePacketListenerImpl
                 }
                 // Paper end - improve distance check
                 BlockPos blockPos = hitResult.getBlockPos();
-                if (this.player.isWithinBlockInteractionRange(blockPos, 1.0)) {
+                if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.player.level(), blockPos.getX() >> 4, blockPos.getZ() >> 4, 8) && this.player.isWithinBlockInteractionRange(blockPos, 1.0)) { // Folia - do not allow players to interact with blocks outside the current region
                     Vec3 vec3 = location.subtract(Vec3.atCenterOf(blockPos));
                     double d = 1.0000001;
                     if (Math.abs(vec3.x()) < 1.0000001 && Math.abs(vec3.y()) < 1.0000001 && Math.abs(vec3.z()) < 1.0000001) {
@@ -2192,7 +2232,7 @@ public class ServerGamePacketListenerImpl
             for (ServerLevel serverLevel : this.server.getAllLevels()) {
                 Entity entity = packet.getEntity(serverLevel);
                 if (entity != null) {
-                    this.player.teleportTo(serverLevel, entity.getX(), entity.getY(), entity.getZ(), Set.of(), entity.getYRot(), entity.getXRot(), true, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
+                    io.papermc.paper.threadedregions.TeleportUtils.teleport(this.player, false, entity, null, null, Entity.TELEPORT_FLAG_LOAD_CHUNK, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE, null); // Folia - region threading
                     return;
                 }
             }
@@ -2219,7 +2259,7 @@ public class ServerGamePacketListenerImpl
         LOGGER.info("{} lost connection: {}", this.player.getPlainTextName(), details.reason().getString());
         // Paper start - Fix kick event leave message not being sent
         final net.kyori.adventure.text.Component quitMessage = details.quitMessage().map(io.papermc.paper.adventure.PaperAdventure::asAdventure).orElse(null);
-        this.removePlayerFromWorld(quitMessage);
+        if (!this.waitingForSwitchToConfig) this.removePlayerFromWorld(quitMessage); // Folia - region threading - don't double remove
         // Paper end - Fix kick event leave message not being sent
         super.onDisconnect(details);
     }
@@ -2229,6 +2269,8 @@ public class ServerGamePacketListenerImpl
         this.removePlayerFromWorld(null);
     }
 
+    public boolean hackSwitchingConfig; // Folia - rewrite login process
+
     private void removePlayerFromWorld(net.kyori.adventure.text.@Nullable Component quitMessage) {
         // Paper end - Fix kick event leave message not being sent
         this.chatMessageChain.close();
@@ -2242,6 +2284,8 @@ public class ServerGamePacketListenerImpl
         this.player.disconnect();
         // Paper start - Adventure
         quitMessage = quitMessage == null ? this.server.getPlayerList().remove(this.player) : this.server.getPlayerList().remove(this.player, quitMessage); // Paper - pass in quitMessage to fix kick message not being used
+        if (!this.hackSwitchingConfig) this.disconnectPos = this.player.chunkPosition(); // Folia - region threading - note: only set after removing, since it can tick the player
+        if (!this.hackSwitchingConfig) this.player.level().moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(DISCONNECT_TICKET, this.disconnectPos, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, this.disconnectTicketId); // Folia - region threading - force chunk to be loaded so that the region is not lost
         if ((quitMessage != null) && !quitMessage.equals(net.kyori.adventure.text.Component.empty())) {
             this.server.getPlayerList().broadcastSystemMessage(PaperAdventure.asVanilla(quitMessage), false);
             // Paper end - Adventure
@@ -2483,7 +2527,7 @@ public class ServerGamePacketListenerImpl
             this.player.resetLastActionTime();
             // CraftBukkit start
             if (sync) {
-                this.server.execute(handler);
+                this.player.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> handler.run(), null, 1L); // Folia - region threading
             } else {
                 handler.run();
             }
@@ -2563,6 +2607,7 @@ public class ServerGamePacketListenerImpl
         if (rawMessage.isEmpty()) {
             LOGGER.warn("{} tried to send an empty message", this.player.getScoreboardName());
         } else if (this.getCraftPlayer().isConversing()) {
+            if (true) throw new UnsupportedOperationException(); // Folia - region threading
             final String conversationInput = rawMessage;
             this.server.processQueue.add(() -> ServerGamePacketListenerImpl.this.getCraftPlayer().acceptConversationInput(conversationInput));
         } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) { // Re-add "Command Only" flag check
@@ -2767,8 +2812,25 @@ public class ServerGamePacketListenerImpl
     // Spigot end
 
     public void switchToConfig() {
-        this.waitingForSwitchToConfig = true;
+        // Folia start - rewrite login process
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.player, "Cannot switch config off-main");
+        if (io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) {
+            throw new IllegalStateException("Cannot switch config while on global tick thread");
+        }
+        // Folia end - rewrite login process
+        // Folia start - rewrite login process - fix bad ordering of this field write - move after removed from world
+        // the field write ordering is bad as it allows the client to send the response packet before the player is
+        // removed from the world
+        // Folia end - rewrite login process - fix bad ordering of this field write - move after removed from world
+        try { // Folia - rewrite login process - move connection ownership to global region
+            this.hackSwitchingConfig = true; // Folia - rewrite login process - avoid adding logout ticket here
         this.removePlayerFromWorld();
+        } finally { // Folia start - rewrite login process - move connection ownership to global region
+            io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.player.level().getCurrentWorldData();
+            worldData.connections.remove(this.connection);
+            // once waitingForSwitchToConfig is set, the global tick thread will own the connection
+        } // Folia end - rewrite login process - move connection ownership to global region
+        this.waitingForSwitchToConfig = true; // Folia - rewrite login process - fix bad ordering of this field write - moved down
         this.send(ClientboundStartConfigurationPacket.INSTANCE);
         this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
     }
@@ -2793,7 +2855,7 @@ public class ServerGamePacketListenerImpl
             // Spigot end
             this.player.resetLastActionTime();
             this.player.setShiftKeyDown(packet.isUsingSecondaryAction());
-            if (target != null) {
+            if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(target) && target != null) { // Folia - region threading - do not allow interaction of entities outside the current region
                 if (!serverLevel.getWorldBorder().isWithinBounds(target.blockPosition())) {
                     return;
                 }
@@ -2922,6 +2984,12 @@ public class ServerGamePacketListenerImpl
         switch (action) {
             case PERFORM_RESPAWN:
                 if (this.player.wonGame) {
+                    // Folia start - region threading
+                    if (true) {
+                        this.player.exitEndCredits();
+                        return;
+                    }
+                    // Folia end - region threading
                     this.player.wonGame = false;
                     this.player = this.server.getPlayerList().respawn(this.player, true, Entity.RemovalReason.CHANGED_DIMENSION, RespawnReason.END_PORTAL); // CraftBukkit
                     this.resetPosition();
@@ -2932,6 +3000,17 @@ public class ServerGamePacketListenerImpl
                         return;
                     }
 
+                    // Folia start - region threading
+                    if (true) {
+                        this.player.respawn((ServerPlayer player) -> {
+                            if (this.server.isHardcore()) {
+                                this.player.setGameMode(GameType.SPECTATOR, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.HARDCORE_DEATH, null); // Paper - Expand PlayerGameModeChangeEvent
+                                this.player.level().getGameRules().set(GameRules.SPECTATORS_GENERATE_CHUNKS, false, this.player.level()); // CraftBukkit - per-world
+                            }
+                        }, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.DEATH);
+                        return;
+                    }
+                    // Folia end - region threading
                     this.player = this.server.getPlayerList().respawn(this.player, false, Entity.RemovalReason.KILLED, RespawnReason.DEATH); // CraftBukkit
                     this.resetPosition();
                     this.restartClientLoadTimerAfterRespawn();
@@ -3467,7 +3546,14 @@ public class ServerGamePacketListenerImpl
         }
         List<String> list = Stream.of(lines).map(ChatFormatting::stripFormatting).collect(Collectors.toList());
         // Paper end - Limit client sign length
-        this.filterTextPacket(list).thenAcceptAsync(texts -> this.updateSignText(packet, (List<FilteredText>)texts), this.server);
+        // Folia start - region threading
+        this.filterTextPacket(list).thenAcceptAsync(texts -> this.updateSignText(packet, (List<FilteredText>)texts), this.player::queuePacketTask)
+                .whenComplete((Object res, Throwable thr) -> {
+            if (thr != null) {
+                LOGGER.error("Failed to handle sign update packet", thr);
+            }
+        });
+        // Folia end - region threading
     }
 
     private void updateSignText(ServerboundSignUpdatePacket packet, List<FilteredText> filteredText) {
@@ -3624,7 +3710,7 @@ public class ServerGamePacketListenerImpl
         this.chatMessageChain
             .append(
                 () -> {
-                    server.executeBlocking(() -> { // Paper - Broadcast chat session update sync
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().blockOn(() -> { // Paper - Broadcast chat session update sync // Folia - region threading
                     this.player.setChatSession(chatSession);
                     this.server
                         .getPlayerList()
@@ -3725,19 +3811,7 @@ public class ServerGamePacketListenerImpl
 
     @Override
     public void disconnectAsync(final net.minecraft.network.DisconnectionDetails disconnectionInfo) {
-        if (this.cserver.isPrimaryThread()) {
-            this.disconnect(disconnectionInfo);
-            return;
-        }
-
-        this.connection.setReadOnly();
-        this.server.scheduleOnMain(() -> {
-            this.disconnect(disconnectionInfo);
-            if (this.player.quitReason == null) {
-                // cancelled
-                this.connection.enableAutoRead();
-            }
-        });
+        this.disconnect(disconnectionInfo); // Folia - threaded regions
     }
 
     public final boolean isDisconnected() {
diff --git a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 51a29ab542136e67741be10bbc5c6377715a207c..605fbd9f16e6b969b3976dd1a905387ac0037c8a 100644
--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -94,7 +94,13 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
         // Paper end - login cookie API
 
         if (this.state == ServerLoginPacketListenerImpl.State.VERIFYING) {
+            // Folia start - region threading - rewrite login process
+            String name = this.authenticatedProfile.name();
+            java.util.UUID uniqueId = this.authenticatedProfile.id();
+            if (this.server.getPlayerList().pushPendingJoin(name, uniqueId, this.connection)) {
+            // Folia end - region threading - rewrite login process
             this.verifyLoginAndFinishConnectionSetup(Objects.requireNonNull(this.authenticatedProfile));
+            } // Folia - region threading - rewrite login process
         }
 
         if (this.state == ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT
@@ -206,7 +212,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     private void verifyLoginAndFinishConnectionSetup(GameProfile profile) {
         PlayerList playerList = this.server.getPlayerList();
-        Component component = org.bukkit.craftbukkit.event.CraftEventFactory.handleLoginResult(playerList.canPlayerLogin(this.connection.getRemoteAddress(), new NameAndId(profile)), this.paperLoginConnection, this.connection, profile, this.server, true); // Paper
+        Component component = org.bukkit.craftbukkit.event.CraftEventFactory.handleLoginResult(playerList.canPlayerLogin(this.connection.getRemoteAddress(), new NameAndId(profile), this.connection), this.paperLoginConnection, this.connection, profile, this.server, true); // Paper // Folia - region threading - add connection parameter
         if (component != null) {
             this.disconnect(component);
         } else {
@@ -218,7 +224,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                     );
             }
 
-            boolean flag = playerList.disconnectAllPlayersWithProfile(profile); // Paper - validate usernames
+            boolean flag = false && playerList.disconnectAllPlayersWithProfile(profile); // Paper - validate usernames // Folia - rewrite login process - always false here
             if (flag) {
                 this.state = ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT;
             } else {
@@ -332,7 +338,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
         uniqueId = gameprofile.id();
         // Paper end - Add more fields to AsyncPlayerPreLoginEvent
 
-        if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
+        if (false && PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) { // Folia - region threading
             final PlayerPreLoginEvent event = new PlayerPreLoginEvent(playerName, address, uniqueId);
             if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
                 event.disallow(asyncEvent.getResult(), asyncEvent.kickMessage()); // Paper - Adventure
diff --git a/net/minecraft/server/network/config/PrepareSpawnTask.java b/net/minecraft/server/network/config/PrepareSpawnTask.java
index 5014840bf5d7ef53a4fea8aa6f3b25eb4033ff96..1fd5a68fcb685646c5c28c8e94ffef5eb319d7d8 100644
--- a/net/minecraft/server/network/config/PrepareSpawnTask.java
+++ b/net/minecraft/server/network/config/PrepareSpawnTask.java
@@ -107,9 +107,24 @@ public class PrepareSpawnTask implements ConfigurationTask {
             }
             final ServerLevel serverLevel = serverLevel1;
             // Paper end - move logic in Entity to here, to use bukkit supplied world UUID & reset to main world spawn if no valid world is found
-            CompletableFuture<Vec3> completableFuture = savedPosition.position()
-                .map(CompletableFuture::completedFuture)
-                .orElseGet(() -> PlayerSpawnFinder.findSpawn(serverLevel, respawnData.pos()));
+            // Folia start - region threading
+            CompletableFuture<Vec3> completableFuture = new java.util.concurrent.CompletableFuture<>();
+            if (savedPosition.position().isPresent()) {
+                completableFuture.complete(savedPosition.position().get());
+            } else {
+                ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> spawnComplete = new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+                spawnComplete.addWaiter(
+                        (final org.bukkit.Location loc, final Throwable throwable) -> {
+                            if (throwable != null) {
+                                completableFuture.completeExceptionally(throwable);
+                            } else {
+                                completableFuture.complete(io.papermc.paper.util.MCUtil.toVec3(loc));
+                            }
+                        }
+                );
+                ServerPlayer.fudgeSpawnLocation(serverLevel, spawnComplete);
+            }
+            // Folia end - region threading
             Vec2 vec2 = savedPosition.rotation().orElse(new Vec2(respawnData.yaw(), respawnData.pitch()));
             this.state = new PrepareSpawnTask.Preparing(serverLevel, completableFuture, vec2);
         }
@@ -133,9 +148,35 @@ public class PrepareSpawnTask implements ConfigurationTask {
         };
     }
 
-    public ServerPlayer spawnPlayer(Connection connection, CommonListenerCookie cookie) {
+    // Folia start - region threading
+    public ServerLevel getSpawnWorld() {
+        if (this.state instanceof PrepareSpawnTask.Ready ready) {
+            return ready.getSpawnWorld();
+        } else {
+            throw new IllegalStateException("Player spawn was not ready");
+        }
+    }
+
+    public Vec3 getSpawnPosition() {
+        if (this.state instanceof PrepareSpawnTask.Ready ready) {
+            return ready.getSpawnPosition();
+        } else {
+            throw new IllegalStateException("Player spawn was not ready");
+        }
+    }
+
+    public ServerPlayer createPlayer(Connection connection, CommonListenerCookie cookie) {
         if (this.state instanceof PrepareSpawnTask.Ready ready) {
-            return ready.spawn(connection, cookie);
+            return ready.createPlayer(connection, cookie);
+        } else {
+            throw new IllegalStateException("Player spawn was not ready");
+        }
+    }
+    // Folia end - region threading
+
+    public ServerPlayer spawnPlayer(Connection connection, CommonListenerCookie cookie, ServerPlayer serverPlayer) { // Folia - region threading
+        if (this.state instanceof PrepareSpawnTask.Ready ready) {
+            return ready.spawn(connection, cookie, serverPlayer); // Folia - region threading
         } else {
             throw new IllegalStateException("Player spawn was not ready");
         }
@@ -185,7 +226,7 @@ public class PrepareSpawnTask implements ConfigurationTask {
                 Vec3 vec3 = this.spawnPosition.join();
                 if (this.chunkLoadFuture == null) {
                     // Paper start - PlayerSpawnLocationEvent
-                    if (this.eventFuture == null && org.spigotmc.event.player.PlayerSpawnLocationEvent.getHandlerList().getRegisteredListeners().length != 0) {
+                    if (false && this.eventFuture == null && org.spigotmc.event.player.PlayerSpawnLocationEvent.getHandlerList().getRegisteredListeners().length != 0) { // Folia - region threading
                         ServerPlayer serverPlayer;
                         if (PrepareSpawnTask.this.listener.connection.savedPlayerForLegacyEvents != null) {
                             serverPlayer = PrepareSpawnTask.this.listener.connection.savedPlayerForLegacyEvents;
@@ -261,9 +302,19 @@ public class PrepareSpawnTask implements ConfigurationTask {
             this.spawnLevel.getChunkSource().addTicketWithRadius(TicketType.PLAYER_SPAWN, new ChunkPos(BlockPos.containing(this.spawnPosition)), 3);
         }
 
-        public ServerPlayer spawn(Connection connection, CommonListenerCookie cookie) {
-            ChunkPos chunkPos = new ChunkPos(BlockPos.containing(this.spawnPosition));
-            this.spawnLevel.waitForEntities(chunkPos, 3);
+        // Folia start - region threading
+        public ServerLevel getSpawnWorld() {
+            return this.spawnLevel;
+        }
+
+        public Vec3 getSpawnPosition() {
+            return this.spawnPosition;
+        }
+
+        public ServerPlayer createPlayer(Connection connection, CommonListenerCookie cookie) {
+            //ChunkPos chunkPos = new ChunkPos(BlockPos.containing(this.spawnPosition));
+            //this.spawnLevel.waitForEntities(chunkPos, 3);
+            // Folia end - region threading
             // Paper start - configuration api - possibly use legacy saved server player instance
             ServerPlayer serverPlayer;
             if (connection.savedPlayerForLegacyEvents != null) {
@@ -277,6 +328,11 @@ public class PrepareSpawnTask implements ConfigurationTask {
                 serverPlayer = new ServerPlayer(PrepareSpawnTask.this.server, this.spawnLevel, cookie.gameProfile(), cookie.clientInformation());
             }
             // Paper end - configuration api - possibly use legacy saved server player instance
+            // Folia start - region threading
+            return serverPlayer;
+        }
+        public ServerPlayer spawn(Connection connection, CommonListenerCookie cookie, ServerPlayer serverPlayer) {
+            // Folia end - region threading
 
             ServerPlayer var7;
             try (ProblemReporter.ScopedCollector scopedCollector = new ProblemReporter.ScopedCollector(serverPlayer.problemPath(), PrepareSpawnTask.LOGGER)) {
diff --git a/net/minecraft/server/players/BanListEntry.java b/net/minecraft/server/players/BanListEntry.java
index 6e135a4f622ef564c1a6562e171a0e05296e0022..be14531aa9d740ea3a2b3f61d4d6e30318b7c91d 100644
--- a/net/minecraft/server/players/BanListEntry.java
+++ b/net/minecraft/server/players/BanListEntry.java
@@ -10,7 +10,7 @@ import net.minecraft.network.chat.Component;
 import org.jspecify.annotations.Nullable;
 
 public abstract class BanListEntry<T> extends StoredUserEntry<T> {
-    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
+    public static final ThreadLocal<SimpleDateFormat> DATE_FORMAT = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT)); // Folia - region threading - SDF is not thread-safe
     public static final String EXPIRES_NEVER = "forever";
     protected final Date created;
     protected final String source;
@@ -30,7 +30,7 @@ public abstract class BanListEntry<T> extends StoredUserEntry<T> {
 
         Date date;
         try {
-            date = entryData.has("created") ? DATE_FORMAT.parse(entryData.get("created").getAsString()) : new Date();
+            date = entryData.has("created") ? DATE_FORMAT.get().parse(entryData.get("created").getAsString()) : new Date(); // Folia - region threading - SDF is not thread-safe
         } catch (ParseException var7) {
             date = new Date();
         }
@@ -40,7 +40,7 @@ public abstract class BanListEntry<T> extends StoredUserEntry<T> {
 
         Date date1;
         try {
-            date1 = entryData.has("expires") ? DATE_FORMAT.parse(entryData.get("expires").getAsString()) : null;
+            date1 = entryData.has("expires") ? DATE_FORMAT.get().parse(entryData.get("expires").getAsString()) : null; // Folia - region threading - SDF is not thread-safe
         } catch (ParseException var6) {
             date1 = null;
         }
@@ -79,9 +79,9 @@ public abstract class BanListEntry<T> extends StoredUserEntry<T> {
 
     @Override
     protected void serialize(JsonObject data) {
-        data.addProperty("created", DATE_FORMAT.format(this.created));
+        data.addProperty("created", DATE_FORMAT.get().format(this.created)); // Folia - region threading - SDF is not thread-safe
         data.addProperty("source", this.source);
-        data.addProperty("expires", this.expires == null ? "forever" : DATE_FORMAT.format(this.expires));
+        data.addProperty("expires", this.expires == null ? "forever" : DATE_FORMAT.get().format(this.expires)); // Folia - region threading - SDF is not thread-safe
         data.addProperty("reason", this.reason);
     }
 
@@ -105,7 +105,7 @@ public abstract class BanListEntry<T> extends StoredUserEntry<T> {
         Date expires = null;
 
         try {
-            expires = jsonobject.has("expires") ? BanListEntry.DATE_FORMAT.parse(jsonobject.get("expires").getAsString()) : null;
+            expires = jsonobject.has("expires") ? BanListEntry.DATE_FORMAT.get().parse(jsonobject.get("expires").getAsString()) : null; // Folia - region threading - SDF is not thread-safe
         } catch (ParseException ex) {
             // Guess we don't have a date
         }
diff --git a/net/minecraft/server/players/OldUsersConverter.java b/net/minecraft/server/players/OldUsersConverter.java
index 6838b8d5c0d046a7db8a88534edc430d79d6c628..62b33d404a20c42eac557eb39188ae07c1376add 100644
--- a/net/minecraft/server/players/OldUsersConverter.java
+++ b/net/minecraft/server/players/OldUsersConverter.java
@@ -470,7 +470,7 @@ public class OldUsersConverter {
     static Date parseDate(String input, Date defaultValue) {
         Date date;
         try {
-            date = BanListEntry.DATE_FORMAT.parse(input);
+            date = BanListEntry.DATE_FORMAT.get().parse(input); // Folia - region threading - SDF is not thread-safe
         } catch (ParseException var4) {
             date = defaultValue;
         }
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 989ac565c47a70c7947cb7315d0f5c2cfecd0363..e0654190600925b912703e026cc716864f0741fd 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -112,10 +112,10 @@ public abstract class PlayerList {
     public static final Component DUPLICATE_LOGIN_DISCONNECT_MESSAGE = Component.translatable("multiplayer.disconnect.duplicate_login");
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int SEND_PLAYER_INFO_INTERVAL = 600;
-    private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z", Locale.ROOT);
+    private static final ThreadLocal<SimpleDateFormat> BAN_DATE_FORMAT = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z", Locale.ROOT)); // Folia - region threading - SDF is not thread-safe
     private final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
+    private final Map<UUID, ServerPlayer> playersByUUID = new java.util.concurrent.ConcurrentHashMap<>(); // Folia - region threading - change to CHM - Note: we do NOT expect concurrency PER KEY!
     private final UserBanList bans;
     private final IpBanList ipBans;
     private final ServerOpList ops;
@@ -136,6 +136,60 @@ public abstract class PlayerList {
     private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
     public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
 
+    // Folia start - region threading
+    private final Object connectionsStateLock = new Object();
+    private final Map<String, Connection> connectionByName = new java.util.HashMap<>();
+    private final Map<UUID, Connection> connectionById = new java.util.HashMap<>();
+    private final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<Connection> usersCountedAgainstLimit = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
+
+    public boolean pushPendingJoin(String userName, UUID byId, Connection conn) {
+        userName = userName.toLowerCase(java.util.Locale.ROOT);
+        Connection conflictingName, conflictingId;
+        synchronized (this.connectionsStateLock) {
+            conflictingName = this.connectionByName.get(userName);
+            conflictingId = this.connectionById.get(byId);
+
+            if (conflictingName == null && conflictingId == null) {
+                this.connectionByName.put(userName, conn);
+                this.connectionById.put(byId, conn);
+            }
+        }
+
+        Component message = Component.translatable("multiplayer.disconnect.duplicate_login", new Object[0]);
+
+        if (conflictingId != null || conflictingName != null) {
+            if (conflictingName != null && conflictingName.isPlayerConnected()) {
+                conflictingName.disconnectSafely(message, io.papermc.paper.connection.DisconnectionReason.DUPLICATE_LOGIN_MESSAGE);
+            }
+            if (conflictingName != conflictingId && conflictingId != null && conflictingId.isPlayerConnected()) {
+                conflictingId.disconnectSafely(message, io.papermc.paper.connection.DisconnectionReason.DUPLICATE_LOGIN_MESSAGE);
+            }
+        }
+
+        return conflictingName == null && conflictingId == null;
+    }
+
+    public void removeConnection(String userName, UUID byId, Connection conn) {
+        userName = userName.toLowerCase(java.util.Locale.ROOT);
+        synchronized (this.connectionsStateLock) {
+            this.connectionByName.remove(userName, conn);
+            this.connectionById.remove(byId, conn);
+            this.usersCountedAgainstLimit.remove(conn);
+        }
+    }
+
+    private boolean countConnection(Connection conn, int limit) {
+        synchronized (this.connectionsStateLock) {
+            int count = this.usersCountedAgainstLimit.size();
+            if (count >= limit) {
+                return false;
+            }
+            this.usersCountedAgainstLimit.add(conn);
+            return true;
+        }
+    }
+    // Folia end - region threading
+
     public PlayerList(
         MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registries, PlayerDataStorage playerIo, NotificationService notificationService
     ) {
@@ -166,6 +220,10 @@ public abstract class PlayerList {
         String loggableAddress = connection.getLoggableAddress(this.server.logIPs());
         LevelData levelData = serverLevel.getLevelData();
         ServerGamePacketListenerImpl serverGamePacketListenerImpl = new ServerGamePacketListenerImpl(this.server, connection, player, cookie);
+        // Folia start - rewrite login process
+        // only after setting the connection listener to game type, add the connection to this regions list
+        serverLevel.getCurrentWorldData().connections.add(connection);
+        // Folia end - rewrite login process
         connection.setupInboundProtocol(
             GameProtocols.SERVERBOUND_TEMPLATE.bind(RegistryFriendlyByteBuf.decorator(this.server.registryAccess()), serverGamePacketListenerImpl),
             serverGamePacketListenerImpl
@@ -201,7 +259,7 @@ public abstract class PlayerList {
         this.sendPlayerPermissionLevel(player);
         player.getStats().markAllDirty();
         player.getRecipeBook().sendInitialRecipeBook(player);
-        this.updateEntireScoreboard(serverLevel.getScoreboard(), player);
+        //this.updateEntireScoreboard(serverLevel.getScoreboard(), player); // Folia - region threading
         this.server.invalidateStatus();
         MutableComponent mutableComponent;
         if (player.getGameProfile().name().equalsIgnoreCase(string)) {
@@ -241,7 +299,7 @@ public abstract class PlayerList {
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
         if (!player.connection.isAcceptingMessages()) {
-            return;
+            //return; // Folia - region threading - must still allow the player to connect, as we must add to chunk map before handling disconnect
         }
 
         final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
@@ -256,8 +314,7 @@ public abstract class PlayerList {
         ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
 
         final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
-        for (int i = 0; i < this.players.size(); ++i) {
-            ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
+        for (ServerPlayer entityplayer1 : this.players) { // Folia - region threading
 
             if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
                 // Paper start - Add Listing API for Player
@@ -307,7 +364,7 @@ public abstract class PlayerList {
         // Paper start - Configurable player collision; Add to collideRule team if needed
         final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
         final PlayerTeam collideRuleTeam = scoreboard.getPlayerTeam(this.collideRuleTeamName);
-        if (this.collideRuleTeamName != null && collideRuleTeam != null && player.getTeam() == null) {
+        if (false && this.collideRuleTeamName != null && collideRuleTeam != null && player.getTeam() == null) { // Folia - region threading
             scoreboard.addPlayerToTeam(player.getScoreboardName(), collideRuleTeam);
         }
         // Paper end - Configurable player collision
@@ -412,7 +469,7 @@ public abstract class PlayerList {
 
     protected void save(ServerPlayer player) {
         if (!player.getBukkitEntity().isPersistent()) return; // CraftBukkit
-        player.lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
+        player.lastSave = System.nanoTime(); // Folia - region threading - changed to nanoTime tracking
         this.playerIo.save(player);
         ServerStatsCounter serverStatsCounter = player.getStats(); // CraftBukkit
         if (serverStatsCounter != null) {
@@ -447,7 +504,7 @@ public abstract class PlayerList {
         // CraftBukkit end
 
         // Paper start - Configurable player collision; Remove from collideRule team if needed
-        if (this.collideRuleTeamName != null) {
+        if (false && this.collideRuleTeamName != null) { // Folia - region threading
             final net.minecraft.world.scores.Scoreboard scoreBoard = this.server.getLevel(Level.OVERWORLD).getScoreboard();
             final PlayerTeam team = scoreBoard.getPlayersTeam(this.collideRuleTeamName);
             if (player.getTeam() == team && team != null) {
@@ -495,6 +552,7 @@ public abstract class PlayerList {
 
         serverLevel.removePlayerImmediately(player, Entity.RemovalReason.UNLOADED_WITH_PLAYER);
         player.retireScheduler(); // Paper - Folia schedulers
+        player.getBukkitEntity().packetProcessor.close(); // Folia - region threading
         player.getAdvancements().stopListening();
         this.players.remove(player);
         this.playersByName.remove(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
@@ -513,8 +571,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         // this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID())));
         ClientboundPlayerInfoRemovePacket packet = new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID()));
-        for (int i = 0; i < this.players.size(); i++) {
-            ServerPlayer otherPlayer = this.players.get(i);
+        for (ServerPlayer otherPlayer : this.players) { // Folia - region threading
 
             if (otherPlayer.getBukkitEntity().canSee(player.getBukkitEntity())) {
                 otherPlayer.connection.send(packet);
@@ -537,7 +594,7 @@ public abstract class PlayerList {
         }
     }
     // Paper end - PlayerLoginEvent
-    public LoginResult canPlayerLogin(SocketAddress socketAddress, NameAndId nameAndId) { // Paper - PlayerLoginEvent
+    public LoginResult canPlayerLogin(SocketAddress socketAddress, NameAndId nameAndId, Connection connection) { // Paper - PlayerLoginEvent // Folia - region threading - add connection parameter
         LoginResult whitelistEventResult; // Paper
         // Paper start - Fix MC-158900
         UserBanListEntry userBanListEntry;
@@ -546,7 +603,7 @@ public abstract class PlayerList {
             MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned.reason", userBanListEntry.getReasonMessage());
             if (userBanListEntry.getExpires() != null) {
                 mutableComponent.append(
-                    Component.translatable("multiplayer.disconnect.banned.expiration", BAN_DATE_FORMAT.format(userBanListEntry.getExpires()))
+                    Component.translatable("multiplayer.disconnect.banned.expiration", BAN_DATE_FORMAT.get().format(userBanListEntry.getExpires())) // Folia - region threading - SDF is not thread-safe
                 );
             }
 
@@ -560,13 +617,13 @@ public abstract class PlayerList {
             MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipBanListEntry.getReasonMessage());
             if (ipBanListEntry.getExpires() != null) {
                 mutableComponent.append(
-                    Component.translatable("multiplayer.disconnect.banned_ip.expiration", BAN_DATE_FORMAT.format(ipBanListEntry.getExpires()))
+                    Component.translatable("multiplayer.disconnect.banned_ip.expiration", BAN_DATE_FORMAT.get().format(ipBanListEntry.getExpires())) // Folia - region threading - SDF is not thread-safe
                 );
             }
 
             return new LoginResult(mutableComponent, org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED); // Paper - PlayerLoginEvent
         } else {
-            return this.canBypassFullServerLogin(nameAndId, new LoginResult(Component.translatable("multiplayer.disconnect.server_full"), org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL)); // Paper - PlayerServerFullCheckEvent
+            return this.canBypassFullServerLogin(nameAndId, new LoginResult(Component.translatable("multiplayer.disconnect.server_full"), org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL), connection); // Paper - PlayerServerFullCheckEvent // Folia - region threading - add connection parameter
         }
     }
 
@@ -585,15 +642,18 @@ public abstract class PlayerList {
             set.add(serverPlayer1);
         }
 
-        for (ServerPlayer serverPlayer2 : set) {
-            serverPlayer2.connection.disconnect(DUPLICATE_LOGIN_DISCONNECT_MESSAGE, io.papermc.paper.connection.DisconnectionReason.DUPLICATE_LOGIN_MESSAGE); // Paper - disconnect API
-        }
+        // Folia - region threading - rewrite login process - moved to pushPendingJoin
 
         return !set.isEmpty();
     }
 
     // Paper start - respawn event
     public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason respawnReason) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        }
+        // Folia end - region threading
         ServerPlayer.RespawnResult result = player.findRespawnPositionAndUseSpawnBlock0(!keepInventory, TeleportTransition.DO_NOTHING, respawnReason);
         if (result == null) { // disconnected player during the respawn event
             return player;
@@ -736,10 +796,10 @@ public abstract class PlayerList {
     public void tick() {
         if (++this.sendAllPlayerInfoIn > 600) {
             // CraftBukkit start
-            for (int i = 0; i < this.players.size(); ++i) {
-                final ServerPlayer target = this.players.get(i);
+            ServerPlayer[] players = this.players.toArray(new ServerPlayer[0]); // Folia - region threading
+            for (final ServerPlayer target : players) { // Folia - region threading
 
-                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), com.google.common.collect.Collections2.filter(this.players, t -> target.getBukkitEntity().canSee(t.getBukkitEntity()))));
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), com.google.common.collect.Collections2.filter(java.util.Arrays.asList(players),t -> target.getBukkitEntity().canSee(t.getBukkitEntity())))); // Folia - region threading
             }
             // CraftBukkit end
             this.sendAllPlayerInfoIn = 0;
@@ -757,8 +817,8 @@ public abstract class PlayerList {
     }
 
     public void broadcastAll(Packet packet, Level world) {
-        for (int i = 0; i < world.players().size(); ++i) {
-            ((ServerPlayer) world.players().get(i)).connection.send(packet);
+        for (net.minecraft.world.entity.player.Player player : world.players()) { // Folia - region threading
+            ((ServerPlayer) player).connection.send(packet); // Folia - region threading
         }
 
     }
@@ -795,8 +855,7 @@ public abstract class PlayerList {
         if (team == null) {
             this.broadcastSystemMessage(message, false);
         } else {
-            for (int i = 0; i < this.players.size(); i++) {
-                ServerPlayer serverPlayer = this.players.get(i);
+            for (ServerPlayer serverPlayer : this.players) { // Folia - region threading
                 if (serverPlayer.getTeam() != team) {
                     serverPlayer.sendSystemMessage(message);
                 }
@@ -805,10 +864,11 @@ public abstract class PlayerList {
     }
 
     public String[] getPlayerNamesArray() {
+        List<ServerPlayer> players = new java.util.ArrayList<>(this.players); // Folia - region threading
         String[] strings = new String[this.players.size()];
 
-        for (int i = 0; i < this.players.size(); i++) {
-            strings[i] = this.players.get(i).getGameProfile().name();
+        for (int i = 0; i < players.size(); i++) { // Folia - region threading
+            strings[i] = players.get(i).getGameProfile().name(); // Folia - region threading
         }
 
         return strings;
@@ -835,7 +895,9 @@ public abstract class PlayerList {
             );
         ServerPlayer player = this.getPlayer(nameAndId.id());
         if (player != null) {
-            this.sendPlayerPermissionLevel(player);
+            player.getBukkitEntity().taskScheduler.schedule((ServerPlayer serverPlayer) -> { // Folia - region threading
+            this.sendPlayerPermissionLevel(serverPlayer); // Folia - region threading
+            }, null, 1L); // Folia - region threading
         }
     }
 
@@ -843,7 +905,11 @@ public abstract class PlayerList {
         if (this.ops.remove(nameAndId)) {
             ServerPlayer player = this.getPlayer(nameAndId.id());
             if (player != null) {
-                this.sendPlayerPermissionLevel(player);
+                // Folia start - region threading
+                player.getBukkitEntity().taskScheduler.schedule((ServerPlayer serverPlayer) -> {
+                    this.sendPlayerPermissionLevel(serverPlayer);
+                }, null, 1L);
+                // Folia end - region threading
             }
         }
     }
@@ -873,8 +939,8 @@ public abstract class PlayerList {
     }
 
     // Paper start - whitelist verify event / login event
-    public LoginResult canBypassFullServerLogin(final NameAndId nameAndId, final LoginResult currentResult) {
-        final boolean shouldKick = this.players.size() >= this.getMaxPlayers() && !this.canBypassPlayerLimit(nameAndId);
+    public LoginResult canBypassFullServerLogin(final NameAndId nameAndId, final LoginResult currentResult, final Connection connection) { // Folia - region threading - add connection parameter
+        final boolean shouldKick = !this.countConnection(connection, this.getMaxPlayers()) && !this.canBypassPlayerLimit(nameAndId); // Folia - region threading - we control connection state here now async, not player list size
         final io.papermc.paper.event.player.PlayerServerFullCheckEvent fullCheckEvent = new io.papermc.paper.event.player.PlayerServerFullCheckEvent(
             new com.destroystokyo.paper.profile.CraftPlayerProfile(nameAndId),
             io.papermc.paper.adventure.PaperAdventure.asAdventure(currentResult.message),
@@ -923,8 +989,7 @@ public abstract class PlayerList {
     }
 
     public void broadcast(@Nullable Player except, double x, double y, double z, double radius, ResourceKey<Level> dimension, Packet<?> packet) {
-        for (int i = 0; i < this.players.size(); i++) {
-            ServerPlayer serverPlayer = this.players.get(i);
+        for (ServerPlayer serverPlayer : this.players) { // Folia - region threading
             // CraftBukkit start - Test if player receiving packet can see the source of the packet
             if (except != null && !serverPlayer.getBukkitEntity().canSee(except.getBukkitEntity())) {
                continue;
@@ -949,10 +1014,15 @@ public abstract class PlayerList {
     public void saveAll(final int interval) {
         io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
         int numSaved = 0;
-        final long now = MinecraftServer.currentTick;
-        for (int i = 0; i < this.players.size(); i++) {
-            final ServerPlayer player = this.players.get(i);
-            if (interval == -1 || now - player.lastSave >= interval) {
+        final long now = System.nanoTime(); // Folia - region threading
+        long timeInterval = (long)interval * io.papermc.paper.threadedregions.TickRegionScheduler.TIME_BETWEEN_TICKS; // Folia - region threading
+        for (final ServerPlayer player : this.players) { // Folia - region threading
+            // Folia start - region threading
+            if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+                continue;
+            }
+            // Folia end - region threading
+            if (interval == -1 || now - player.lastSave >= timeInterval) { // Folia - region threading
                 this.save(player);
                 if (interval != -1 && ++numSaved >= io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.maxPerTick()) {
                     break;
@@ -1074,6 +1144,20 @@ public abstract class PlayerList {
     }
 
     public void removeAll(boolean isRestarting) {
+        // Folia start - region threading
+        // just send disconnect packet, don't modify state
+        for (ServerPlayer player : this.players) {
+            final Component shutdownMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(this.server.server.shutdownMessage()); // Paper - Adventure
+            // CraftBukkit end
+
+            player.connection.send(new net.minecraft.network.protocol.common.ClientboundDisconnectPacket(shutdownMessage), net.minecraft.network.PacketSendListener.thenRun(() -> {
+                player.connection.connection.disconnect(shutdownMessage);
+            }));
+        }
+        if (true) {
+            return;
+        }
+        // Folia end - region threading
         // Paper end
         // CraftBukkit start - disconnect safely
         for (ServerPlayer player : this.players) {
@@ -1083,7 +1167,7 @@ public abstract class PlayerList {
         // CraftBukkit end
 
         // Paper start - Configurable player collision; Remove collideRule team if it exists
-        if (this.collideRuleTeamName != null) {
+        if (false && this.collideRuleTeamName != null) { // Folia - region threading
             final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
             final PlayerTeam team = scoreboard.getPlayersTeam(this.collideRuleTeamName);
             if (team != null) scoreboard.removePlayerTeam(team);
diff --git a/net/minecraft/server/players/StoredUserList.java b/net/minecraft/server/players/StoredUserList.java
index 9ee855c0d1a30b3c83e0e9e93f1a561ac462bc49..1a79297ebba73efe00a85d21294a2a32a2038022 100644
--- a/net/minecraft/server/players/StoredUserList.java
+++ b/net/minecraft/server/players/StoredUserList.java
@@ -123,6 +123,7 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
     }
 
     public void save() throws IOException {
+        synchronized (this) { // Folia - region threading
         this.removeExpired(); // Paper - remove expired values before saving
         JsonArray jsonArray = new JsonArray();
         this.map.values().stream().map(storedEntry -> Util.make(new JsonObject(), storedEntry::serialize)).forEach(jsonArray::add);
@@ -130,9 +131,11 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
         try (BufferedWriter writer = Files.newWriter(this.file, StandardCharsets.UTF_8)) {
             GSON.toJson(jsonArray, GSON.newJsonWriter(writer));
         }
+        } // Folia - region threading
     }
 
     public void load() throws IOException {
+        synchronized (this) { // Folia - region threading
         if (this.file.exists()) {
             try (BufferedReader reader = Files.newReader(this.file, StandardCharsets.UTF_8)) {
                 this.map.clear();
@@ -157,5 +160,6 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
             }
             // Spigot end
         }
+        } // Folia - region threading
     }
 }
diff --git a/net/minecraft/server/waypoints/ServerWaypointManager.java b/net/minecraft/server/waypoints/ServerWaypointManager.java
index 471e558a609c9e457720660b90fe57322b860461..1cbc46e480cc7d109c6128f109a1a9e38bf1a193 100644
--- a/net/minecraft/server/waypoints/ServerWaypointManager.java
+++ b/net/minecraft/server/waypoints/ServerWaypointManager.java
@@ -22,11 +22,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
 
     @Override
     public void trackWaypoint(WaypointTransmitter waypoint) {
-        this.waypoints.add(waypoint);
-
-        for (ServerPlayer serverPlayer : this.players) {
-            this.createConnection(serverPlayer, waypoint);
-        }
+        // Folia - region threading
     }
 
     @Override
@@ -53,37 +49,15 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     public void addPlayer(ServerPlayer player) {
-        this.players.add(player);
-
-        for (WaypointTransmitter waypointTransmitter : this.waypoints) {
-            this.createConnection(player, waypointTransmitter);
-        }
-
-        if (player.isTransmittingWaypoint()) {
-            this.trackWaypoint((WaypointTransmitter)player);
-        }
+        // Folia - region threading
     }
 
     public void updatePlayer(ServerPlayer player) {
-        Map<WaypointTransmitter, WaypointTransmitter.Connection> map = this.connections.row(player);
-        SetView<WaypointTransmitter> set = Sets.difference(this.waypoints, map.keySet());
-
-        for (Entry<WaypointTransmitter, WaypointTransmitter.Connection> entry : ImmutableSet.copyOf(map.entrySet())) {
-            this.updateConnection(player, entry.getKey(), entry.getValue());
-        }
-
-        for (WaypointTransmitter waypointTransmitter : set) {
-            this.createConnection(player, waypointTransmitter);
-        }
+        // Folia - region threading
     }
 
     public void removePlayer(ServerPlayer player) {
-        this.connections.row(player).values().removeIf(connection -> {
-            connection.disconnect();
-            return true;
-        });
-        this.untrackWaypoint((WaypointTransmitter)player);
-        this.players.remove(player);
+        // Folia - region threading
     }
 
     public void breakAllConnections() {
diff --git a/net/minecraft/util/SpawnUtil.java b/net/minecraft/util/SpawnUtil.java
index cbee99d782af257d04a7da739f956886146c9542..73100d3375ac7ee64b7aa5b2fe4e14d87e5e9565 100644
--- a/net/minecraft/util/SpawnUtil.java
+++ b/net/minecraft/util/SpawnUtil.java
@@ -83,7 +83,7 @@ public class SpawnUtil {
                         return Optional.of(mob);
                     }
 
-                    mob.discard(null); // CraftBukkit - add Bukkit remove cause
+                    //mob.discard(null); // CraftBukkit - add Bukkit remove cause // Folia - region threading
                 }
             }
         }
diff --git a/net/minecraft/world/RandomSequences.java b/net/minecraft/world/RandomSequences.java
index 4fe5a6c1faa69a76a96d7cd1efa1df8421d6374f..bc39446886d92fb578ec31632fb61b7019a20fa5 100644
--- a/net/minecraft/world/RandomSequences.java
+++ b/net/minecraft/world/RandomSequences.java
@@ -29,7 +29,7 @@ public class RandomSequences extends SavedData {
     private int salt;
     private boolean includeWorldSeed = true;
     private boolean includeSequenceId = true;
-    private final Map<Identifier, RandomSequence> sequences = new Object2ObjectOpenHashMap<>();
+    private final Map<Identifier, RandomSequence> sequences = new java.util.concurrent.ConcurrentHashMap<>(); // Folia - region threading
 
     public RandomSequences() {
     }
@@ -101,61 +101,61 @@ public class RandomSequences extends SavedData {
         @Override
         public RandomSource fork() {
             RandomSequences.this.setDirty();
-            return this.random.fork();
+            synchronized (this.random) { return this.random.fork(); } // Folia - region threading
         }
 
         @Override
         public PositionalRandomFactory forkPositional() {
             RandomSequences.this.setDirty();
-            return this.random.forkPositional();
+            synchronized (this.random) { return this.random.forkPositional(); } // Folia - region threading
         }
 
         @Override
         public void setSeed(long seed) {
             RandomSequences.this.setDirty();
-            this.random.setSeed(seed);
+            synchronized (this.random) { this.random.setSeed(seed); } // Folia - region threading
         }
 
         @Override
         public int nextInt() {
             RandomSequences.this.setDirty();
-            return this.random.nextInt();
+            synchronized (this.random) { return this.random.nextInt(); } // Folia - region threading
         }
 
         @Override
         public int nextInt(int bound) {
             RandomSequences.this.setDirty();
-            return this.random.nextInt(bound);
+            synchronized (this.random) { return this.random.nextInt(bound); } // Folia - region threading
         }
 
         @Override
         public long nextLong() {
             RandomSequences.this.setDirty();
-            return this.random.nextLong();
+            synchronized (this.random) { return this.random.nextLong(); } // Folia - region threading
         }
 
         @Override
         public boolean nextBoolean() {
             RandomSequences.this.setDirty();
-            return this.random.nextBoolean();
+            synchronized (this.random) { return this.random.nextBoolean(); } // Folia - region threading
         }
 
         @Override
         public float nextFloat() {
             RandomSequences.this.setDirty();
-            return this.random.nextFloat();
+            synchronized (this.random) { return this.random.nextFloat(); } // Folia - region threading
         }
 
         @Override
         public double nextDouble() {
             RandomSequences.this.setDirty();
-            return this.random.nextDouble();
+            synchronized (this.random) { return this.random.nextDouble(); } // Folia - region threading
         }
 
         @Override
         public double nextGaussian() {
             RandomSequences.this.setDirty();
-            return this.random.nextGaussian();
+            synchronized (this.random) { return this.random.nextGaussian(); } // Folia - region threading
         }
 
         @Override
diff --git a/net/minecraft/world/damagesource/CombatTracker.java b/net/minecraft/world/damagesource/CombatTracker.java
index ffdfb4c4e3d6496ebdba6e4bad7146a9cbdcf5ec..14b55c20ff8645aeecc228bdc4c8d242d9aeeed9 100644
--- a/net/minecraft/world/damagesource/CombatTracker.java
+++ b/net/minecraft/world/damagesource/CombatTracker.java
@@ -63,7 +63,7 @@ public class CombatTracker {
     }
 
     private Component getMessageForAssistedFall(Entity entity, Component entityDisplayName, String hasWeaponTranslationKey, String noWeaponTranslationKey) {
-        ItemStack itemStack = entity instanceof LivingEntity livingEntity ? livingEntity.getMainHandItem() : ItemStack.EMPTY;
+        ItemStack itemStack = entity instanceof LivingEntity livingEntity && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(livingEntity) ? livingEntity.getMainHandItem() : ItemStack.EMPTY; // Folia - region threading
         return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
             ? Component.translatable(hasWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName, itemStack.getDisplayName())
             : Component.translatable(noWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName);
@@ -89,7 +89,7 @@ public class CombatTracker {
     }
 
     private static @Nullable Component getDisplayName(@Nullable Entity entity) {
-        return entity == null ? null : entity.getDisplayName();
+        return entity == null || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity) ? null : entity.getDisplayName(); // Folia - region threading
     }
 
     public Component getDeathMessage() {
diff --git a/net/minecraft/world/damagesource/DamageSource.java b/net/minecraft/world/damagesource/DamageSource.java
index 4df37fcd42b8edf789ee8e99d61ee1fa6471288b..5ff788e0f365f080f505ee72200bf4bb62104756 100644
--- a/net/minecraft/world/damagesource/DamageSource.java
+++ b/net/minecraft/world/damagesource/DamageSource.java
@@ -151,12 +151,12 @@ public class DamageSource {
         if (this.causingEntity == null && this.directEntity == null) {
             LivingEntity killCredit = livingEntity.getKillCredit();
             String string1 = string + ".player";
-            return killCredit != null
+            return killCredit != null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(killCredit)
                 ? Component.translatable(string1, livingEntity.getDisplayName(), killCredit.getDisplayName())
                 : Component.translatable(string, livingEntity.getDisplayName());
         } else {
             Component component = this.causingEntity == null ? this.directEntity.getDisplayName() : this.causingEntity.getDisplayName();
-            ItemStack itemStack = this.causingEntity instanceof LivingEntity livingEntity1 ? livingEntity1.getMainHandItem() : ItemStack.EMPTY;
+            ItemStack itemStack = this.causingEntity instanceof LivingEntity livingEntity1 && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(livingEntity1) ? livingEntity1.getMainHandItem() : ItemStack.EMPTY; // Folia - region threading
             return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
                 ? Component.translatable(string + ".item", livingEntity.getDisplayName(), component, itemStack.getDisplayName())
                 : Component.translatable(string, livingEntity.getDisplayName(), component);
diff --git a/net/minecraft/world/damagesource/FallLocation.java b/net/minecraft/world/damagesource/FallLocation.java
index 6471ff779dd1672db769538bad1d00c8c5724be3..956782df0a3a5e221422c072d7c1c67e76396658 100644
--- a/net/minecraft/world/damagesource/FallLocation.java
+++ b/net/minecraft/world/damagesource/FallLocation.java
@@ -34,7 +34,7 @@ public record FallLocation(String id) {
 
     public static @Nullable FallLocation getCurrentFallLocation(LivingEntity entity) {
         Optional<BlockPos> lastClimbablePos = entity.getLastClimbablePos();
-        if (lastClimbablePos.isPresent()) {
+        if (lastClimbablePos.isPresent() && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)entity.level(), lastClimbablePos.get())) { // Folia - region threading
             BlockState blockState = entity.level().getBlockState(lastClimbablePos.get());
             return blockToFallLocation(blockState);
         } else {
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index cd434d5a6e37a525611fd0b44b9a859435c4d157..7fc26d8d17970d58f3bb0ca4849005ef7a7abb28 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -160,7 +160,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     // Paper start - Share random for entities to make them more random
-    public static RandomSource SHARED_RANDOM = new RandomRandomSource();
+    public static RandomSource SHARED_RANDOM = io.papermc.paper.threadedregions.util.ThreadLocalRandomSource.INSTANCE; // Folia - region threading
     // Paper start - replace random
     private static final class RandomRandomSource extends ca.spottedleaf.moonrise.common.util.ThreadUnsafeRandom {
         public RandomRandomSource() {
@@ -321,7 +321,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     private boolean hasGlowingTag;
     private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
-    private long pistonDeltasGameTime;
+    private long pistonDeltasGameTime = Long.MIN_VALUE; // Folia - region threading
     private EntityDimensions dimensions;
     private float eyeHeight;
     public boolean isInPowderSnow;
@@ -534,6 +534,23 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
     }
     // Paper end - optimise entity tracker
+    // Folia start - region ticking
+    public void updateTicks(long fromTickOffset, long fromRedstoneTimeOffset) {
+        if (this.activatedTick != Integer.MIN_VALUE) {
+            this.activatedTick += fromTickOffset;
+        }
+        if (this.activatedImmunityTick != Integer.MIN_VALUE) {
+            this.activatedImmunityTick += fromTickOffset;
+        }
+        if (this.pistonDeltasGameTime != Long.MIN_VALUE) {
+            this.pistonDeltasGameTime += fromRedstoneTimeOffset;
+        }
+    }
+
+    public boolean canBeSpectated() {
+        return !this.getBukkitEntity().taskScheduler.isRetiredOffThread();
+    }
+    // Folia end - region ticking
 
     public Entity(EntityType<?> type, Level level) {
         this.type = type;
@@ -675,8 +692,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     // due to interactions on the client.
     public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
-            ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
-            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
+            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = this.moonrise$getTrackedEntity(); // Folia - region threading
             if (tracker == null) {
                 return;
             }
@@ -845,7 +861,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     public void postTick() {
         // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
         if (!(this instanceof ServerPlayer) && this.isAlive()) { // Paper - don't attempt to teleport dead entities
-            this.handlePortal();
+            //this.handlePortal(); // Folia - region threading
         }
     }
     // CraftBukkit end
@@ -864,7 +880,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             this.boardingCooldown--;
         }
 
-        if (this instanceof ServerPlayer) this.handlePortal(); // CraftBukkit - Moved up to postTick
+        //if (this instanceof ServerPlayer) this.handlePortal(); // CraftBukkit - Moved up to postTick // Folia - region threading - ONLY allow in postTick()
         if (this.canSpawnSprintParticle()) {
             this.spawnSprintParticle();
         }
@@ -1132,8 +1148,8 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         } else {
             if (type == MoverType.PISTON) {
                 // Paper start - EAR 2
-                this.activatedTick = Math.max(this.activatedTick, net.minecraft.server.MinecraftServer.currentTick + 20);
-                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, net.minecraft.server.MinecraftServer.currentTick + 20);
+                this.activatedTick = Math.max(this.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20); // Folia - region threading
+                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20); // Folia - region threading
                 // Paper end - EAR 2
                 movement = this.limitPistonMovement(movement);
                 if (movement.equals(Vec3.ZERO)) {
@@ -1486,7 +1502,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         if (pos.lengthSqr() <= 1.0E-7) {
             return pos;
         } else {
-            long gameTime = this.level().getGameTime();
+            long gameTime = this.level().getRedstoneGameTime(); // Folia - region threading
             if (gameTime != this.pistonDeltasGameTime) {
                 Arrays.fill(this.pistonDeltas, 0.0);
                 this.pistonDeltasGameTime = gameTime;
@@ -1722,6 +1738,11 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 } else if (index >= maxSteps) {
                     return false;
                 } else {
+                    // Folia start - region threading
+                    if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(Entity.this.level, pos, 16)) {
+                        return false;
+                    }
+                    // Folia end - region threading
                     atomicInteger.set(index);
                     BlockState blockState = this.level().getBlockState(pos);
                     if (blockState.isAir()) {
@@ -3253,6 +3274,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             }
 
             if (force || this.canRide(entity) && entity.canAddPassenger(this)) {
+                if (this.valid) { // Folia - region threading - suppress entire event logic during worldgen
                 // CraftBukkit start
                 if (entity.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && this.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
                     org.bukkit.event.vehicle.VehicleEnterEvent event = new org.bukkit.event.vehicle.VehicleEnterEvent((org.bukkit.entity.Vehicle) entity.getBukkitEntity(), this.getBukkitEntity());
@@ -3274,6 +3296,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                     return false;
                 }
                 // CraftBukkit end
+                } // Folia - region threading - suppress entire event logic during worldgen
                 if (this.isPassenger()) {
                     this.stopRiding();
                 }
@@ -3282,7 +3305,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 this.vehicle = entity;
                 this.vehicle.addPassenger(this);
                 if (triggerEvents) {
-                    this.level().gameEvent(this, GameEvent.ENTITY_MOUNT, this.vehicle.position);
+                    if (!this.hasNullCallback()) this.level().gameEvent(this, GameEvent.ENTITY_MOUNT, this.vehicle.position); // Folia - region threading - do not fire game events for entities not added
                     entity.getIndirectPassengersStream()
                         .filter(entity2 -> entity2 instanceof ServerPlayer)
                         .forEach(entity2 -> CriteriaTriggers.START_RIDING_TRIGGER.trigger((ServerPlayer)entity2));
@@ -3318,7 +3341,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             if (!entity.removePassenger(this, suppressCancellation)) this.vehicle = entity; // CraftBukkit // Paper - Force entity dismount during teleportation
             Entity.RemovalReason removalReason = this.getRemovalReason();
             if (removalReason == null || removalReason.shouldDestroy()) {
-                this.level().gameEvent(this, GameEvent.ENTITY_DISMOUNT, entity.position);
+                if (!this.hasNullCallback()) this.level().gameEvent(this, GameEvent.ENTITY_DISMOUNT, entity.position); // Folia - region threading - do not fire game events for entities not added
             }
         }
     }
@@ -3362,6 +3385,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
         } else {
             // CraftBukkit start
+            if (this.valid) { // Folia - region threading - suppress entire event logic during worldgen
             org.bukkit.craftbukkit.entity.CraftEntity craft = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
             Entity orig = craft == null ? null : craft.getHandle();
             if (this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
@@ -3389,6 +3413,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 return false;
             }
             // CraftBukkit end
+            } // Folia - region threading - suppress entire event logic during worldgen
             if (this.passengers.size() == 1 && this.passengers.get(0) == passenger) {
                 this.passengers = ImmutableList.of();
             } else {
@@ -3486,7 +3511,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
     }
 
-    protected void handlePortal() {
+    public boolean handlePortal() { // Folia - region threading - public, ret type -> boolean
         if (this.level() instanceof ServerLevel serverLevel) {
             this.processPortalCooldown();
             if (this.portalProcess != null) {
@@ -3494,22 +3519,20 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                     ProfilerFiller profilerFiller = Profiler.get();
                     profilerFiller.push("portal");
                     this.setPortalCooldown();
-                    TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
-                    if (portalDestination != null) {
-                        ServerLevel level = portalDestination.newLevel();
-                        if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
-                            )
-                         {
-                            this.teleport(portalDestination);
-                        }
+                    // Folia start - region threading
+                    try {
+                        return this.portalProcess.portalAsync(serverLevel, this);
+                    } finally {
+                        profilerFiller.pop();
                     }
-
-                    profilerFiller.pop();
+                    // Folia end - region threading
                 } else if (this.portalProcess.hasExpired()) {
                     this.portalProcess = null;
                 }
             }
         }
+
+        return false; // Folia - region threading
     }
 
     public int getDimensionChangingDelay() {
@@ -3648,6 +3671,11 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     public @Nullable PlayerTeam getTeam() {
+        // Folia start - region threading
+        if (true) {
+            return null;
+        }
+        // Folia end - region threading
         if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof Player)) { return null; } // Paper - Perf: Disable Scoreboards for non players by default
         return this.level().getScoreboard().getPlayersTeam(this.getScoreboardName());
     }
@@ -3992,7 +4020,794 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         this.portalProcess = entity.portalProcess;
     }
 
+    // Folia start - region threading
+    public static class EntityTreeNode {
+        @Nullable
+        public EntityTreeNode parent;
+        public Entity root;
+        @Nullable
+        public EntityTreeNode[] passengers;
+
+        public EntityTreeNode(EntityTreeNode parent, Entity root) {
+            this.parent = parent;
+            this.root = root;
+        }
+
+        public EntityTreeNode(EntityTreeNode parent, Entity root, EntityTreeNode[] passengers) {
+            this.parent = parent;
+            this.root = root;
+            this.passengers = passengers;
+        }
+
+        public List<EntityTreeNode> getFullTree() {
+            List<EntityTreeNode> ret = new java.util.ArrayList<>();
+            ret.add(this);
+
+            // this is just a BFS except we don't remove from head, we just advance down the list
+            for (int i = 0; i < ret.size(); ++i) {
+                EntityTreeNode node = ret.get(i);
+
+                EntityTreeNode[] passengers = node.passengers;
+                if (passengers == null) {
+                    continue;
+                }
+                for (EntityTreeNode passenger : passengers) {
+                    ret.add(passenger);
+                }
+            }
+
+            return ret;
+        }
+
+        public void restore() {
+            java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
+            queue.add(this);
+
+            EntityTreeNode curr;
+            while ((curr = queue.pollFirst()) != null) {
+                EntityTreeNode[] passengers = curr.passengers;
+                if (passengers == null) {
+                    continue;
+                }
+
+                List<Entity> newPassengers = new java.util.ArrayList<>();
+                for (EntityTreeNode passenger : passengers) {
+                    queue.add(passenger);
+                    newPassengers.add(passenger.root);
+                    passenger.root.vehicle = curr.root;
+                }
+
+                curr.root.passengers = ImmutableList.copyOf(newPassengers);
+            }
+        }
+
+        public void addTracker() {
+            for (final EntityTreeNode node : this.getFullTree()) {
+                if (node.root.moonrise$getTrackedEntity() != null) {
+                    for (final ServerPlayer player : node.root.level.getLocalPlayers()) {
+                        node.root.moonrise$getTrackedEntity().updatePlayer(player);
+                    }
+                }
+            }
+        }
+
+        public void clearTracker() {
+            for (final EntityTreeNode node : this.getFullTree()) {
+                if (node.root.moonrise$getTrackedEntity() != null) {
+                    node.root.moonrise$getTrackedEntity().moonrise$removeNonTickThreadPlayers();
+                    for (final ServerPlayer player : node.root.level.getLocalPlayers()) {
+                        node.root.moonrise$getTrackedEntity().removePlayer(player);
+                    }
+                }
+            }
+        }
+
+        public void adjustRiders(boolean teleport) {
+            java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
+            queue.add(this);
+
+            EntityTreeNode curr;
+            while ((curr = queue.pollFirst()) != null) {
+                EntityTreeNode[] passengers = curr.passengers;
+                if (passengers == null) {
+                    continue;
+                }
+
+                for (EntityTreeNode passenger : passengers) {
+                    queue.add(passenger);
+                    curr.root.positionRider(passenger.root, teleport ? Entity::snapTo : Entity::setPos);
+                }
+            }
+        }
+    }
+
+    public void repositionAllPassengers(boolean teleport) {
+        this.makePassengerTree().adjustRiders(teleport);
+    }
+
+    protected EntityTreeNode makePassengerTree() {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot read passengers off of the main thread");
+
+        EntityTreeNode root = new EntityTreeNode(null, this);
+        java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
+        queue.add(root);
+        EntityTreeNode curr;
+        while ((curr = queue.pollFirst()) != null) {
+            Entity vehicle = curr.root;
+            List<Entity> passengers = vehicle.passengers;
+            if (passengers.isEmpty()) {
+                continue;
+            }
+
+            EntityTreeNode[] treePassengers = new EntityTreeNode[passengers.size()];
+            curr.passengers = treePassengers;
+
+            for (int i = 0; i < passengers.size(); ++i) {
+                Entity passenger = passengers.get(i);
+                queue.addLast(treePassengers[i] = new EntityTreeNode(curr, passenger));
+            }
+        }
+
+        return root;
+    }
+
+    protected EntityTreeNode detachPassengers() {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot adjust passengers/vehicle off of the main thread");
+
+        EntityTreeNode root = new EntityTreeNode(null, this);
+        java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
+        queue.add(root);
+        EntityTreeNode curr;
+        while ((curr = queue.pollFirst()) != null) {
+            Entity vehicle = curr.root;
+            List<Entity> passengers = vehicle.passengers;
+            if (passengers.isEmpty()) {
+                continue;
+            }
+
+            vehicle.passengers = ImmutableList.of();
+
+            EntityTreeNode[] treePassengers = new EntityTreeNode[passengers.size()];
+            curr.passengers = treePassengers;
+
+            for (int i = 0; i < passengers.size(); ++i) {
+                Entity passenger = passengers.get(i);
+                passenger.vehicle = null;
+                queue.addLast(treePassengers[i] = new EntityTreeNode(curr, passenger));
+            }
+        }
+
+        return root;
+    }
+
+    /**
+     * This flag will perform an async load on the chunks determined by
+     * the entity's bounding box before teleporting the entity.
+     */
+    public static final long TELEPORT_FLAG_LOAD_CHUNK = 1L << 0;
+    /**
+     * This flag requires the entity being teleported to be a root vehicle.
+     * Thus, if you want to teleport a non-root vehicle, you must dismount
+     * the target entity before calling teleport, otherwise the
+     * teleport will be refused.
+     */
+    public static final long TELEPORT_FLAG_TELEPORT_PASSENGERS = 1L << 1;
+    /**
+     * The flag will dismount any passengers and dismout from the current vehicle
+     * to teleport if and only if dismounting would result in the teleport being allowed.
+     */
+    public static final long TELEPORT_FLAG_UNMOUNT = 1L << 2;
+
+    protected void placeSingleSync(ServerLevel originWorld, ServerLevel destination, EntityTreeNode treeNode, long teleportFlags) {
+        destination.addDuringTeleport(this);
+    }
+
+    protected final void placeInAsync(ServerLevel originWorld, ServerLevel destination, long teleportFlags,
+                                      EntityTreeNode passengerTree, java.util.function.Consumer<Entity> teleportComplete) {
+        Vec3 pos = this.position();
+        ChunkPos posChunk = new ChunkPos(
+            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(pos),
+            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(pos)
+        );
+
+        // ensure the region is always ticking in case of a shutdown
+        // otherwise, the shutdown will not be able to complete the shutdown as it requires a ticking region
+        Long teleportHoldId = Long.valueOf(TELEPORT_HOLD_TICKET_GEN.getAndIncrement());
+        originWorld.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+            TicketType.TELEPORT_HOLD_TICKET, posChunk,
+            ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+            teleportHoldId
+        );
+        final ServerLevel.PendingTeleport pendingTeleport = new ServerLevel.PendingTeleport(passengerTree, pos);
+        destination.pushPendingTeleport(pendingTeleport);
+
+        Runnable scheduleEntityJoin = () -> {
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                destination,
+                ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(pos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(pos),
+                () -> {
+                    if (!destination.removePendingTeleport(pendingTeleport)) {
+                        // shutdown logic placed the entity already, and we are shutting down - do nothing to ensure
+                        // we do not produce any errors here
+                        return;
+                    }
+                    originWorld.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                        TicketType.TELEPORT_HOLD_TICKET, posChunk,
+                        ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                        teleportHoldId
+                    );
+                    List<EntityTreeNode> fullTree = passengerTree.getFullTree();
+                    for (EntityTreeNode node : fullTree) {
+                        node.root.placeSingleSync(originWorld, destination, node, teleportFlags);
+                    }
+
+                    // restore passenger tree
+                    passengerTree.restore();
+                    passengerTree.adjustRiders(true);
+
+                    // invoke post dimension change now
+                    for (EntityTreeNode node : fullTree) {
+                        node.root.postChangeDimension();
+                    }
+
+                    if (teleportComplete != null) {
+                        teleportComplete.accept(Entity.this);
+                    }
+                }
+            );
+        };
+
+        if ((teleportFlags & TELEPORT_FLAG_LOAD_CHUNK) != 0L) {
+            destination.loadChunksForMoveAsync(
+                this.getBoundingBox(), ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
+                (chunkList) -> {
+                    for (net.minecraft.world.level.chunk.ChunkAccess chunk : chunkList) {
+                        destination.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                            TicketType.POST_TELEPORT, chunk.getPos(),
+                            ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.FULL_LOADED_TICKET_LEVEL,
+                            null
+                        );
+                    }
+                    scheduleEntityJoin.run();
+                }
+            );
+        } else {
+            scheduleEntityJoin.run();
+        }
+    }
+
+    protected boolean canTeleportAsync() {
+        return !this.hasNullCallback() && !this.isRemoved() && this.isAlive() && (!(this instanceof net.minecraft.world.entity.LivingEntity livingEntity) || !livingEntity.isSleeping());
+    }
+
+    // Mojang for whatever reason has started storing positions to cache certain physics properties that entities collide with
+    // As usual though, they don't properly do anything to prevent serious desync with respect to the current entity position
+    // We add additional logic to reset these before teleporting to prevent issues with them possibly tripping thread checks.
+    protected void resetStoredPositions() {
+        this.mainSupportingBlockPos = Optional.empty();
+        // this is copied from teleportSetPosition
+        this.movementThisTick.clear();
+    }
+
+    protected void teleportSyncSameRegion(Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
+        if (yaw != null) {
+            this.setYRot(yaw.floatValue());
+            this.setYHeadRot(yaw.floatValue());
+        }
+        if (pitch != null) {
+            this.setXRot(pitch.floatValue());
+        }
+        if (velocity != null) {
+            this.setDeltaMovement(velocity);
+        }
+        this.snapTo(pos.x, pos.y, pos.z);
+        this.setOldPosAndRot();
+        this.resetStoredPositions();
+    }
+
+    protected final void transform(TeleportTransition telpeort) {
+        PositionMoveRotation move = PositionMoveRotation.calculateAbsolute(
+            PositionMoveRotation.of(this), PositionMoveRotation.of(telpeort), telpeort.relatives()
+        );
+        this.transform(
+            move.position(), Float.valueOf(move.yRot()), Float.valueOf(move.xRot()), move.deltaMovement()
+        );
+    }
+
+    protected void transform(Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
+        if (yaw != null) {
+            this.setYRot(yaw.floatValue());
+            this.setYHeadRot(yaw.floatValue());
+        }
+        if (pitch != null) {
+            this.setXRot(pitch.floatValue());
+        }
+        if (velocity != null) {
+            this.setDeltaMovement(velocity);
+        }
+        if (pos != null) {
+            this.setPosRaw(pos.x, pos.y, pos.z);
+        }
+        this.setOldPosAndRot();
+    }
+
+    protected final Entity transformForAsyncTeleport(TeleportTransition telpeort) {
+        PositionMoveRotation move = PositionMoveRotation.calculateAbsolute(
+            PositionMoveRotation.of(this), PositionMoveRotation.of(telpeort), telpeort.relatives()
+        );
+        return this.transformForAsyncTeleport(
+            telpeort.newLevel(), telpeort.position(), Float.valueOf(move.yRot()), Float.valueOf(move.xRot()), move.deltaMovement()
+        );
+    }
+
+    protected Entity transformForAsyncTeleport(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
+        this.removeAfterChangingDimensions(); // remove before so that any CBEntity#getHandle call affects this entity before copying
+
+        Entity copy = this.getType().create(destination, EntitySpawnReason.DIMENSION_TRAVEL);
+        copy.restoreFrom(this);
+        copy.transform(pos, yaw, pitch, velocity);
+        // vanilla code used to call remove _after_ copying, and some stuff is required to be after copy - so add hook here
+        // for example, clearing of inventory after switching dimensions
+        this.postRemoveAfterChangingDimensions();
+
+        return copy;
+    }
+
+    public final boolean teleportAsync(TeleportTransition teleportTarget, long teleportFlags,
+                                       java.util.function.Consumer<Entity> teleportComplete) {
+        PositionMoveRotation move = PositionMoveRotation.calculateAbsolute(PositionMoveRotation.of(this), PositionMoveRotation.of(teleportTarget), teleportTarget.relatives());
+
+        return this.teleportAsync(
+            teleportTarget.newLevel(), move.position(), Float.valueOf(move.yRot()), Float.valueOf(move.xRot()), move.deltaMovement(),
+            teleportTarget.cause(), teleportFlags, teleportComplete
+        );
+    }
+
+    public final boolean teleportAsync(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity,
+                                       org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, long teleportFlags,
+                                       java.util.function.Consumer<Entity> teleportComplete) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot teleport entity async");
+
+        if (!ServerLevel.isInSpawnableBounds(new BlockPos(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getBlockX(pos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getBlockY(pos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getBlockZ(pos)))) {
+            return false;
+        }
+
+        if (!this.canTeleportAsync()) {
+            return false;
+        }
+        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+        if ((teleportFlags & TELEPORT_FLAG_UNMOUNT) == 0L) {
+            for (Entity entity : this.getIndirectPassengers()) {
+                if (!entity.canTeleportAsync()) {
+                    return false;
+                }
+                entity.getBukkitEntity(); // force bukkit entity to be created before TPing
+            }
+        } else {
+            this.unRide();
+        }
+
+        if ((teleportFlags & TELEPORT_FLAG_TELEPORT_PASSENGERS) != 0L) {
+            if (this.isPassenger()) {
+                return false;
+            }
+        } else {
+            if (this.isVehicle() || this.isPassenger()) {
+                return false;
+            }
+        }
+
+        // TODO any events that can modify go HERE
+
+        // check for same region
+        if (destination == this.level()) {
+            Vec3 currPos = this.position();
+            if (
+                destination.regioniser.getRegionAtUnsynchronised(
+                    ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(currPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(currPos)
+                ) == destination.regioniser.getRegionAtUnsynchronised(
+                    ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(pos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(pos)
+                )
+            ) {
+                boolean hasPassengers = !this.passengers.isEmpty();
+                EntityTreeNode passengerTree = this.detachPassengers();
+
+                if (hasPassengers) {
+                    // Note: The client does not accept position updates for controlled entities. So, we must
+                    // perform a lot of tracker updates here to make it all work out.
+
+                    // first, clear the tracker
+                    passengerTree.clearTracker();
+                }
+
+                for (EntityTreeNode entity : passengerTree.getFullTree()) {
+                    entity.root.teleportSyncSameRegion(pos, yaw, pitch, velocity);
+                }
+
+                if (hasPassengers) {
+                    passengerTree.restore();
+                    // re-add to the tracker once the tree is restored
+                    passengerTree.addTracker();
+
+                    // adjust entities to final position
+                    passengerTree.adjustRiders(true);
+
+                    // the tracker clear/add logic is only used in the same region, as the other logic
+                    // performs add/remove from world logic which will also perform add/remove tracker logic
+                }
+
+                if (teleportComplete != null) {
+                    teleportComplete.accept(this);
+                }
+                return true;
+            }
+        }
+
+        EntityTreeNode passengerTree = this.detachPassengers();
+        List<EntityTreeNode> fullPassengerTree = passengerTree.getFullTree();
+        ServerLevel originWorld = (ServerLevel)this.level;
+
+        for (EntityTreeNode node : fullPassengerTree) {
+            node.root.preChangeDimension();
+        }
+
+        for (EntityTreeNode node : fullPassengerTree) {
+            node.root = node.root.transformForAsyncTeleport(destination, pos, yaw, pitch, velocity);
+        }
+
+        passengerTree.root.placeInAsync(originWorld, destination, teleportFlags, passengerTree, teleportComplete);
+
+        return true;
+    }
+
+    public void preChangeDimension() {
+        if (this instanceof Leashable leashable) {
+            leashable.dropLeash();
+        }
+    }
+
+    public void postChangeDimension() {
+        this.resetStoredPositions();
+    }
+
+    protected static enum PortalType {
+        NETHER, END;
+    }
+
+    public boolean endPortalLogicAsync(BlockPos portalPos) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+
+        ServerLevel destination = this.level().getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END ? Level.OVERWORLD : Level.END);
+        if (destination == null) {
+            // wat
+            return false;
+        }
+
+        return this.portalToAsync(destination, portalPos, true, PortalType.END, null);
+    }
+
+    public boolean netherPortalLogicAsync(BlockPos portalPos) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+
+        ServerLevel destination = this.level().getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER);
+        if (destination == null) {
+            // wat
+            return false;
+        }
+
+        return this.portalToAsync(destination, portalPos, true, PortalType.NETHER, null);
+    }
+
+    private static final java.util.concurrent.atomic.AtomicLong CREATE_PORTAL_DOUBLE_CHECK = new java.util.concurrent.atomic.AtomicLong();
+    private static final java.util.concurrent.atomic.AtomicLong TELEPORT_HOLD_TICKET_GEN = new java.util.concurrent.atomic.AtomicLong();
+
+    // To simplify portal logic, in region threading both players
+    // and non-player entities will create portals. By guaranteeing
+    // that the teleportation can take place, we can simply
+    // remove the entity, find/create the portal, and place async.
+    // If we have to worry about whether the entity may not teleport,
+    // we need to first search, then report back, ...
+    protected void findOrCreatePortalAsync(ServerLevel origin, BlockPos originPortal, ServerLevel destination, PortalType type,
+                                           ca.spottedleaf.concurrentutil.completable.CallbackCompletable<TeleportTransition> portalInfoCompletable) {
+        switch (type) {
+            // end portal logic is quite simple, the spawn in the end is fixed and when returning to the overworld
+            // we just select the spawn position
+            case END: {
+                if (destination.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END) {
+                    BlockPos targetPos = ServerLevel.END_SPAWN_POINT;
+                    // need to load chunks so we can create the platform
+                    destination.moonrise$loadChunksAsync(
+                        targetPos, 16, // load 16 blocks to be safe from block physics
+                        ca.spottedleaf.concurrentutil.util.Priority.HIGH,
+                        (chunks) -> {
+                            net.minecraft.world.level.levelgen.feature.EndPlatformFeature.createEndPlatform(destination, targetPos.below(), true, null);
+
+                            // the portal obsidian is placed at targetPos.y - 2, so if we want to place the entity
+                            // on the obsidian, we need to spawn at targetPos.y - 1
+                            portalInfoCompletable.complete(
+                                new net.minecraft.world.level.portal.TeleportTransition(
+                                    destination, Vec3.atBottomCenterOf(targetPos.below()), Vec3.ZERO, Direction.WEST.toYRot(), 0.0f,
+                                    Relative.union(Relative.DELTA, Set.of(Relative.X_ROT)),
+                                    TeleportTransition.PLAY_PORTAL_SOUND.then(TeleportTransition.PLACE_PORTAL_TICKET),
+                                    org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_PORTAL
+                                )
+                            );
+                        }
+                    );
+                } else {
+                    BlockPos spawnPos = destination.getRespawnData().pos();
+                    // need to load chunk for heightmap
+                    destination.moonrise$loadChunksAsync(
+                        spawnPos, 0,
+                        ca.spottedleaf.concurrentutil.util.Priority.HIGH,
+                        (chunks) -> {
+                            BlockPos adjustedSpawn = destination.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, spawnPos);
+
+                            // done
+                            portalInfoCompletable.complete(
+                                new net.minecraft.world.level.portal.TeleportTransition(
+                                    destination, Vec3.atBottomCenterOf(adjustedSpawn), Vec3.ZERO, 0.0f, 0.0f,
+                                    Relative.union(Relative.DELTA, Relative.ROTATION),
+                                    TeleportTransition.PLAY_PORTAL_SOUND.then(TeleportTransition.PLACE_PORTAL_TICKET),
+                                    org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_PORTAL
+                                )
+                            );
+                        }
+                    );
+                }
+
+                break;
+            }
+            // for the nether logic, we need to first load the chunks in radius to empty (so that POI is created)
+            // then we can search for an existing portal using the POI routines
+            // if we don't find a portal, then we bring the chunks in the create radius to full and
+            // create it
+            case NETHER: {
+                // hoisted from the create fallback, so that we can avoid the sync load later if we need it
+                BlockState originalPortalBlock = origin.getBlockStateIfLoaded(originPortal);
+                Direction.Axis originalPortalDirection = originalPortalBlock == null ? Direction.Axis.X :
+                    originalPortalBlock.getOptionalValue(net.minecraft.world.level.block.NetherPortalBlock.AXIS).orElse(Direction.Axis.X);
+                BlockUtil.FoundRectangle originalPortalRectangle =
+                    originalPortalBlock == null || !originalPortalBlock.hasProperty(net.minecraft.world.level.block.state.properties.BlockStateProperties.HORIZONTAL_AXIS)
+                        ? null
+                        : BlockUtil.getLargestRectangleAround(
+                            originPortal, originalPortalDirection, 21, Direction.Axis.Y, 21,
+                            (blockpos) -> {
+                                return origin.getBlockStateFromEmptyChunkIfLoaded(blockpos) == originalPortalBlock;
+                            }
+                        );
+
+                boolean destinationIsNether = destination.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER;
+
+                int portalSearchRadius = origin.paperConfig().environment.portalSearchVanillaDimensionScaling && destinationIsNether ?
+                    (int)(destination.paperConfig().environment.portalSearchRadius / destination.dimensionType().coordinateScale()) :
+                    destination.paperConfig().environment.portalSearchRadius;
+                int portalCreateRadius = destination.paperConfig().environment.portalCreateRadius;
+
+                WorldBorder destinationBorder = destination.getWorldBorder();
+                double dimensionScale = net.minecraft.world.level.dimension.DimensionType.getTeleportationScale(origin.dimensionType(), destination.dimensionType());
+                BlockPos targetPos = destination.getWorldBorder().clampToBounds(this.getX() * dimensionScale, this.getY(), this.getZ() * dimensionScale);
+
+                ca.spottedleaf.concurrentutil.completable.CallbackCompletable<BlockUtil.FoundRectangle> portalFound
+                    = new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+
+                // post portal find/create logic
+                portalFound.addWaiter(
+                    (BlockUtil.FoundRectangle portal, Throwable thr) -> {
+                        // no portal could be created
+                        if (portal == null) {
+                            portalInfoCompletable.complete(
+                                new TeleportTransition(destination, Vec3.atCenterOf(targetPos), Vec3.ZERO,
+                                    90.0f, 0.0f,
+                                    TeleportTransition.PLAY_PORTAL_SOUND.then(TeleportTransition.PLACE_PORTAL_TICKET))
+                            );
+                            return;
+                        }
+
+                        Vec3 relativePos = originalPortalRectangle == null ?
+                            new Vec3(0.5, 0.0, 0.0) :
+                            Entity.this.getRelativePortalPosition(originalPortalDirection, originalPortalRectangle);
+
+                        portalInfoCompletable.complete(
+                            net.minecraft.world.level.block.NetherPortalBlock.createDimensionTransition(
+                                destination, portal, originalPortalDirection, relativePos,
+                                Entity.this, TeleportTransition.PLAY_PORTAL_SOUND.then(TeleportTransition.PLACE_PORTAL_TICKET)
+                            )
+                        );
+                    }
+                );
+
+                // kick off search for existing portal or creation
+                destination.moonrise$loadChunksAsync(
+                    // add 32 so that the final search for a portal frame doesn't load any chunks
+                    targetPos, portalSearchRadius + 32,
+                    net.minecraft.world.level.chunk.status.ChunkStatus.EMPTY,
+                    ca.spottedleaf.concurrentutil.util.Priority.HIGH,
+                    (chunks) -> {
+                        BlockUtil.FoundRectangle portal =
+                            net.minecraft.world.level.block.NetherPortalBlock.findPortalAround(destination, targetPos, destinationBorder, portalSearchRadius);
+                        if (portal != null) {
+                            portalFound.complete(portal);
+                            return;
+                        }
+
+                        // add tickets so that we can re-search for a portal once the chunks are loaded
+                        Long ticketId = Long.valueOf(CREATE_PORTAL_DOUBLE_CHECK.getAndIncrement());
+                        for (net.minecraft.world.level.chunk.ChunkAccess chunk : chunks) {
+                            destination.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                                TicketType.NETHER_PORTAL_DOUBLE_CHECK, chunk.getPos(),
+                                ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                                ticketId
+                            );
+                        }
+
+                        // no portal found - create one
+                        destination.moonrise$loadChunksAsync(
+                            targetPos, portalCreateRadius + 32,
+                            ca.spottedleaf.concurrentutil.util.Priority.HIGH,
+                            (chunks2) -> {
+                                // don't need the tickets anymore
+                                // note: we expect removeTicketsAtLevel to add an unknown ticket for us automatically
+                                // if the ticket level were to decrease
+                                for (net.minecraft.world.level.chunk.ChunkAccess chunk : chunks) {
+                                    destination.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                                        TicketType.NETHER_PORTAL_DOUBLE_CHECK, chunk.getPos(),
+                                        ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                                        ticketId
+                                    );
+                                }
+
+                                // when two entities portal at the same time, it is possible that both entities reach this
+                                // part of the code - and create a double portal
+                                // to fix this, we just issue another search to try and see if another entity created
+                                // a portal nearby
+                                BlockUtil.FoundRectangle existingTryAgain =
+                                    net.minecraft.world.level.block.NetherPortalBlock.findPortalAround(destination, targetPos, destinationBorder, portalSearchRadius);
+                                if (existingTryAgain != null) {
+                                    portalFound.complete(existingTryAgain);
+                                    return;
+                                }
+
+                                // we do not have the correct entity reference here
+                                BlockUtil.FoundRectangle createdPortal =
+                                    destination.getPortalForcer().createPortal(targetPos, originalPortalDirection, null, portalCreateRadius).orElse(null);
+                                // if it wasn't created, passing null is expected here
+                                portalFound.complete(createdPortal);
+                            }
+                        );
+                    }
+                );
+                break;
+            }
+            default: {
+                throw new IllegalStateException("Unknown portal type " + type);
+            }
+        }
+    }
+
+    public boolean canPortalAsync(ServerLevel to, boolean considerPassengers) {
+        return this.canPortalAsync(to, considerPassengers, false);
+    }
+
+    protected boolean canPortalAsync(ServerLevel to, boolean considerPassengers, boolean skipPassengerCheck) {
+        if (considerPassengers) {
+            if (!skipPassengerCheck && this.isPassenger()) {
+                return false;
+            }
+        } else {
+            if (this.isVehicle() || (!skipPassengerCheck && this.isPassenger())) {
+                return false;
+            }
+        }
+        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+        if (!this.canTeleportAsync()) {
+            return false;
+        }
+        if (considerPassengers) {
+            for (Entity entity : this.passengers) {
+                if (!entity.canPortalAsync(to, true, true)) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    protected void prePortalLogic(ServerLevel origin, ServerLevel destination, PortalType type) {
+
+    }
+
+    protected boolean portalToAsync(ServerLevel destination, BlockPos portalPos, boolean takePassengers,
+                                    PortalType type, java.util.function.Consumer<Entity> teleportComplete) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        if (!this.canPortalAsync(destination, takePassengers)) {
+            return false;
+        }
+
+        Vec3 initialPosition = this.position();
+        ChunkPos initialPositionChunk = new ChunkPos(
+            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(initialPosition),
+            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(initialPosition)
+        );
+
+        // first, remove entity/passengers from world
+        EntityTreeNode passengerTree = this.detachPassengers();
+        List<EntityTreeNode> fullPassengerTree = passengerTree.getFullTree();
+        ServerLevel originWorld = (ServerLevel)this.level;
+
+        for (EntityTreeNode node : fullPassengerTree) {
+            node.root.preChangeDimension();
+            node.root.prePortalLogic(originWorld, destination, type);
+        }
+
+        for (EntityTreeNode node : fullPassengerTree) {
+            // we will update pos/rot/speed later
+            node.root = node.root.transformForAsyncTeleport(destination, null, null, null, null);
+            // set portal cooldown
+            node.root.setPortalCooldown();
+        }
+
+        // ensure the region is always ticking in case of a shutdown
+        // otherwise, the shutdown will not be able to complete the shutdown as it requires a ticking region
+        Long teleportHoldId = Long.valueOf(TELEPORT_HOLD_TICKET_GEN.getAndIncrement());
+        originWorld.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+            TicketType.TELEPORT_HOLD_TICKET, initialPositionChunk,
+            ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+            teleportHoldId
+        );
+
+        ServerLevel.PendingTeleport beforeFindDestination = new ServerLevel.PendingTeleport(passengerTree, initialPosition);
+        originWorld.pushPendingTeleport(beforeFindDestination);
+
+        ca.spottedleaf.concurrentutil.completable.CallbackCompletable<TeleportTransition> portalInfoCompletable
+            = new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+
+        portalInfoCompletable.addWaiter((TeleportTransition info, Throwable throwable) -> {
+            if (!originWorld.removePendingTeleport(beforeFindDestination)) {
+                // the shutdown thread has placed us back into the origin world at the original position
+                // we just have to abandon this teleport to prevent duplication
+                return;
+            }
+            originWorld.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                TicketType.TELEPORT_HOLD_TICKET, initialPositionChunk,
+                ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
+                teleportHoldId
+            );
+            // adjust passenger tree to final pos/rot/speed
+            for (EntityTreeNode node : fullPassengerTree) {
+                node.root.transform(info);
+            }
+
+            // place
+            passengerTree.root.placeInAsync(
+                originWorld, destination, Entity.TELEPORT_FLAG_LOAD_CHUNK | (takePassengers ? Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS : 0L),
+                passengerTree,
+                (Entity teleported) -> {
+                    if (info.postTeleportTransition() != null) {
+                        info.postTeleportTransition().onTransition(teleported);
+                    }
+
+                    if (teleportComplete != null) {
+                        teleportComplete.accept(teleported);
+                    }
+                }
+            );
+        });
+
+
+        passengerTree.root.findOrCreatePortalAsync(originWorld, portalPos, destination, type, portalInfoCompletable);
+
+        return true;
+    }
+    // Folia end - region threading
+
     public @Nullable Entity teleport(TeleportTransition teleportTransition) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        }
+        // Folia end - region threading
         // Paper start - Fix item duplication and teleport issues
         if ((!this.isAlive() || !this.valid) && (teleportTransition.newLevel() != this.level)) {
             LOGGER.warn("Illegal Entity Teleport {} to {}:{}", this, teleportTransition.newLevel(), teleportTransition.position(), new Throwable());
@@ -4197,6 +5012,12 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
     }
 
+    // Folia start - region threading - move inventory clearing until after the dimension change
+    protected void postRemoveAfterChangingDimensions() {
+
+    }
+    // Folia end - region threading - move inventory clearing until after the dimension change
+
     protected void removeAfterChangingDimensions() {
         this.setRemoved(Entity.RemovalReason.CHANGED_DIMENSION, null); // CraftBukkit - add Bukkit remove cause
         if (this instanceof Leashable leashable && leashable.isLeashed()) { // Paper - only call if it is leashed
@@ -4497,6 +5318,12 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     public void startSeenByPlayer(ServerPlayer player) {
+        // Folia start - region threading
+        if (player.getCamera() == this) {
+            // set camera again
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundSetCameraPacket(this));
+        }
+        // Folia end - region threading
     }
 
     public void stopSeenByPlayer(ServerPlayer player) {
@@ -4506,6 +5333,12 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             new io.papermc.paper.event.player.PlayerUntrackEntityEvent(player.getBukkitEntity(), this.getBukkitEntity()).callEvent();
         }
         // Paper end - entity tracking events
+        // Folia start - region threading
+        if (player.getCamera() == this) {
+            // unset camera, the player tick method should TP us close enough again to invoke startSeenByPlayer
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundSetCameraPacket(player));
+        }
+        // Folia end - region threading
     }
 
     public float rotate(Rotation transformRotation) {
@@ -5032,7 +5865,8 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             return;
         }
         // Paper end - Block invalid positions and bounding box
-        if (this.position.x != x || this.position.y != y || this.position.z != z) {
+        boolean posChanged = this.position.x != x || this.position.y != y || this.position.z != z;
+        if (posChanged) { // Folia - region threading
             synchronized (this.posLock) { // Paper - detailed watchdog information
             this.position = new Vec3(x, y, z);
             } // Paper - detailed watchdog information
@@ -5065,7 +5899,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
         // Paper start - Block invalid positions and bounding box; don't allow desync of pos and AABB
         // hanging has its own special logic
-        if (!(this instanceof net.minecraft.world.entity.decoration.HangingEntity) && (forceBoundingBoxUpdate || this.position.x != x || this.position.y != y || this.position.z != z)) {
+        if (!(this instanceof net.minecraft.world.entity.decoration.HangingEntity) && (forceBoundingBoxUpdate || posChanged)) {
             this.setBoundingBox(this.makeBoundingBox());
         }
         // Paper end - Block invalid positions and bounding box
@@ -5171,6 +6005,12 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         return this.removalReason != null;
     }
 
+    // Folia start - region threading
+    public final boolean hasNullCallback() {
+        return this.levelCallback == EntityInLevelCallback.NULL;
+    }
+    // Folia end - region threading
+
     public Entity.@Nullable RemovalReason getRemovalReason() {
         return this.removalReason;
     }
@@ -5185,6 +6025,9 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         // Paper end - rewrite chunk system
         org.bukkit.craftbukkit.event.CraftEventFactory.callEntityRemoveEvent(this, cause); // CraftBukkit
         final boolean alreadyRemoved = this.removalReason != null; // Paper - Folia schedulers
+        // Folia start - region threading
+        this.preRemove(removalReason);
+        // Folia end - region threading
         if (this.removalReason == null) {
             this.removalReason = removalReason;
         }
@@ -5208,6 +6051,10 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         this.removalReason = null;
     }
 
+    // Folia start - region threading
+    protected void preRemove(Entity.RemovalReason reason) {}
+    // Folia end - region threading
+
     // Paper start - Folia schedulers
     /**
      * Invoked only when the entity is truly removed from the server, never to be added to any world.
@@ -5219,7 +6066,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     // Paper end - Folia schedulers
     // Paper start - optimise Folia entity scheduler
     public final void registerScheduler() {
-        this.getBukkitEntity().taskScheduler.registerTo(net.minecraft.server.MinecraftServer.getServer().entitySchedulerTickList);
+        this.getBukkitEntity().taskScheduler.registerTo(io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().entitySchedulerTickList); // Folia - region threading
     }
     // Paper end - optimise Folia entity scheduler
 
diff --git a/net/minecraft/world/entity/EntityReference.java b/net/minecraft/world/entity/EntityReference.java
index 9b5b4d26e2b059203f0245bf2110182378ccb8a6..11038db859b118c34f02a45cf497187406f21ddc 100644
--- a/net/minecraft/world/entity/EntityReference.java
+++ b/net/minecraft/world/entity/EntityReference.java
@@ -16,44 +16,44 @@ import net.minecraft.world.level.storage.ValueInput;
 import net.minecraft.world.level.storage.ValueOutput;
 import org.jspecify.annotations.Nullable;
 
-public final class EntityReference<StoredEntityType extends UniquelyIdentifyable> {
+public final class EntityReference<StoredEntityType extends Entity> { // Folia - region threading - force Entity Type
     private static final Codec<? extends EntityReference<?>> CODEC = UUIDUtil.CODEC.xmap(EntityReference::new, EntityReference::getUUID);
     private static final StreamCodec<ByteBuf, ? extends EntityReference<?>> STREAM_CODEC = UUIDUtil.STREAM_CODEC
         .map(EntityReference::new, EntityReference::getUUID);
-    private Either<UUID, StoredEntityType> entity;
+    private Either<UUID, org.bukkit.craftbukkit.entity.CraftEntity> entity; // Folia - region threading - force usage of CraftEntity
 
-    public static <Type extends UniquelyIdentifyable> Codec<EntityReference<Type>> codec() {
+    public static <Type extends Entity> Codec<EntityReference<Type>> codec() { // Folia - region threading - force Entity Type
         return (Codec<EntityReference<Type>>)CODEC;
     }
 
-    public static <Type extends UniquelyIdentifyable> StreamCodec<ByteBuf, EntityReference<Type>> streamCodec() {
+    public static <Type extends Entity> StreamCodec<ByteBuf, EntityReference<Type>> streamCodec() { // Folia - region threading - force Entity Type
         return (StreamCodec<ByteBuf, EntityReference<Type>>)STREAM_CODEC;
     }
 
     private EntityReference(StoredEntityType entity) {
-        this.entity = Either.right(entity);
+        this.entity = Either.right(entity.getBukkitEntity()); // Folia - region threading - force usage of CraftEntity
     }
 
     private EntityReference(UUID uuid) {
         this.entity = Either.left(uuid);
     }
 
-    public static <T extends UniquelyIdentifyable> @Nullable EntityReference<T> of(@Nullable T entity) {
+    public static <T extends Entity> @Nullable EntityReference<T> of(@Nullable T entity) { // Folia - region threading - force Entity Type
         return entity != null ? new EntityReference<>(entity) : null;
     }
 
-    public static <T extends UniquelyIdentifyable> EntityReference<T> of(UUID uuid) {
+    public static <T extends Entity> EntityReference<T> of(UUID uuid) { // Folia - region threading - force Entity Type
         return new EntityReference<>(uuid);
     }
 
     public UUID getUUID() {
-        return this.entity.map(uuid -> (UUID)uuid, UniquelyIdentifyable::getUUID);
+        return this.entity.map(uuid -> (UUID)uuid, org.bukkit.craftbukkit.entity.CraftEntity::getUniqueId); // Folia - region threading - force usage of CraftEntity
     }
 
     public @Nullable StoredEntityType getEntity(UUIDLookup<? extends UniquelyIdentifyable> uuidLookup, Class<StoredEntityType> entityClass) {
-        Optional<StoredEntityType> optional = this.entity.right();
+        Optional<org.bukkit.craftbukkit.entity.CraftEntity> optional = this.entity.right(); // Folia - region threading - force usage of CraftEntity
         if (optional.isPresent()) {
-            StoredEntityType uniquelyIdentifyable = optional.get();
+            StoredEntityType uniquelyIdentifyable = (StoredEntityType)optional.get().getHandleRaw(); // Folia - region threading - force usage of CraftEntity
             if (!uniquelyIdentifyable.isRemoved()) {
                 return uniquelyIdentifyable;
             }
@@ -65,7 +65,7 @@ public final class EntityReference<StoredEntityType extends UniquelyIdentifyable
         if (optional1.isPresent()) {
             StoredEntityType uniquelyIdentifyable1 = this.resolve(uuidLookup.lookup(optional1.get()), entityClass);
             if (uniquelyIdentifyable1 != null && !uniquelyIdentifyable1.isRemoved()) {
-                this.entity = Either.right(uniquelyIdentifyable1);
+                this.entity = Either.right(uniquelyIdentifyable1.getBukkitEntity()); // Folia - region threading - force usage of CraftEntity
                 return uniquelyIdentifyable1;
             }
         }
@@ -97,7 +97,7 @@ public final class EntityReference<StoredEntityType extends UniquelyIdentifyable
         }
     }
 
-    public static <StoredEntityType extends UniquelyIdentifyable> @Nullable StoredEntityType get(
+    public static <StoredEntityType extends Entity> @Nullable StoredEntityType get( // Folia - region threading - force Entity Type
         @Nullable EntityReference<StoredEntityType> reference, Level level, Class<StoredEntityType> entityClass
     ) {
         return reference != null ? reference.getEntity(level, entityClass) : null;
@@ -115,11 +115,11 @@ public final class EntityReference<StoredEntityType extends UniquelyIdentifyable
         return get(reference, level, Player.class);
     }
 
-    public static <StoredEntityType extends UniquelyIdentifyable> @Nullable EntityReference<StoredEntityType> read(ValueInput input, String key) {
+    public static <StoredEntityType extends Entity> @Nullable EntityReference<StoredEntityType> read(ValueInput input, String key) { // Folia - region threading - force Entity Type
         return input.read(key, EntityReference.<StoredEntityType>codec()).orElse(null);
     }
 
-    public static <StoredEntityType extends UniquelyIdentifyable> @Nullable EntityReference<StoredEntityType> readWithOldOwnerConversion(
+    public static <StoredEntityType extends Entity> @Nullable EntityReference<StoredEntityType> readWithOldOwnerConversion( // Folia - region threading - force Entity Type
         ValueInput input, String key, Level level
     ) {
         Optional<UUID> optional = input.read(key, UUIDUtil.CODEC);
@@ -143,7 +143,7 @@ public final class EntityReference<StoredEntityType extends UniquelyIdentifyable
 
     // Paper start - utility for reading an entity from a nullable entity reference via a UUIDLookup
     @Nullable
-    public static <StoredEntityType extends UniquelyIdentifyable> StoredEntityType getEntity(
+    public static <StoredEntityType extends Entity> StoredEntityType getEntity( // Folia - region threading - force Entity Type
         final @Nullable EntityReference<StoredEntityType> ref,
         final UUIDLookup<? extends UniquelyIdentifyable> uuidLookup,
         final Class<StoredEntityType> entityClass
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 730bf0cfdc9698a74b269b76fed614e08e058153..d5bd641094730571eb65110c84b1df287288be3d 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -265,7 +265,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     private BlockPos lastPos;
     private Optional<BlockPos> lastClimbablePos = Optional.empty();
     private @Nullable DamageSource lastDamageSource;
-    private long lastDamageStamp;
+    private long lastDamageStamp = Long.MIN_VALUE; // Folia - region threading
     protected int autoSpinAttackTicks;
     protected float autoSpinAttackDmg;
     protected @Nullable ItemStack autoSpinAttackItemStack;
@@ -291,6 +291,26 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
     public int invulnerableDuration = LivingEntity.INVULNERABLE_DURATION; // Paper - configurable invulnerable duration
     // CraftBukkit end
+    // Folia start - region threading
+    @Override
+    public void updateTicks(long fromTickOffset, long fromRedstoneTimeOffset) {
+        super.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+        if (this.lastDamageStamp != Long.MIN_VALUE) {
+            this.lastDamageStamp += fromRedstoneTimeOffset;
+        }
+    }
+
+    @Override
+    public boolean canBeSpectated() {
+        return super.canBeSpectated() && this.getHealth() > 0.0F;
+    }
+
+    @Override
+    protected void resetStoredPositions() {
+        super.resetStoredPositions();
+        this.lastClimbablePos = Optional.empty();
+    }
+    // Folia end - region threading
 
     protected LivingEntity(EntityType<? extends LivingEntity> type, Level level) {
         super(type, level);
@@ -492,7 +512,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
         if (this.isDeadOrDying() && this.level().shouldTickDeath(this)) {
             this.tickDeath();
-        }
+        } else { this.broadcastedDeath = false; } // Folia - region threading
 
         if (this.lastHurtByPlayerMemoryTime > 0) {
             this.lastHurtByPlayerMemoryTime--;
@@ -583,11 +603,13 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         return true;
     }
 
+    public boolean broadcastedDeath = false; // Folia - region threading
     protected void tickDeath() {
         this.deathTime++;
         if (this.deathTime >= 20 && !this.level().isClientSide() && !this.isRemoved()) {
-            this.level().broadcastEntityEvent(this, EntityEvent.POOF);
-            this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DEATH); // CraftBukkit - add Bukkit remove cause
+            this.level().broadcastEntityEvent(this, EntityEvent.POOF); this.broadcastedDeath = true; // Folia - region threading - death has been broadcasted
+            if (!(this instanceof ServerPlayer)) this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DEATH); // CraftBukkit - add Bukkit remove cause // Folia - region threading - don't remove, we want the tick scheduler to be running
+            if ((this instanceof ServerPlayer)) this.unRide(); // Folia - region threading - unmount player when dead
         }
     }
 
@@ -885,7 +907,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         // CraftBukkit end
         this.setHealth(input.getFloatOr("Health", this.getMaxHealth()));
         this.hurtTime = input.getShortOr("HurtTime", (short)0);
-        this.deathTime = input.getShortOr("DeathTime", (short)0);
+        this.deathTime = input.getShortOr("DeathTime", (short)0); this.broadcastedDeath = false; // Folia - region threading
         this.lastHurtByMobTimestamp = input.getIntOr("HurtByTimestamp", 0);
         input.getString("Team").ifPresent(string -> {
             Scoreboard scoreboard = this.level().getScoreboard();
@@ -1160,6 +1182,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     public boolean addEffect(MobEffectInstance effectInstance, @Nullable Entity entity, EntityPotionEffectEvent.Cause cause, boolean fireEvent) {
         // Paper end - Don't fire sync event during generation
         // org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot // Paper - move to API
+        if (!this.hasNullCallback()) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add effects to entities asynchronously"); // Folia - region threading
         if (this.isTickingEffects) {
             this.effectsToProcess.add(new ProcessableEffect(effectInstance, cause));
             return true;
@@ -1545,7 +1568,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             boolean flag2 = !flag; // CraftBukkit - Ensure to return false if damage is blocked
             if (flag2) {
                 this.lastDamageSource = damageSource;
-                this.lastDamageStamp = this.level().getGameTime();
+                this.lastDamageStamp = this.level().getRedstoneGameTime(); // Folia - region threading
 
                 for (MobEffectInstance mobEffectInstance : this.getActiveEffects()) {
                     mobEffectInstance.onMobHurt(level, this, damageSource, amount);
@@ -1773,7 +1796,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     }
 
     public @Nullable DamageSource getLastDamageSource() {
-        if (this.level().getGameTime() - this.lastDamageStamp > 40L) {
+        if (this.level().getRedstoneGameTime() - this.lastDamageStamp > 40L || this.lastDamageStamp == Long.MIN_VALUE) { // Folia - region threading
             this.lastDamageSource = null;
         }
 
@@ -2551,10 +2574,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     }
 
     public @Nullable LivingEntity getKillCredit() {
-        if (this.lastHurtByPlayer != null) {
+        if (this.lastHurtByPlayer != null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.lastHurtByPlayer.getEntity(this.level(), Player.class))) { // Folia - region threading
             return this.lastHurtByPlayer.getEntity(this.level(), Player.class);
         } else {
-            return this.lastHurtByMob != null ? this.lastHurtByMob.getEntity(this.level(), LivingEntity.class) : null;
+            return this.lastHurtByMob != null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.lastHurtByMob.getEntity(this.level(), LivingEntity.class)) ? this.lastHurtByMob.getEntity(this.level(), LivingEntity.class) : null; // Folia - region threading
         }
     }
 
@@ -2637,7 +2660,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         }
 
         this.lastDamageSource = damageSource;
-        this.lastDamageStamp = this.level().getGameTime();
+        this.lastDamageStamp = this.level().getRedstoneGameTime(); // Folia - region threading
     }
 
     @Override
@@ -3729,7 +3752,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         this.pushEntities();
         profilerFiller.pop();
         // Paper start - Add EntityMoveEvent
-        if (((ServerLevel) this.level()).hasEntityMoveEvent && !(this instanceof Player)) {
+        if (((ServerLevel) this.level()).getCurrentWorldData().hasEntityMoveEvent && !(this instanceof Player)) { // Folia - region threading
             if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
                 Location from = new Location(this.level().getWorld(), this.xo, this.yo, this.zo, this.yRotO, this.xRotO);
                 Location to = new Location(this.level().getWorld(), this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
@@ -4424,7 +4447,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         boolean flag = false;
         BlockPos blockPos = BlockPos.containing(x, y, z);
         Level level = this.level();
-        if (level.hasChunkAt(blockPos)) {
+        if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((ServerLevel)level, blockPos) && level.hasChunkAt(blockPos)) { // Folia - region threading
             boolean flag1 = false;
 
             while (!flag1 && blockPos.getY() > level.getMinY()) {
@@ -4586,6 +4609,11 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 this.setXRot(0.0F);
             }
         });
+        // Folia start - separate out
+        this.stopSleepingRaw();
+    }
+    public void stopSleepingRaw() {
+        // Folia end - separate out
         Vec3 vec3 = this.position();
         this.setPose(Pose.STANDING);
         this.setPos(vec3.x, vec3.y, vec3.z);
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index a6ed274cb0cf86a1ca93588f946ed52a58354546..9168ec5cd066161a11eac9ed9d59dbfa5ea9988c 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -254,9 +254,21 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
 
     @Override
     public @Nullable LivingEntity getTarget() {
+        // Folia start - region threading
+        if (this.target != null && (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.target) || this.target.isRemoved())) {
+            this.target = null;
+            return null;
+        }
+        // Folia end - region threading
         return this.target;
     }
 
+    // Folia start - region threading
+    public LivingEntity getTargetRaw() {
+        return this.target;
+    }
+    // Folia end - region threading
+
     protected final @Nullable LivingEntity getTargetFromBrain() {
         return this.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET).orElse(null);
     }
@@ -267,7 +279,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     }
 
     public boolean setTarget(@Nullable LivingEntity target, EntityTargetEvent.@Nullable TargetReason reason) {
-        if (this.getTarget() == target) {
+        if (this.getTargetRaw() == target) { // Folia - region threading
             return false;
         }
         if (reason != null) {
@@ -1619,10 +1631,10 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.goalSelector.removeAllGoals(filter);
     }
 
+    // Folia start - region threading
     @Override
-    protected void removeAfterChangingDimensions() {
-        super.removeAfterChangingDimensions();
-
+    protected void postRemoveAfterChangingDimensions() {
+        super.postRemoveAfterChangingDimensions();
         for (EquipmentSlot equipmentSlot : EquipmentSlot.VALUES) {
             ItemStack itemBySlot = this.getItemBySlot(equipmentSlot);
             if (!itemBySlot.isEmpty()) {
@@ -1630,6 +1642,20 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             }
         }
     }
+    // Folia end - region threading
+
+    @Override
+    protected void removeAfterChangingDimensions() {
+        super.removeAfterChangingDimensions();
+        // Folia start - region threading - move inventory clearing until after the dimension change - move into postRemoveAfterChangingDimensions
+//        for (EquipmentSlot equipmentSlot : EquipmentSlot.VALUES) {
+//            ItemStack itemBySlot = this.getItemBySlot(equipmentSlot);
+//            if (!itemBySlot.isEmpty()) {
+//                itemBySlot.setCount(0);
+//            }
+//        }
+        // Folia end - region threading - move inventory clearing until after the dimension change - move into postRemoveAfterChangingDimensions
+    }
 
     @Override
     public @Nullable ItemStack getPickResult() {
diff --git a/net/minecraft/world/entity/PortalProcessor.java b/net/minecraft/world/entity/PortalProcessor.java
index 4e69e32ad000b8c02e44c3ffce24ff5e3c090a2f..0a019024ff9a5c4ae8067f0e2cfd2c9cdbdce0ea 100644
--- a/net/minecraft/world/entity/PortalProcessor.java
+++ b/net/minecraft/world/entity/PortalProcessor.java
@@ -32,6 +32,12 @@ public class PortalProcessor {
         return this.portal.getPortalDestination(level, entity, this.entryPosition);
     }
 
+    // Folia start - region threading
+    public boolean portalAsync(ServerLevel sourceWorld, Entity portalTarget) {
+        return this.portal.portalAsync(sourceWorld, portalTarget, this.entryPosition);
+    }
+    // Folia end - region threading
+
     public Portal.Transition getPortalLocalTransition() {
         return this.portal.getLocalTransition();
     }
diff --git a/net/minecraft/world/entity/TamableAnimal.java b/net/minecraft/world/entity/TamableAnimal.java
index c40455773ada45a560462c22f429ad82c9f9e8f0..f6b921ce3674d3c2bf963b913045a3c83c6bbf08 100644
--- a/net/minecraft/world/entity/TamableAnimal.java
+++ b/net/minecraft/world/entity/TamableAnimal.java
@@ -242,6 +242,11 @@ public abstract class TamableAnimal extends Animal implements OwnableEntity {
     public void tryToTeleportToOwner() {
         LivingEntity owner = this.getOwner();
         if (owner != null) {
+            // Folia start - region threading
+            if (owner.isRemoved() || owner.level() != this.level()) {
+                return;
+            }
+            // Folia end - region threading
             this.teleportToAroundBlockPos(owner.blockPosition());
         }
     }
@@ -274,7 +279,22 @@ public abstract class TamableAnimal extends Animal implements OwnableEntity {
                 return false;
             }
             org.bukkit.Location to = event.getTo();
-            this.snapTo(to.getX(), to.getY(), to.getZ(), to.getYaw(), to.getPitch());
+            // Folia start - region threading - can't teleport here, we may be removed by teleport logic - delay until next tick
+            // also, use teleportAsync so that crossing region boundaries will not blow up
+            org.bukkit.Location finalTo = to;
+            Level sourceWorld = this.level();
+            this.getBukkitEntity().taskScheduler.schedule((TamableAnimal nmsEntity) -> {
+                if (nmsEntity.level() == sourceWorld) {
+                    nmsEntity.teleportAsync(
+                        (net.minecraft.server.level.ServerLevel)nmsEntity.level(),
+                        new net.minecraft.world.phys.Vec3(finalTo.getX(), finalTo.getY(), finalTo.getZ()),
+                        Float.valueOf(finalTo.getYaw()), Float.valueOf(finalTo.getPitch()),
+                        net.minecraft.world.phys.Vec3.ZERO, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN, Entity.TELEPORT_FLAG_LOAD_CHUNK,
+                        null
+                    );
+                }
+            }, null, 1L);
+            // Folia end - region threading - can't teleport here, we may be removed by teleport logic - delay until next tick
             // CraftBukkit end
             this.navigation.stop();
             return true;
diff --git a/net/minecraft/world/entity/ai/Brain.java b/net/minecraft/world/entity/ai/Brain.java
index a8b076d95ca7bbdbdb6f32bd464cf77d9894dcba..11432097b02ddc8c8a2c0e29e9a5bd03c82dd1d4 100644
--- a/net/minecraft/world/entity/ai/Brain.java
+++ b/net/minecraft/world/entity/ai/Brain.java
@@ -431,9 +431,17 @@ public class Brain<E extends LivingEntity> {
     }
 
     public void stopAll(ServerLevel level, E owner) {
+        // Folia start - region threading
+        List<BehaviorControl<? super E>> behaviors = this.getRunningBehaviors();
+        if (behaviors.isEmpty()) {
+            // avoid calling getGameTime, as this may be called while portalling an entity - which will cause
+            // the world data retrieval to fail
+            return;
+        }
+        // Folia end - region threading
         long gameTime = owner.level().getGameTime();
 
-        for (BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
+        for (BehaviorControl<? super E> behaviorControl : behaviors) { // Folia - region threading
             behaviorControl.doStop(level, owner, gameTime);
         }
     }
diff --git a/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java b/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
index eefc8f835f8818407612eadf3f2df5730a0bbe97..d4ceb6980794e4abf669a227020aa3899a9735ad 100644
--- a/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
+++ b/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
@@ -45,12 +45,14 @@ public class GoToPotentialJobSite extends Behavior<Villager> {
             BlockPos blockPos = globalPos.pos();
             ServerLevel level1 = level.getServer().getLevel(globalPos.dimension());
             if (level1 != null) {
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(level1, blockPos.getX() >> 4, blockPos.getZ() >> 4, () -> { // Folia - region threading
                 PoiManager poiManager = level1.getPoiManager();
                 if (poiManager.exists(blockPos, holder -> true)) {
                     poiManager.release(blockPos);
                 }
 
                 level.debugSynchronizers().updatePoi(blockPos);
+                }); // Folia - region threading
             }
         });
         entity.getBrain().eraseMemory(MemoryModuleType.POTENTIAL_JOB_SITE);
diff --git a/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java b/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java
index 9b595322b21b83d38886d515a3b8dd04cde43cea..a7552764bec1c9e5a69117fd0be604d1b9cfccfe 100644
--- a/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java
+++ b/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java
@@ -19,6 +19,11 @@ public class PoiCompetitorScan {
                     instance,
                     (jobSite, nearestLivingEntities) -> (level, villager, gameTime) -> {
                         GlobalPos globalPos = instance.get(jobSite);
+                        // Folia start - region threading
+                        if (globalPos.dimension() != level.dimension() || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, globalPos.pos())) {
+                            return true;
+                        }
+                        // Folia end - region threading
                         level.getPoiManager()
                             .getType(globalPos.pos())
                             .ifPresent(
diff --git a/net/minecraft/world/entity/ai/behavior/YieldJobSite.java b/net/minecraft/world/entity/ai/behavior/YieldJobSite.java
index 0ae25ca3d1822c9efedbde0355edf4d85db0f39b..701ed3d86c30bd61d84c667ae4c3224bace0eb62 100644
--- a/net/minecraft/world/entity/ai/behavior/YieldJobSite.java
+++ b/net/minecraft/world/entity/ai/behavior/YieldJobSite.java
@@ -32,7 +32,13 @@ public class YieldJobSite {
                         } else if (!villager.getVillagerData().profession().is(VillagerProfession.NONE)) {
                             return false;
                         } else {
-                            BlockPos blockPos = instance.<GlobalPos>get(potentialJobSite).pos();
+                            // Folia start - region threading
+                            GlobalPos globalPos = instance.get(potentialJobSite);
+                            BlockPos blockPos = globalPos.pos();
+                            if (globalPos.dimension() != level.dimension() || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, blockPos)) {
+                                return true;
+                            }
+                            // Folia end - region threading
                             Optional<Holder<PoiType>> type = level.getPoiManager().getType(blockPos);
                             if (type.isEmpty()) {
                                 return true;
diff --git a/net/minecraft/world/entity/ai/goal/FollowOwnerGoal.java b/net/minecraft/world/entity/ai/goal/FollowOwnerGoal.java
index 35eaf9fc3ae78bdc2ceae01683c07d8c817d789e..285e51a730e87643d9e2b74cb8fa3a1cf39172a9 100644
--- a/net/minecraft/world/entity/ai/goal/FollowOwnerGoal.java
+++ b/net/minecraft/world/entity/ai/goal/FollowOwnerGoal.java
@@ -50,7 +50,7 @@ public class FollowOwnerGoal extends Goal {
     public boolean canContinueToUse() {
         return !this.navigation.isDone()
             && !this.tamable.unableToMoveToOwner()
-            && !(this.tamable.distanceToSqr(this.owner) <= this.stopDistance * this.stopDistance);
+            && !(this.owner.level() == this.tamable.level() && this.tamable.distanceToSqr(this.owner) <= this.stopDistance * this.stopDistance); // Folia - region threading - check level
     }
 
     @Override
diff --git a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
index 5ccc526adb65b2107afd944a52c1246738b4bcad..99a70c6b00df3ae67336197d190ac03d074967c2 100644
--- a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
@@ -43,6 +43,11 @@ public class GroundPathNavigation extends PathNavigation {
 
     @Override
     public Path createPath(BlockPos pos, @javax.annotation.Nullable Entity entity, int reachRange) { // Paper - EntityPathfindEvent
+        // Folia start - region threading
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level, pos)) {
+            return null;
+        }
+        // Folia end - region threading
         LevelChunk chunkNow = this.level.getChunkSource().getChunkNow(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
         if (chunkNow == null) {
             return null;
diff --git a/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 61c7ca1d262098583d40b78e22db8fa67cf1dec2..0a77b906a426732a2f82e8727ef99b0ebf692238 100644
--- a/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -99,11 +99,11 @@ public abstract class PathNavigation {
     }
 
     public void recomputePath() {
-        if (this.level.getGameTime() - this.timeLastRecompute > 20L) {
+        if (this.tick - this.timeLastRecompute > 20L) { // Folia - region threading
             if (this.targetPos != null) {
                 this.path = null;
                 this.path = this.createPath(this.targetPos, this.reachRange);
-                this.timeLastRecompute = this.level.getGameTime();
+                this.timeLastRecompute = this.tick; // Folia - region threading
                 this.hasDelayedRecomputation = false;
             }
         } else {
@@ -213,7 +213,7 @@ public abstract class PathNavigation {
 
     public boolean moveTo(Entity entity, double speedModifier) {
         // Paper start - Perf: Optimise pathfinding
-        if (this.pathfindFailures > 10 && this.path == null && net.minecraft.server.MinecraftServer.currentTick < this.lastFailure + 40) {
+        if (this.pathfindFailures > 10 && this.path == null && this.tick < this.lastFailure + 40) { // Folia - region threading
             return false;
         }
         // Paper end - Perf: Optimise pathfinding
@@ -225,7 +225,7 @@ public abstract class PathNavigation {
             return true;
         } else {
             this.pathfindFailures++;
-            this.lastFailure = net.minecraft.server.MinecraftServer.currentTick;
+            this.lastFailure = this.tick; // Folia - region threading
             return false;
         }
         // Paper end - Perf: Optimise pathfinding
diff --git a/net/minecraft/world/entity/ai/sensing/PlayerSensor.java b/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
index eb3ec4be63e1710d0ed9021eb8158d56eae89f8d..ce9a369a603ed0fe2a119775b1e597a5dcde91b9 100644
--- a/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
@@ -26,7 +26,7 @@ public class PlayerSensor extends Sensor<LivingEntity> {
 
     @Override
     protected void doTick(ServerLevel level, LivingEntity entity) {
-        List<Player> list = level.players()
+        List<Player> list = level.getLocalPlayers() // Folia - region threading
             .stream()
             .filter(EntitySelector.NO_SPECTATORS)
             .filter(serverPlayer -> entity.closerThan(serverPlayer, this.getFollowDistance(entity)))
diff --git a/net/minecraft/world/entity/ai/sensing/TemptingSensor.java b/net/minecraft/world/entity/ai/sensing/TemptingSensor.java
index 77cd672c846cb05b19f387348f1531c8b9c972ee..d69a098e46eb99f51d98f37fa71c67733b0122df 100644
--- a/net/minecraft/world/entity/ai/sensing/TemptingSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/TemptingSensor.java
@@ -38,7 +38,7 @@ public class TemptingSensor extends Sensor<PathfinderMob> {
     protected void doTick(ServerLevel level, PathfinderMob entity) {
         Brain<?> brain = entity.getBrain();
         TargetingConditions targetingConditions = TEMPT_TARGETING.copy().range((float)entity.getAttributeValue(Attributes.TEMPT_RANGE));
-        List<Player> list = level.players()
+        List<Player> list = level.getLocalPlayers() // Folia - region threading
             .stream()
             .filter(EntitySelector.NO_SPECTATORS)
             .filter(serverPlayer -> targetingConditions.test(level, entity, serverPlayer))
diff --git a/net/minecraft/world/entity/ai/village/VillageSiege.java b/net/minecraft/world/entity/ai/village/VillageSiege.java
index a246ace744c686b34089d36a1ced06e5414f27f8..0796558d3df40aebe937f4094b1b3831d22e3740 100644
--- a/net/minecraft/world/entity/ai/village/VillageSiege.java
+++ b/net/minecraft/world/entity/ai/village/VillageSiege.java
@@ -18,62 +18,66 @@ import org.slf4j.Logger;
 
 public class VillageSiege implements CustomSpawner {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private boolean hasSetupSiege;
-    private VillageSiege.State siegeState = VillageSiege.State.SIEGE_DONE;
-    private int zombiesToSpawn;
-    private int nextSpawnTime;
-    private int spawnX;
-    private int spawnY;
-    private int spawnZ;
+    // Folia - region threading
 
     @Override
     public void tick(ServerLevel level, boolean spawnEnemies) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+        // Folia start - region threading
+        // check if the spawn pos is no longer owned by this region
+        if (worldData.villageSiegeState.siegeState != VillageSiege.State.SIEGE_DONE
+                && !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, worldData.villageSiegeState.spawnX >> 4, worldData.villageSiegeState.spawnZ >> 4, 8)) {
+            // can't spawn here, just re-set
+            worldData.villageSiegeState = new io.papermc.paper.threadedregions.RegionizedWorldData.VillageSiegeState();
+        }
+        // Folia end - region threading
         if (!level.isBrightOutside() && spawnEnemies) {
             long l = level.getDayTime() % 24000L;
             if (l == 18000L) {
-                this.siegeState = level.random.nextInt(10) == 0 ? VillageSiege.State.SIEGE_TONIGHT : VillageSiege.State.SIEGE_DONE;
+                worldData.villageSiegeState.siegeState = level.random.nextInt(10) == 0 ? VillageSiege.State.SIEGE_TONIGHT : VillageSiege.State.SIEGE_DONE; // Folia - region threading
             }
 
-            if (this.siegeState != VillageSiege.State.SIEGE_DONE) {
-                if (!this.hasSetupSiege) {
+            if (worldData.villageSiegeState.siegeState != VillageSiege.State.SIEGE_DONE) { // Folia - region threading
+                if (!worldData.villageSiegeState.hasSetupSiege) { // Folia - region threading
                     if (!this.tryToSetupSiege(level)) {
                         return;
                     }
 
-                    this.hasSetupSiege = true;
+                    worldData.villageSiegeState.hasSetupSiege = true; // Folia - region threading
                 }
 
-                if (this.nextSpawnTime > 0) {
-                    this.nextSpawnTime--;
+                if (worldData.villageSiegeState.nextSpawnTime > 0) { // Folia - region threading
+                    worldData.villageSiegeState.nextSpawnTime--; // Folia - region threading
                 } else {
-                    this.nextSpawnTime = 2;
-                    if (this.zombiesToSpawn > 0) {
+                    worldData.villageSiegeState.nextSpawnTime = 2; // Folia - region threading
+                    if (worldData.villageSiegeState.zombiesToSpawn > 0) { // Folia - region threading
                         this.trySpawn(level);
-                        this.zombiesToSpawn--;
+                        worldData.villageSiegeState.zombiesToSpawn--; // Folia - region threading
                     } else {
-                        this.siegeState = VillageSiege.State.SIEGE_DONE;
+                        worldData.villageSiegeState.siegeState = VillageSiege.State.SIEGE_DONE; // Folia - region threading
                     }
                 }
             }
         } else {
-            this.siegeState = VillageSiege.State.SIEGE_DONE;
-            this.hasSetupSiege = false;
+            worldData.villageSiegeState.siegeState = VillageSiege.State.SIEGE_DONE; // Folia - region threading
+            worldData.villageSiegeState.hasSetupSiege = false; // Folia - region threading
         }
     }
 
     private boolean tryToSetupSiege(ServerLevel level) {
-        for (Player player : level.players()) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+        for (Player player : level.getLocalPlayers()) { // Folia - region threading
             if (!player.isSpectator()) {
                 BlockPos blockPos = player.blockPosition();
                 if (level.isVillage(blockPos) && !level.getBiome(blockPos).is(BiomeTags.WITHOUT_ZOMBIE_SIEGES)) {
                     for (int i = 0; i < 10; i++) {
                         float f = level.random.nextFloat() * (float) (Math.PI * 2);
-                        this.spawnX = blockPos.getX() + Mth.floor(Mth.cos(f) * 32.0F);
-                        this.spawnY = blockPos.getY();
-                        this.spawnZ = blockPos.getZ() + Mth.floor(Mth.sin(f) * 32.0F);
-                        if (this.findRandomSpawnPos(level, new BlockPos(this.spawnX, this.spawnY, this.spawnZ)) != null) {
-                            this.nextSpawnTime = 0;
-                            this.zombiesToSpawn = 20;
+                        worldData.villageSiegeState.spawnX = blockPos.getX() + Mth.floor(Mth.cos(f) * 32.0F); // Folia - region threading
+                        worldData.villageSiegeState.spawnY = blockPos.getY(); // Folia - region threading
+                        worldData.villageSiegeState.spawnZ = blockPos.getZ() + Mth.floor(Mth.sin(f) * 32.0F); // Folia - region threading
+                        if (this.findRandomSpawnPos(level, new BlockPos(worldData.villageSiegeState.spawnX, worldData.villageSiegeState.spawnY, worldData.villageSiegeState.spawnZ)) != null) { // Folia - region threading
+                            worldData.villageSiegeState.nextSpawnTime = 0; // Folia - region threading
+                            worldData.villageSiegeState.zombiesToSpawn = 20; // Folia - region threading
                             break;
                         }
                     }
@@ -87,11 +91,13 @@ public class VillageSiege implements CustomSpawner {
     }
 
     private void trySpawn(ServerLevel level) {
-        Vec3 vec3 = this.findRandomSpawnPos(level, new BlockPos(this.spawnX, this.spawnY, this.spawnZ));
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+        Vec3 vec3 = this.findRandomSpawnPos(level, new BlockPos(worldData.villageSiegeState.spawnX, worldData.villageSiegeState.spawnY, worldData.villageSiegeState.spawnZ)); // Folia - region threading
         if (vec3 != null) {
             Zombie zombie;
             try {
                 zombie = new Zombie(level);
+                zombie.snapTo(vec3.x, vec3.y, vec3.z, level.random.nextFloat() * 360.0F, 0.0F); // Folia - region threading - move up
                 zombie.finalizeSpawn(level, level.getCurrentDifficultyAt(zombie.blockPosition()), EntitySpawnReason.EVENT, null);
             } catch (Exception var5) {
                 LOGGER.warn("Failed to create zombie for village siege at {}", vec3, var5);
@@ -99,7 +105,7 @@ public class VillageSiege implements CustomSpawner {
                 return;
             }
 
-            zombie.snapTo(vec3.x, vec3.y, vec3.z, level.random.nextFloat() * 360.0F, 0.0F);
+            //zombie.snapTo(vec3.x, vec3.y, vec3.z, level.random.nextFloat() * 360.0F, 0.0F); // Folia - region threading - move up
             level.addFreshEntityWithPassengers(zombie, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.VILLAGE_INVASION); // CraftBukkit
         }
     }
@@ -118,7 +124,7 @@ public class VillageSiege implements CustomSpawner {
         return null;
     }
 
-    static enum State {
+    public static enum State { // Folia - region threading
         SIEGE_CAN_ACTIVATE,
         SIEGE_TONIGHT,
         SIEGE_DONE;
diff --git a/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 95fa0d9487542ba5308c60d29095efa6c90e86d6..26059d9b462bf3860aab979ca85b721086293c8e 100644
--- a/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -60,11 +60,13 @@ public class PoiManager extends SectionStorage<PoiSection, PoiSection.Packed> im
     }
 
     private void updateDistanceTracking(long section) {
+        synchronized (this.villageDistanceTracker) { // Folia - region threading
         if (this.isVillageCenter(section)) {
             this.villageDistanceTracker.setSource(section, POI_DATA_SOURCE);
         } else {
             this.villageDistanceTracker.removeSource(section);
         }
+        } // Folia - region threading
     }
 
     @Override
@@ -348,10 +350,12 @@ public class PoiManager extends SectionStorage<PoiSection, PoiSection.Packed> im
     }
 
     public int sectionsToVillage(SectionPos sectionPos) {
+        synchronized (this.villageDistanceTracker) { // Folia - region threading
         // Paper start - rewrite chunk system
         this.villageDistanceTracker.propagateUpdates();
         return convertBetweenLevels(this.villageDistanceTracker.getLevel(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkSectionKey(sectionPos)));
         // Paper end - rewrite chunk system
+        } // Folia - region threading
     }
 
     boolean isVillageCenter(long chunkPos) {
@@ -365,7 +369,9 @@ public class PoiManager extends SectionStorage<PoiSection, PoiSection.Packed> im
 
     @Override
     public void tick(BooleanSupplier aheadOfTime) {
+        synchronized (this.villageDistanceTracker) { // Folia - region threading
         this.villageDistanceTracker.propagateUpdates(); // Paper - rewrite chunk system
+        } // Folia - region threading
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/bee/Bee.java b/net/minecraft/world/entity/animal/bee/Bee.java
index 0cbcf23b6edba2305dfbbc95abb06a90a6edd42b..6d6495621a3c4269f7a3f5f815e13cfabcb34560 100644
--- a/net/minecraft/world/entity/animal/bee/Bee.java
+++ b/net/minecraft/world/entity/animal/bee/Bee.java
@@ -814,6 +814,11 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
         @Override
         public boolean canBeeUse() {
+            // Folia start - region threading
+            if (Bee.this.hivePos != null && Bee.this.isTooFarAway(Bee.this.hivePos)) {
+                Bee.this.hivePos = null;
+            }
+            // Folia end - region threading
             return Bee.this.hivePos != null
                 && !Bee.this.isTooFarAway(Bee.this.hivePos)
                 && !Bee.this.hasHome()
@@ -924,6 +929,11 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
         @Override
         public boolean canBeeUse() {
+            // Folia start - region threading
+            if (Bee.this.savedFlowerPos != null && Bee.this.isTooFarAway(Bee.this.savedFlowerPos)) {
+                Bee.this.savedFlowerPos = null;
+            }
+            // Folia end - region threading
             return Bee.this.savedFlowerPos != null && !Bee.this.hasHome() && this.wantsToGoToKnownFlower() && !Bee.this.closerThan(Bee.this.savedFlowerPos, 2);
         }
 
diff --git a/net/minecraft/world/entity/animal/happyghast/HappyGhast.java b/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
index 5a4a96895c1d2f7538bf644dd133645bc831b582..c5880672ec5fda6f372346c33c48d93fc9f040d3 100644
--- a/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
+++ b/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
@@ -546,7 +546,7 @@ public class HappyGhast extends Animal {
             boundingBox.maxZ + 1.0
         );
 
-        for (Player player : this.level().players()) {
+        for (Player player : this.level().getLocalPlayers()) { // Folia - region threading - Vanilla should do an AABB lookup but whatever
             if (!player.isSpectator()) {
                 Entity rootVehicle = player.getRootVehicle();
                 if (!(rootVehicle instanceof HappyGhast) && aabb.contains(rootVehicle.position())) {
diff --git a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
index c095f42aa103b7874fb5d8dcece1b1484c2e2968..b118edb806bd1004d6e915663efb693747ec6498 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
@@ -54,7 +54,7 @@ public class EndCrystal extends Entity {
     public void tick() {
         this.time++;
         this.applyEffectsFromBlocks();
-        this.handlePortal();
+        //this.handlePortal(); // Folia - region threading
         if (this.level() instanceof ServerLevel) {
             BlockPos blockPos = this.blockPosition();
             if (((ServerLevel)this.level()).getDragonFight() != null && this.level().getBlockState(blockPos).isAir()) {
diff --git a/net/minecraft/world/entity/decoration/ItemFrame.java b/net/minecraft/world/entity/decoration/ItemFrame.java
index df3b0f910bef3b56db31980e61396008de7021e3..c139a52d67ad61abeaf582e08e6a301095dc2e44 100644
--- a/net/minecraft/world/entity/decoration/ItemFrame.java
+++ b/net/minecraft/world/entity/decoration/ItemFrame.java
@@ -265,7 +265,9 @@ public class ItemFrame extends HangingEntity {
         if (framedMapId != null) {
             MapItemSavedData savedData = MapItem.getSavedData(framedMapId, this.level());
             if (savedData != null) {
+                synchronized (savedData) { // Folia - make map data thread-safe
                 savedData.removedFromFrame(this.pos, this.getId());
+                } // Folia - make map data thread-safe
             }
         }
 
diff --git a/net/minecraft/world/entity/item/FallingBlockEntity.java b/net/minecraft/world/entity/item/FallingBlockEntity.java
index 51f1b141f5f2abd96d36d3ea1954f8dded936506..8009dfe104d53ebfc10f0eb86e955d21831dbffc 100644
--- a/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -164,7 +164,7 @@ public class FallingBlockEntity extends Entity {
                 return;
             }
             // Paper end - Configurable falling blocks height nerf
-            this.handlePortal();
+            //this.handlePortal(); // Folia - region threading
             if (this.level() instanceof ServerLevel serverLevel && (this.isAlive() || this.forceTickAfterTeleportToDuplicate)) {
                 BlockPos blockPos = this.blockPosition();
                 boolean flag = this.blockState.getBlock() instanceof ConcretePowderBlock;
diff --git a/net/minecraft/world/entity/item/ItemEntity.java b/net/minecraft/world/entity/item/ItemEntity.java
index e82bb8f2d2b0e771dc371fd7e709116e1f5f204f..7d8748fd4bdd523a7cf37ef86729da4277416f9a 100644
--- a/net/minecraft/world/entity/item/ItemEntity.java
+++ b/net/minecraft/world/entity/item/ItemEntity.java
@@ -491,12 +491,20 @@ public class ItemEntity extends Entity implements TraceableEntity {
         return false;
     }
 
+    // Folia start - region threading
     @Override
-    public @Nullable Entity teleport(TeleportTransition teleportTransition) {
-        Entity entity = super.teleport(teleportTransition);
-        if (!this.level().isClientSide() && entity instanceof ItemEntity itemEntity) {
+    public void postChangeDimension() {
+        super.postChangeDimension();
+        if (!this.level().isClientSide() && this instanceof ItemEntity itemEntity) {
             itemEntity.mergeWithNeighbours();
         }
+    }
+    // Folia end - region threading
+
+    @Override
+    public @Nullable Entity teleport(TeleportTransition teleportTransition) {
+        Entity entity = super.teleport(teleportTransition);
+        if (entity != null) entity.postChangeDimension(); // Folia - region threading - move to post change
 
         return entity;
     }
diff --git a/net/minecraft/world/entity/item/PrimedTnt.java b/net/minecraft/world/entity/item/PrimedTnt.java
index 910e7739aea98d6dfa603072acf5e9936dbb2c5e..fd1db18764be58bc5ed5983b98e669c76f7ff427 100644
--- a/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/net/minecraft/world/entity/item/PrimedTnt.java
@@ -99,8 +99,8 @@ public class PrimedTnt extends Entity implements TraceableEntity {
 
     @Override
     public void tick() {
-        if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().spigotConfig.currentPrimedTnt > this.level().spigotConfig.maxTntTicksPerTick) { return; } // Spigot
-        this.handlePortal();
+        if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().getCurrentWorldData().currentPrimedTnt > this.level().spigotConfig.maxTntTicksPerTick) { return; } // Spigot // Folia - region threading
+        //this.handlePortal(); // Folia - region threading
         this.applyGravity();
         this.move(MoverType.SELF, this.getDeltaMovement());
         this.applyEffectsFromBlocks();
@@ -217,13 +217,21 @@ public class PrimedTnt extends Entity implements TraceableEntity {
     @Override
     public @Nullable Entity teleport(TeleportTransition teleportTransition) {
         Entity entity = super.teleport(teleportTransition);
-        if (entity instanceof PrimedTnt primedTnt) {
-            primedTnt.setUsedPortal(true);
-        }
+        // Folia - region threading - move to post change
 
         return entity;
     }
 
+    // Folia start - region threading
+    @Override
+    public void postChangeDimension() {
+        super.postChangeDimension();
+        if (this instanceof PrimedTnt primedTnt) { // Folia - region threading - move to post change
+            primedTnt.setUsedPortal(true);
+        }
+    }
+    // Folia end - region threading
+
     @Override
     public final boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
         return false;
diff --git a/net/minecraft/world/entity/monster/Vex.java b/net/minecraft/world/entity/monster/Vex.java
index a6bfb39305732068c50ae99a28114b58b76d2cf7..95074a7106d58819e0b5d53436c37164fd83d2bf 100644
--- a/net/minecraft/world/entity/monster/Vex.java
+++ b/net/minecraft/world/entity/monster/Vex.java
@@ -341,7 +341,7 @@ public class Vex extends Monster implements TraceableEntity {
         @Override
         public void tick() {
             BlockPos boundOrigin = Vex.this.getBoundOrigin();
-            if (boundOrigin == null) {
+            if (boundOrigin == null || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)Vex.this.level(), boundOrigin)) { // Folia - region threading
                 boundOrigin = Vex.this.blockPosition();
             }
 
diff --git a/net/minecraft/world/entity/npc/CatSpawner.java b/net/minecraft/world/entity/npc/CatSpawner.java
index 5401976c4fa86e2db6622743c8e8ea7381f72878..0e2651f8e9d3033417bae3808e34dcc7ac896a2c 100644
--- a/net/minecraft/world/entity/npc/CatSpawner.java
+++ b/net/minecraft/world/entity/npc/CatSpawner.java
@@ -17,14 +17,15 @@ import net.minecraft.world.phys.AABB;
 
 public class CatSpawner implements CustomSpawner {
     private static final int TICK_DELAY = 1200;
-    private int nextTick;
+    //private int nextTick; // Folia - region threading
 
     @Override
     public void tick(ServerLevel level, boolean spawnEnemies) {
-        this.nextTick--;
-        if (this.nextTick <= 0) {
-            this.nextTick = 1200;
-            Player randomPlayer = level.getRandomPlayer();
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+        worldData.catSpawnerNextTick--; // Folia - region threading
+        if (worldData.catSpawnerNextTick <= 0) { // Folia - region threading
+            worldData.catSpawnerNextTick = 1200; // Folia - region threading
+            Player randomPlayer = level.getRandomLocalPlayer(); // Folia - region threading
             if (randomPlayer != null) {
                 RandomSource randomSource = level.random;
                 int i = (8 + randomSource.nextInt(24)) * (randomSource.nextBoolean() ? -1 : 1);
diff --git a/net/minecraft/world/entity/npc/villager/AbstractVillager.java b/net/minecraft/world/entity/npc/villager/AbstractVillager.java
index fa8f1ea38192f9ad0a961a53399f295d83af7721..6917bed9d4b34b359489046355174e6c21ca294b 100644
--- a/net/minecraft/world/entity/npc/villager/AbstractVillager.java
+++ b/net/minecraft/world/entity/npc/villager/AbstractVillager.java
@@ -202,9 +202,17 @@ public abstract class AbstractVillager extends AgeableMob implements InventoryCa
         this.readInventoryFromTag(input);
     }
 
+    // Folia start - region threading
     @Override
-    public @Nullable Entity teleport(TeleportTransition teleportTransition) {
+    public void preChangeDimension() {
+        super.preChangeDimension();
         this.stopTrading();
+    }
+    // Folia end - region threading
+
+    @Override
+    public @Nullable Entity teleport(TeleportTransition teleportTransition) {
+        this.preChangeDimension(); // Folia - region threading - move into preChangeDimension
         return super.teleport(teleportTransition);
     }
 
diff --git a/net/minecraft/world/entity/npc/villager/Villager.java b/net/minecraft/world/entity/npc/villager/Villager.java
index 89844d7e804cc8a2110b694e448bc5993991bea7..8616a8f5b720eac2bb5b3d78a3b69d40bb0b5547 100644
--- a/net/minecraft/world/entity/npc/villager/Villager.java
+++ b/net/minecraft/world/entity/npc/villager/Villager.java
@@ -250,7 +250,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         villagerBrain.setCoreActivities(ImmutableSet.of(Activity.CORE));
         villagerBrain.setDefaultActivity(Activity.IDLE);
         villagerBrain.setActiveActivityIfPossible(Activity.IDLE);
-        villagerBrain.updateActivityFromSchedule(this.level().environmentAttributes(), this.level().getGameTime(), this.position());
+        villagerBrain.updateActivityFromSchedule(this.level().environmentAttributes(), this.level().getLevelData().getGameTime(), this.position()); // Folia - region threading - not in the world yet
     }
 
     @Override
@@ -678,6 +678,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             this.brain.getMemory(moduleType).ifPresent(pos -> {
                 ServerLevel level = server.getLevel(pos.dimension());
                 if (level != null) {
+                    io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue( // Folia - region threading
+                            level, pos.pos().getX() >> 4, pos.pos().getZ() >> 4, () -> { // Folia - region threading
                     PoiManager poiManager = level.getPoiManager();
                     Optional<Holder<PoiType>> type = poiManager.getType(pos.pos());
                     BiPredicate<Villager, Holder<PoiType>> biPredicate = POI_MEMORIES.get(moduleType);
@@ -685,6 +687,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
                         poiManager.release(pos.pos());
                         level.debugSynchronizers().updatePoi(pos.pos());
                     }
+                    }); // Folia - region threading
                 }
             });
         }
diff --git a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
index 44b43ca9fba989f975133f966cedd582a93d3350..d948df50738421b83e0314ee1e00759ebbcfd443 100644
--- a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
+++ b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
@@ -30,16 +30,14 @@ public class WanderingTraderSpawner implements CustomSpawner {
     private static final int SPAWN_CHANCE_INCREASE = 25;
     private static final int SPAWN_ONE_IN_X_CHANCE = 10;
     private static final int NUMBER_OF_SPAWN_ATTEMPTS = 10;
-    private final RandomSource random = RandomSource.create();
+    private final RandomSource random = io.papermc.paper.threadedregions.util.ThreadLocalRandomSource.INSTANCE; // Folia - region threading
     private final ServerLevelData serverLevelData;
-    private int tickDelay;
-    private int spawnDelay;
-    private int spawnChance;
+    // Folia - region threading
 
     public WanderingTraderSpawner(ServerLevelData serverLevelData) {
         this.serverLevelData = serverLevelData;
         // Paper start - Add Wandering Trader spawn rate config options
-        this.tickDelay = Integer.MIN_VALUE;
+        //this.tickDelay = Integer.MIN_VALUE; // Folia - region threading - moved to regionisedworlddata
         // this.spawnDelay = serverLevelData.getWanderingTraderSpawnDelay();
         // this.spawnChance = serverLevelData.getWanderingTraderSpawnChance();
         // if (this.spawnDelay == 0 && this.spawnChance == 0) {
@@ -53,35 +51,36 @@ public class WanderingTraderSpawner implements CustomSpawner {
 
     @Override
     public void tick(ServerLevel level, boolean spawnEnemies) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
         // Paper start - Add Wandering Trader spawn rate config options
-        if (this.tickDelay == Integer.MIN_VALUE) {
-            this.tickDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength;
-            this.spawnDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnDayLength;
-            this.spawnChance = level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin;
+        if (worldData.wanderingTraderTickDelay == Integer.MIN_VALUE) { // Folia - region threading
+            worldData.wanderingTraderTickDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength; // Folia - region threading
+            worldData.wanderingTraderSpawnDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnDayLength; // Folia - region threading
+            worldData.wanderingTraderSpawnChance = level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin; // Folia - region threading
         }
         if (level.getGameRules().get(GameRules.SPAWN_WANDERING_TRADERS)) {
-            if (this.tickDelay - 1 <= 0) { // Paper - Prevent tickDelay going below 0
-                this.tickDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength;
-                this.spawnDelay = this.spawnDelay - level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength;
+            if (worldData.wanderingTraderTickDelay - 1 <= 0) { // Paper - Prevent tickDelay going below 0 // Folia - region threading
+                worldData.wanderingTraderTickDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength; // Folia - region threading
+                worldData.wanderingTraderSpawnDelay = worldData.wanderingTraderSpawnDelay - level.paperConfig().entities.spawning.wanderingTrader.spawnMinuteLength; // Folia - region threading
                 //this.serverLevelData.setWanderingTraderSpawnDelay(this.spawnDelay); // Paper - We don't need to save this value to disk if it gets set back to a hardcoded value anyways
-                if (this.spawnDelay <= 0) {
-                    this.spawnDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnDayLength;
-                    int i = this.spawnChance;
-                    this.spawnChance = Mth.clamp(this.spawnChance + level.paperConfig().entities.spawning.wanderingTrader.spawnChanceFailureIncrement, level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin, level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMax);
+                if (worldData.wanderingTraderSpawnDelay <= 0) { // Folia - region threading
+                    worldData.wanderingTraderSpawnDelay = level.paperConfig().entities.spawning.wanderingTrader.spawnDayLength; // Folia - region threading
+                    int i = worldData.wanderingTraderSpawnChance; // Folia - region threading
+                    worldData.wanderingTraderSpawnChance = Mth.clamp(worldData.wanderingTraderSpawnChance + level.paperConfig().entities.spawning.wanderingTrader.spawnChanceFailureIncrement, level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin, level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMax); // Folia - region threading
                     //this.serverLevelData.setWanderingTraderSpawnChance(this.spawnChance); // Paper - We don't need to save this value to disk if it gets set back to a hardcoded value anyways
                     if (this.random.nextInt(100) <= i) {
                         if (this.spawn(level)) {
-                            this.spawnChance = level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin;
+                            worldData.wanderingTraderSpawnChance = level.paperConfig().entities.spawning.wanderingTrader.spawnChanceMin; // Folia - region threading
                             // Paper end - Add Wandering Trader spawn rate config options
                         }
                     }
                 }
-            } else { this.tickDelay--; } // Paper - Prevent tickDelay going below 0
+            } else { worldData.wanderingTraderTickDelay--; } // Paper - Prevent tickDelay going below 0
         }
     }
 
     private boolean spawn(ServerLevel level) {
-        Player randomPlayer = level.getRandomPlayer();
+        Player randomPlayer = level.getRandomLocalPlayer(); // Folia - region threading
         if (randomPlayer == null) {
             return true;
         } else if (this.random.nextInt(10) != 0) {
@@ -104,7 +103,7 @@ public class WanderingTraderSpawner implements CustomSpawner {
                         this.tryToSpawnLlamaFor(level, wanderingTrader, 4);
                     }
 
-                    this.serverLevelData.setWanderingTraderId(wanderingTrader.getUUID());
+                    //this.serverLevelData.setWanderingTraderId(wanderingTrader.getUUID()); // Folia - region threading - doesn't appear to be used anywhere, so avoid the race condition here...
                     // wanderingTrader.setDespawnDelay(48000); // Paper - moved above, modifiable by plugins on CreatureSpawnEvent
                     wanderingTrader.setWanderTarget(blockPos1);
                     wanderingTrader.setHomeTo(blockPos1, 16);
diff --git a/net/minecraft/world/entity/player/Player.java b/net/minecraft/world/entity/player/Player.java
index 01eff08e3834f5e12fce070509d3ee6969db8c67..3050064e6d3c8d0cedd680b5ec6336594b70b2a0 100644
--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -1365,6 +1365,14 @@ public abstract class Player extends Avatar implements ContainerUser {
         return this.isLocalPlayer();
     }
 
+    // Folia start - region threading
+    @Override
+    protected void preRemove(RemovalReason reason) {
+        super.preRemove(reason);
+        this.fishing = null;
+    }
+    // Folia end - region threading
+
     public boolean isLocalPlayer() {
         return false;
     }
diff --git a/net/minecraft/world/entity/projectile/FireworkRocketEntity.java b/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
index 1b633d2eb77704fd9a6358f09ed368fab2a5b212..b18110d57eecfa8e9a39b5be3b7123acbbb54e65 100644
--- a/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
+++ b/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
@@ -135,6 +135,11 @@ public class FireworkRocketEntity extends Projectile implements ItemSupplier {
                     }
                 });
             }
+            // Folia start - region threading
+            if (this.attachedToEntity != null && !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.attachedToEntity)) {
+                this.attachedToEntity = null;
+            }
+            // Folia end - region threading
 
             if (this.attachedToEntity != null) {
                 Vec3 handHoldingItemAngle;
diff --git a/net/minecraft/world/entity/projectile/FishingHook.java b/net/minecraft/world/entity/projectile/FishingHook.java
index 4a7abf4ae0c1f4c22c1c77d5ce9e67418b274365..71f6acc07d222fe512bf8d9fbaad35cb36bcf2d6 100644
--- a/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/net/minecraft/world/entity/projectile/FishingHook.java
@@ -270,6 +270,11 @@ public class FishingHook extends Projectile {
     }
 
     private boolean shouldStopFishing(Player player) {
+        // Folia start - region threading
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+            return true;
+        }
+        // Folia end - region threading
         if (player.canInteractWithLevel()) {
             ItemStack mainHandItem = player.getMainHandItem();
             ItemStack offhandItem = player.getOffhandItem();
@@ -614,10 +619,18 @@ public class FishingHook extends Projectile {
 
     @Override
     public void remove(Entity.RemovalReason reason, org.bukkit.event.entity.EntityRemoveEvent.@Nullable Cause cause) { // CraftBukkit - add Bukkit remove cause
-        this.updateOwnerInfo(null);
+        //this.updateOwnerInfo(null); // Folia - region threading - move into preRemove
         super.remove(reason, cause); // CraftBukkit - add Bukkit remove cause
     }
 
+    // Folia start - region threading
+    @Override
+    protected void preRemove(RemovalReason reason) {
+        super.preRemove(reason);
+        this.updateOwnerInfo(null);
+    }
+    // Folia end - region threading
+
     @Override
     public void onClientRemoval() {
         this.updateOwnerInfo(null);
diff --git a/net/minecraft/world/entity/projectile/LlamaSpit.java b/net/minecraft/world/entity/projectile/LlamaSpit.java
index b8e3616de5f07e49a8bbab314329157e4268fb1e..9d5bf726867a0e4bd9e9fd617cce72f6cbbc3d72 100644
--- a/net/minecraft/world/entity/projectile/LlamaSpit.java
+++ b/net/minecraft/world/entity/projectile/LlamaSpit.java
@@ -41,6 +41,11 @@ public class LlamaSpit extends Projectile {
     @Override
     public void tick() {
         super.tick();
+        // Folia start - region threading - make sure entities do not move into regions they do not own
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
+            return;
+        }
+        // Folia end - region threading - make sure entities do not move into regions they do not own
         Vec3 deltaMovement = this.getDeltaMovement();
         HitResult hitResultOnMoveVector = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity);
         this.preHitTargetOrDeflectSelf(hitResultOnMoveVector); // CraftBukkit - projectile hit event
diff --git a/net/minecraft/world/entity/projectile/Projectile.java b/net/minecraft/world/entity/projectile/Projectile.java
index 6298e6de25f1dd9ff880a9ad2882dc7ccb2f100c..da218b6f84f8501eec8086abf2b61d8552741fc9 100644
--- a/net/minecraft/world/entity/projectile/Projectile.java
+++ b/net/minecraft/world/entity/projectile/Projectile.java
@@ -71,8 +71,20 @@ public abstract class Projectile extends Entity implements TraceableEntity {
     }
     // Paper end - Refresh ProjectileSource for projectiles
 
+
+    // Folia start - region threading
+    // In general, this is an entire mess. At the time of writing, there are fifty usages of getOwner.
+    // Usage of this function is to avoid concurrency issues, even if it sacrifices behavior.
+    @Nullable
     @Override
-    public @Nullable Entity getOwner() {
+    public Entity getOwner() {
+        Entity ret = this.getOwnerRaw();
+        return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(ret) && (ret == null || !ret.isRemoved()) ? ret : null;
+    }
+    // Folia end - region threading
+
+    public @Nullable Entity getOwnerRaw() { // Folia - region threading
+        if (!this.hasNullCallback()) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot update owner state asynchronously"); // Folia - region threading
         return EntityReference.getEntity(this.owner, this.level());
     }
 
@@ -434,7 +446,7 @@ public abstract class Projectile extends Entity implements TraceableEntity {
     @Override
     public boolean mayInteract(ServerLevel level, BlockPos pos) {
         Entity owner = this.getOwner();
-        return owner instanceof Player ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().get(GameRules.MOB_GRIEFING);
+        return owner instanceof Player && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(owner) ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().get(GameRules.MOB_GRIEFING); // Folia - region threading
     }
 
     public boolean mayBreak(ServerLevel level) {
diff --git a/net/minecraft/world/entity/projectile/ThrowableProjectile.java b/net/minecraft/world/entity/projectile/ThrowableProjectile.java
index dfda0560e364aa7777bc1aa76febc55f1c2dd5a0..06fa80879b11ee84f0468e0c428e99586341c927 100644
--- a/net/minecraft/world/entity/projectile/ThrowableProjectile.java
+++ b/net/minecraft/world/entity/projectile/ThrowableProjectile.java
@@ -44,6 +44,11 @@ public abstract class ThrowableProjectile extends Projectile {
 
     @Override
     public void tick() {
+        // Folia start - region threading - make sure entities do not move into regions they do not own
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
+            return;
+        }
+        // Folia end - region threading - make sure entities do not move into regions they do not own
         this.handleFirstTickBubbleColumn();
         this.applyGravity();
         this.applyInertia();
diff --git a/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java b/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
index 499c65dae899b50f9e2dd689bf23a565f51e5a88..6a1bb4193ecab042ffea193641098cd892258e43 100644
--- a/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
+++ b/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
@@ -169,6 +169,11 @@ public abstract class AbstractArrow extends Projectile {
 
     @Override
     public void tick() {
+        // Folia start - region threading - make sure entities do not move into regions they do not own
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
+            return;
+        }
+        // Folia end - region threading - make sure entities do not move into regions they do not own
         boolean flag = !this.isNoPhysics();
         Vec3 deltaMovement = this.getDeltaMovement();
         BlockPos blockPos = this.blockPosition();
diff --git a/net/minecraft/world/entity/projectile/hurtingprojectile/AbstractHurtingProjectile.java b/net/minecraft/world/entity/projectile/hurtingprojectile/AbstractHurtingProjectile.java
index 6edff432866ae72db657b47bf9726be9a4ef1562..e7c522f816819a708bd3f56c8c55347543b7acb2 100644
--- a/net/minecraft/world/entity/projectile/hurtingprojectile/AbstractHurtingProjectile.java
+++ b/net/minecraft/world/entity/projectile/hurtingprojectile/AbstractHurtingProjectile.java
@@ -83,6 +83,11 @@ public abstract class AbstractHurtingProjectile extends Projectile {
             this.setPos(location);
             this.applyEffectsFromBlocks();
             super.tick();
+            // Folia start - region threading - make sure entities do not move into regions they do not own
+            if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor((net.minecraft.server.level.ServerLevel)this.level(), this.position(), this.getDeltaMovement(), 1)) {
+                return;
+            }
+            // Folia end - region threading - make sure entities do not move into regions they do not own
             if (this.shouldBurn()) {
                 this.igniteForSeconds(1.0F);
             }
diff --git a/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java b/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
index 043ddaa0e8718f50881d16892eab188aed70f67f..876aca02bec4d12c10524d3c2860f6804bdd9a29 100644
--- a/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
+++ b/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
@@ -24,7 +24,7 @@ public class SmallFireball extends Fireball {
     public SmallFireball(Level level, LivingEntity owner, Vec3 movement) {
         super(EntityType.SMALL_FIREBALL, owner, movement, level);
         // CraftBukkit start
-        if (this.getOwner() != null && this.getOwner() instanceof Mob) {
+        if (owner != null && owner instanceof Mob) { // Folia - region threading
             this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING);
         }
         // CraftBukkit end
diff --git a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEgg.java b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEgg.java
index c7db74ccc3f8c46e97c24857f297fe5fb5f45e36..ffc93b24e2fee325bf79c648378f7adc74f0da94 100644
--- a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEgg.java
+++ b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEgg.java
@@ -98,12 +98,13 @@ public class ThrownEgg extends ThrowableItemProjectile {
                 for (int i1 = 0; i1 < i; i1++) {
                     net.minecraft.world.entity.Entity chicken = newEntityType.create(this.level(), net.minecraft.world.entity.EntitySpawnReason.TRIGGERED); // CraftBukkit
                     if (chicken != null) {
+                        chicken.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), 0.0F); // Folia - region threading - moved up
                         // CraftBukkit start
                         if (chicken.getBukkitEntity() instanceof org.bukkit.entity.Ageable ageable) {
                             ageable.setBaby();
                         }
                         // CraftBukkit end
-                        chicken.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), 0.0F);
+                        // Folia - region threading - move up
                         // CraftBukkit start
                         if (chicken instanceof Chicken realChicken) {
                             Optional.ofNullable(this.getItem().get(DataComponents.CHICKEN_VARIANT))
diff --git a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
index 66df6c69a95c5ca6b07294fdb3b13eee6651d22d..7d8c528a76e6a95d27368bc459d654c6ef66dd8f 100644
--- a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
+++ b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
@@ -52,15 +52,11 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
     }
 
     private void deregisterFromCurrentOwner() {
-        if (this.getOwner() instanceof ServerPlayer serverPlayer) {
-            serverPlayer.deregisterEnderPearl(this);
-        }
+        // Folia - region threading - we remove the registration logic, we do not need to fetch the owner
     }
 
     private void registerToCurrentOwner() {
-        if (this.getOwner() instanceof ServerPlayer serverPlayer) {
-            serverPlayer.registerEnderPearl(this);
-        }
+        // Folia - region threading - we remove the registration logic, we do not need to fetch the owner
     }
 
     @Override
@@ -79,6 +75,81 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
         result.getEntity().hurt(this.damageSources().thrown(this, this.getOwner()), 0.0F);
     }
 
+    // Folia start - region threading
+    private static void attemptTeleport(Entity source, ServerLevel checkWorld, net.minecraft.world.phys.Vec3 to) {
+        final boolean onPortalCooldown = source.isOnPortalCooldown();
+        // ignore retired callback, in those cases we do not want to teleport
+        source.getBukkitEntity().taskScheduler.schedule(
+            (Entity entity) -> {
+                if (!isAllowedToTeleportOwner(entity, checkWorld)) {
+                    return;
+                }
+                // source is now an invalid reference, do not use it, use the entity parameter
+                net.minecraft.world.phys.Vec3 endermitePos = entity.position();
+
+                // dismount from any vehicles, so we can teleport and to prevent desync
+                if (entity.isPassenger()) {
+                    entity.unRide();
+                }
+
+                if (onPortalCooldown) {
+                    entity.setPortalCooldown();
+                }
+
+                entity.teleportAsync(
+                    checkWorld, to, null, null, null,
+                    org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.ENDER_PEARL,
+                    // chunk could have been unloaded
+                    Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS | Entity.TELEPORT_FLAG_LOAD_CHUNK,
+                    (Entity teleported) -> {
+                        // entity is now an invalid reference, do not use it, instead use teleported
+                        if (teleported instanceof ServerPlayer player) {
+                            // connection teleport is already done
+                            ServerLevel world = player.level();
+
+                            // endermite spawn chance
+                            if (world.random.nextFloat() < 0.05F && world.isSpawningMonsters()) {
+                                Endermite entityendermite = (Endermite) EntityType.ENDERMITE.create(world, EntitySpawnReason.TRIGGERED);
+
+                                if (entityendermite != null) {
+                                    float yRot = teleported.getYRot();
+                                    float xRot = teleported.getXRot();
+                                    Runnable spawn = () -> {
+                                        entityendermite.snapTo(endermitePos.x, endermitePos.y, endermitePos.z, yRot, xRot);
+                                        world.addFreshEntity(entityendermite, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.ENDER_PEARL);
+                                    };
+
+                                    if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(world, endermitePos, net.minecraft.world.phys.Vec3.ZERO, 1)) {
+                                        spawn.run();
+                                    } else {
+                                        io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                                            world,
+                                            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkCoordinate(endermitePos.x),
+                                            ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkCoordinate(endermitePos.z),
+                                            spawn
+                                        );
+                                    }
+                                }
+                            }
+
+                            // damage player
+                            teleported.resetFallDistance();
+                            player.resetCurrentImpulseContext();
+                            player.hurtServer(player.level(), player.damageSources().enderPearl().eventEntityDamager(player), 5.0F); // CraftBukkit // Paper - fix DamageSource API
+                            playSound(teleported.level(), to);
+                        } else {
+                            // reset fall damage so that if the entity was falling they do not instantly die
+                            teleported.resetFallDistance();
+                            playSound(teleported.level(), to);
+                        }
+                    }
+                );
+            },
+            null, 1L
+        );
+    }
+    // Folia end - region threading
+
     @Override
     protected void onHit(HitResult result) {
         super.onHit(result);
@@ -97,6 +168,20 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
         }
 
         if (this.level() instanceof ServerLevel serverLevel && !this.isRemoved()) {
+            // Folia start - region threading
+            if (true) {
+                // we can't fire events, because we do not actually know where the other entity is located
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this)) {
+                    throw new IllegalStateException("Must be on tick thread for ticking entity: " + this);
+                }
+                Entity entity = this.getOwnerRaw();
+                if (entity != null) {
+                    attemptTeleport(entity, (ServerLevel)this.level(), this.position());
+                }
+                this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.HIT);
+                return;
+            }
+            // Folia end - region threading
             Entity owner = this.getOwner();
             if (owner != null && isAllowedToTeleportOwner(owner, serverLevel)) {
                 Vec3 vec3 = this.oldPosition();
@@ -196,7 +281,15 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
         }
     }
 
-    private void playSound(Level level, Vec3 pos) {
+    // Folia start - region threading
+    @Override
+    public void preChangeDimension() {
+        super.preChangeDimension();
+        // Don't change the owner here, since the tick logic will consider it anyways.
+    }
+    // Folia end - region threading
+
+    private static void playSound(Level level, Vec3 pos) { // Folia - region threading - static
         level.playSound(null, pos.x, pos.y, pos.z, SoundEvents.PLAYER_TELEPORT, SoundSource.PLAYERS);
     }
 
diff --git a/net/minecraft/world/entity/raid/Raid.java b/net/minecraft/world/entity/raid/Raid.java
index c449d05a4cdb4ea51edfbf01b14f5e4f20b4de00..4deb9e4688a04b25e862572b70bf91e3ace9841e 100644
--- a/net/minecraft/world/entity/raid/Raid.java
+++ b/net/minecraft/world/entity/raid/Raid.java
@@ -128,6 +128,13 @@ public class Raid {
     private int celebrationTicks;
     private Optional<BlockPos> waveSpawnPos = Optional.empty();
 
+    // Folia start - make raids thread-safe
+    public boolean ownsRaid(ServerLevel world) {
+        BlockPos center = this.getCenter();
+        return center != null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(world, center.getX() >> 4, center.getZ() >> 4, 8);
+    }
+    // Folia end - make raids thread-safe
+
     public Raid(BlockPos center, Difficulty difficulty) {
         this.active = true;
         this.raidCooldownTicks = 300;
@@ -223,7 +230,7 @@ public class Raid {
     private Predicate<ServerPlayer> validPlayer() {
         return player -> {
             BlockPos blockPos = player.blockPosition();
-            return player.isAlive() && player.level().getRaidAt(blockPos) == this;
+            return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player) && player.isAlive() && player.level().getRaidAt(blockPos) == this; // Folia - make raids thread-safe
         };
     }
 
@@ -418,12 +425,21 @@ public class Raid {
                         for (UUID uuid : this.heroesOfTheVillage) {
                             Entity entity = level.getEntity(uuid);
                             if (entity instanceof LivingEntity livingEntity && !entity.isSpectator()) {
-                                livingEntity.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true));
+                                //livingEntity.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true)); // Folia start - Fix off region raid heroes - moved down
                                 if (livingEntity instanceof ServerPlayer serverPlayer) {
-                                    serverPlayer.awardStat(Stats.RAID_WIN);
-                                    CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
+                                    //serverPlayer.awardStat(Stats.RAID_WIN); // Folia start - Fix off region raid heroes - moved down
+                                    //CriteriaTriggers.RAID_WIN.trigger(serverPlayer); // Folia start - Fix off region raid heroes - moved down
                                     winners.add(serverPlayer.getBukkitEntity()); // CraftBukkit
                                 }
+                                // Folia start - Fix off region raid heroes
+                                livingEntity.getBukkitEntity().taskScheduler.schedule((LivingEntity lv) -> {
+                                    lv.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.raidOmenLevel - 1, false, false, true));
+                                    if (lv instanceof ServerPlayer serverPlayer) {
+                                        serverPlayer.awardStat(Stats.RAID_WIN);
+                                        CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
+                                    }
+                                }, null, 1L);
+                                // Folia end - Fix off region raid heroes
                             }
                         }
                         org.bukkit.craftbukkit.event.CraftEventFactory.callRaidFinishEvent(level, this, winners); // CraftBukkit
@@ -524,7 +540,7 @@ public class Raid {
         Collection<ServerPlayer> players = this.raidEvent.getPlayers();
         long randomLong = this.random.nextLong();
 
-        for (ServerPlayer serverPlayer : level.players()) {
+        for (ServerPlayer serverPlayer : level.getLocalPlayers()) { // Folia - region threading
             Vec3 vec3 = serverPlayer.position();
             Vec3 vec31 = Vec3.atCenterOf(pos);
             double squareRoot = Math.sqrt((vec31.x - vec3.x) * (vec31.x - vec3.x) + (vec31.z - vec3.z) * (vec31.z - vec3.z));
@@ -706,6 +722,11 @@ public class Raid {
     }
 
     private boolean addWaveMob(ServerLevel level, int wave, Raider raider) {
+        // Folia start - make raids thread-safe
+        if (!this.ownsRaid(level)) {
+            return false;
+        }
+        // Folia end - make raids thread-safe
         return this.addWaveMob(level, wave, raider, true);
     }
 
diff --git a/net/minecraft/world/entity/raid/Raider.java b/net/minecraft/world/entity/raid/Raider.java
index 298d6749bdd5b6f09530096f8f546d9f46910b19..29ddff87216069cdf423f96f3fe835e0802d9ab5 100644
--- a/net/minecraft/world/entity/raid/Raider.java
+++ b/net/minecraft/world/entity/raid/Raider.java
@@ -88,7 +88,7 @@ public abstract class Raider extends PatrollingMonster {
             Raid currentRaid = this.getCurrentRaid();
             if (this.canJoinRaid()) {
                 if (currentRaid == null) {
-                    if (this.level().getGameTime() % 20L == 0L) {
+                    if (this.level().getRedstoneGameTime() % 20L == 0L) { // Folia - region threading
                         Raid raidAt = serverLevel.getRaidAt(this.blockPosition());
                         if (raidAt != null && Raids.canJoinRaid(this)) {
                             raidAt.joinRaid(serverLevel, raidAt.getGroupsSpawned(), this, null, true);
diff --git a/net/minecraft/world/entity/raid/Raids.java b/net/minecraft/world/entity/raid/Raids.java
index 9ded4e75da1efd2fb351fa1544dca33da8455d98..163841c8267b60bd69fe539057681fbb76831cea 100644
--- a/net/minecraft/world/entity/raid/Raids.java
+++ b/net/minecraft/world/entity/raid/Raids.java
@@ -36,16 +36,16 @@ public class Raids extends SavedData {
                 Raids.RaidWithId.CODEC
                     .listOf()
                     .optionalFieldOf("raids", List.of())
-                    .forGetter(raids -> raids.raidMap.int2ObjectEntrySet().stream().map(Raids.RaidWithId::from).toList()),
-                Codec.INT.fieldOf("next_id").forGetter(raids -> raids.nextId),
+                    .forGetter(raids -> raids.raidMap.entrySet().stream().map(Raids.RaidWithId::from).toList()), // Folia - make raids thread-safe
+                Codec.INT.fieldOf("next_id").forGetter(raids -> raids.nextAvailableID.get()), // Folia - make raids thread-safe
                 Codec.INT.fieldOf("tick").forGetter(raids -> raids.tick)
             )
             .apply(instance, Raids::new)
     );
     public static final SavedDataType<Raids> TYPE = new SavedDataType<>("raids", Raids::new, CODEC, DataFixTypes.SAVED_DATA_RAIDS);
     public static final SavedDataType<Raids> TYPE_END = new SavedDataType<>("raids_end", Raids::new, CODEC, DataFixTypes.SAVED_DATA_RAIDS);
-    public final Int2ObjectMap<Raid> raidMap = new Int2ObjectOpenHashMap<>();
-    private int nextId = 1;
+    public final java.util.Map<Integer, Raid> raidMap = new java.util.concurrent.ConcurrentHashMap<>(); // Folia - make raids thread-safe
+    private final java.util.concurrent.atomic.AtomicInteger nextAvailableID = new java.util.concurrent.atomic.AtomicInteger(); // Folia - make raids thread-safe
     private int tick;
 
     public static SavedDataType<Raids> getType(Holder<DimensionType> dimension) {
@@ -53,6 +53,7 @@ public class Raids extends SavedData {
     }
 
     public Raids() {
+        this.nextAvailableID.set(1); // Folia - make raids thread-safe
         this.setDirty();
     }
 
@@ -62,7 +63,7 @@ public class Raids extends SavedData {
             raidWithId.raid.idOrNegativeOne = raidWithId.id; // Paper - expose id of raids while method is kept around as deprecated for removal
         }
 
-        this.nextId = nextId;
+        this.nextAvailableID.set(nextId); // Folia - make raids thread-safe
         this.tick = tick;
     }
 
@@ -71,21 +72,34 @@ public class Raids extends SavedData {
     }
 
     public OptionalInt getId(Raid raid) {
-        for (Entry<Raid> entry : this.raidMap.int2ObjectEntrySet()) {
+        for (java.util.Map.Entry<Integer, Raid> entry : this.raidMap.entrySet()) { // Folia - make raids thread-safe
             if (entry.getValue() == raid) {
-                return OptionalInt.of(entry.getIntKey());
+                return OptionalInt.of(entry.getKey().intValue()); // Folia - make raids thread-safe
             }
         }
 
         return OptionalInt.empty();
     }
 
-    public void tick(ServerLevel level) {
+    // Folia start - make raids thread-safe
+    public void globalTick() {
         this.tick++;
+        if (this.tick % 200 == 0) {
+            this.setDirty();
+        }
+    }
+
+    public void tick(ServerLevel level) {
+        // Folia end - make raids thread-safe
         Iterator<Raid> iterator = this.raidMap.values().iterator();
 
         while (iterator.hasNext()) {
             Raid raid = iterator.next();
+            // Folia start - make raids thread-safe
+            if (!raid.ownsRaid(level)) {
+                continue;
+            }
+            // Folia end - make raids thread-safe
             if (!level.getGameRules().get(GameRules.RAIDS)) {
                 raid.stop();
             }
@@ -98,9 +112,7 @@ public class Raids extends SavedData {
             }
         }
 
-        if (this.tick % 200 == 0) {
-            this.setDirty();
-        }
+        // Folia - make raids thread-safe - move to globalTick()
     }
 
     public static boolean canJoinRaid(Raider raider) {
@@ -112,7 +124,7 @@ public class Raids extends SavedData {
             return null;
         } else {
             ServerLevel serverLevel = player.level();
-            if (!serverLevel.getGameRules().get(GameRules.RAIDS)) {
+            if (!serverLevel.getGameRules().get(GameRules.RAIDS)|| !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player) || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel, pos.getX() >> 4, pos.getZ() >> 4, 8) || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(serverLevel, player.chunkPosition().x, player.chunkPosition().z, 8)) { // Folia - region threading
                 return null;
             } else if (!serverLevel.environmentAttributes().getValue(EnvironmentAttributes.CAN_START_RAID, pos)) {
                 return null;
@@ -151,8 +163,8 @@ public class Raids extends SavedData {
                     }
 
                     if (!raid.isStarted() && !this.raidMap.containsValue(raid)) {
-                        this.raidMap.put(this.getUniqueId(), raid);
-                        raid.idOrNegativeOne = this.nextId; // Paper - expose id of raids while method is kept around as deprecated for removal
+                        int id = this.getUniqueId(); this.raidMap.put(id, raid); // Folia - region threading
+                        raid.idOrNegativeOne = id; // Paper - expose id of raids while method is kept around as deprecated for removal // Folia - region threading
                     }
                     // CraftBukkit end
                     raid.absorbRaidOmen(player);
@@ -174,14 +186,19 @@ public class Raids extends SavedData {
     }
 
     private int getUniqueId() {
-        return ++this.nextId;
+        return this.nextAvailableID.incrementAndGet(); // Folia - make raids thread-safe
     }
 
-    public @Nullable Raid getNearbyRaid(BlockPos pos, int distance) {
+    public @Nullable Raid getNearbyRaid(ServerLevel world, BlockPos pos, int distance) { // Folia - make raids thread-safe - add ServerLevel param
         Raid raid = null;
         double d = distance;
 
         for (Raid raid1 : this.raidMap.values()) {
+            // Folia start - make raids thread-safe
+            if (!raid1.ownsRaid(world)) {
+                continue;
+            }
+            // Folia end - make raids thread-safe
             double d1 = raid1.getCenter().distSqr(pos);
             if (raid1.isActive() && d1 < d) {
                 raid = raid1;
@@ -203,8 +220,8 @@ public class Raids extends SavedData {
                 .apply(instance, Raids.RaidWithId::new)
         );
 
-        public static Raids.RaidWithId from(Entry<Raid> entry) {
-            return new Raids.RaidWithId(entry.getIntKey(), entry.getValue());
+        public static Raids.RaidWithId from(java.util.Map.Entry<Integer, Raid> entry) { // Folia - make raids thread-safe
+            return new Raids.RaidWithId(entry.getKey().intValue(), entry.getValue()); // Folia - make raids thread-safe
         }
     }
 }
diff --git a/net/minecraft/world/entity/variant/StructureCheck.java b/net/minecraft/world/entity/variant/StructureCheck.java
index 0f6866c7fb26a2be8314f55d601533545a3d3610..61906347ce64943acc2172d0f4a09c2443f4dd52 100644
--- a/net/minecraft/world/entity/variant/StructureCheck.java
+++ b/net/minecraft/world/entity/variant/StructureCheck.java
@@ -15,7 +15,7 @@ public record StructureCheck(HolderSet<Structure> requiredStructures) implements
 
     @Override
     public boolean test(SpawnContext context) {
-        return context.level().getLevel().structureManager().getStructureWithPieceAt(context.pos(), this.requiredStructures, context.level()).isValid(); // Paper - Fix swamp hut cat generation deadlock
+        return context.level().getLevel().structureManager().getStructureWithPieceAt(context.pos(), this.requiredStructures).isValid(); // Paper - Fix swamp hut cat generation deadlock // Folia - region threading - properly fix this
     }
 
     @Override
diff --git a/net/minecraft/world/entity/vehicle/minecart/MinecartCommandBlock.java b/net/minecraft/world/entity/vehicle/minecart/MinecartCommandBlock.java
index 21e14ff87fb90541437c4c33e1def56c67e6a939..ec23dfed0a0955ead245ab07cf2e146720710c77 100644
--- a/net/minecraft/world/entity/vehicle/minecart/MinecartCommandBlock.java
+++ b/net/minecraft/world/entity/vehicle/minecart/MinecartCommandBlock.java
@@ -146,5 +146,11 @@ public class MinecartCommandBlock extends AbstractMinecart {
             return (net.minecraft.server.level.ServerLevel) MinecartCommandBlock.this.level();
         }
         // CraftBukkit end
+        // Folia start
+        @Override
+        public void threadCheck() {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(MinecartCommandBlock.this, "Asynchronous sendSystemMessage to a command block");
+        }
+        // Folia end
     }
 }
diff --git a/net/minecraft/world/entity/vehicle/minecart/MinecartHopper.java b/net/minecraft/world/entity/vehicle/minecart/MinecartHopper.java
index 3c961b76769f16160caedce8ec32bb2a2561163f..c24cd09ec2e2a98ed5d904772ebcb0274d9a9483 100644
--- a/net/minecraft/world/entity/vehicle/minecart/MinecartHopper.java
+++ b/net/minecraft/world/entity/vehicle/minecart/MinecartHopper.java
@@ -148,7 +148,7 @@ public class MinecartHopper extends AbstractMinecartContainer implements Hopper
 
     // Paper start
     public void immunize() {
-        this.activatedImmunityTick = Math.max(this.activatedImmunityTick, net.minecraft.server.MinecraftServer.currentTick + 20);
+        this.activatedImmunityTick = Math.max(this.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20);
     }
     // Paper end
 
diff --git a/net/minecraft/world/inventory/AbstractContainerMenu.java b/net/minecraft/world/inventory/AbstractContainerMenu.java
index c533045b6185930fbfe2b98530153453b6e769ee..5be0f260197103264b33cf8a58980455b2b34ec6 100644
--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -713,7 +713,7 @@ public abstract class AbstractContainerMenu {
     }
 
     private static void dropOrPlaceInInventory(Player player, ItemStack stack) {
-        boolean flag = player.isRemoved() && player.getRemovalReason() != Entity.RemovalReason.CHANGED_DIMENSION;
+        boolean flag = (player.getHealth() <= 0.0f) || (player.isRemoved() && player.getRemovalReason() != Entity.RemovalReason.CHANGED_DIMENSION);  // Folia - region threading
         boolean flag1 = player instanceof ServerPlayer serverPlayer && serverPlayer.hasDisconnected();
         if (flag || flag1) {
             player.drop(stack, false);
diff --git a/net/minecraft/world/item/ItemStack.java b/net/minecraft/world/item/ItemStack.java
index b00ad17852e9890f848fc2124e2287885c2b9c5d..8adf67ce0781a54af76ad54d7df51af48e2ff810 100644
--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -383,31 +383,32 @@ public final class ItemStack implements DataComponentHolder {
             DataComponentPatch previousPatch = this.components.asPatch();
             int oldCount = this.getCount();
             ServerLevel serverLevel = (ServerLevel) context.getLevel();
+            io.papermc.paper.threadedregions.RegionizedWorldData worldData = serverLevel.getCurrentWorldData(); // Folia - region threading
 
             if (!(item instanceof BucketItem/* || item instanceof SolidBucketItem*/)) { // if not bucket // Paper - Fix cancelled powdered snow bucket placement
-                serverLevel.captureBlockStates = true;
+                worldData.captureBlockStates = true; // Folia - region threading
                 // special case bonemeal
                 if (item == Items.BONE_MEAL) {
-                    serverLevel.captureTreeGeneration = true;
+                    worldData.captureTreeGeneration = true; // Folia - region threading
                 }
             }
             InteractionResult interactionResult;
             try {
                 interactionResult = item.useOn(context);
             } finally {
-                serverLevel.captureBlockStates = false;
+                worldData.captureBlockStates = false; // Folia - region threading
             }
             DataComponentPatch newPatch = this.components.asPatch();
             int newCount = this.getCount();
             this.setCount(oldCount);
             this.restorePatch(previousPatch);
-            if (interactionResult.consumesAction() && serverLevel.captureTreeGeneration && !serverLevel.capturedBlockStates.isEmpty()) {
-                serverLevel.captureTreeGeneration = false;
+            if (interactionResult.consumesAction() && worldData.captureTreeGeneration && !worldData.capturedBlockStates.isEmpty()) { // Folia - region threading
+                worldData.captureTreeGeneration = false; // Folia - region threading
                 org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(clickedPos, serverLevel);
-                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                net.minecraft.world.level.block.SaplingBlock.treeType = null;
-                List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
-                serverLevel.capturedBlockStates.clear();
+                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeTypeRT.get(); // Folia - region threading
+                net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(null); // Folia - region threading
+                List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(worldData.capturedBlockStates.values()); // Folia - region threading
+                worldData.capturedBlockStates.clear(); // Folia - region threading
                 org.bukkit.event.world.StructureGrowEvent structureEvent = null;
                 if (treeType != null) {
                     boolean isBonemeal = this.getItem() == Items.BONE_MEAL;
@@ -433,15 +434,15 @@ public final class ItemStack implements DataComponentHolder {
                     player.awardStat(Stats.ITEM_USED.get(item)); // SPIGOT-7236 - award stat
                 }
 
-                SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                SignItem.openSign.set(null); // SPIGOT-6758 - Reset on early return // Folia - region threading
                 return interactionResult;
             }
-            serverLevel.captureTreeGeneration = false;
+            worldData.captureTreeGeneration = false; // Folia - region threading
             if (player != null && interactionResult instanceof InteractionResult.Success success && success.wasItemInteraction()) {
                 InteractionHand hand = context.getHand();
                 org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
-                List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
-                serverLevel.capturedBlockStates.clear();
+                List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldData.capturedBlockStates.values()); // Folia - region threading
+                worldData.capturedBlockStates.clear(); // Folia - region threading
                 if (blocks.size() > 1) {
                     placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockMultiPlaceEvent(serverLevel, player, hand, blocks, clickedPos);
                 } else if (blocks.size() == 1 && item != Items.POWDER_SNOW_BUCKET) { // Paper - Fix cancelled powdered snow bucket placement
@@ -452,13 +453,13 @@ public final class ItemStack implements DataComponentHolder {
                     interactionResult = InteractionResult.FAIL; // cancel placement
                     // PAIL: Remove this when MC-99075 fixed
                     player.containerMenu.forceHeldSlot(hand);
-                    serverLevel.capturedTileEntities.clear(); // Paper - Allow chests to be placed with NBT data; clear out block entities as chests and such will pop loot
+                    worldData.capturedTileEntities.clear(); // Paper - Allow chests to be placed with NBT data; clear out block entities as chests and such will pop loot // Folia - region threading
                     // revert back all captured blocks
                     for (org.bukkit.block.BlockState blockstate : blocks) {
                         ((org.bukkit.craftbukkit.block.CraftBlockState) blockstate).revertPlace();
                     }
 
-                    SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
+                    SignItem.openSign.set(null); // SPIGOT-6758 - Reset on early return // Folia - region threading
                 } else {
                     // Change the stack to its new contents if it hasn't been tampered with.
                     if (this.getCount() == oldCount && Objects.equals(this.components.asPatch(), previousPatch)) {
@@ -466,7 +467,7 @@ public final class ItemStack implements DataComponentHolder {
                         this.setCount(newCount);
                     }
 
-                    for (java.util.Map.Entry<BlockPos, net.minecraft.world.level.block.entity.BlockEntity> e : serverLevel.capturedTileEntities.entrySet()) {
+                    for (java.util.Map.Entry<BlockPos, net.minecraft.world.level.block.entity.BlockEntity> e : worldData.capturedTileEntities.entrySet()) { // Folia - region threading
                         serverLevel.setBlockEntity(e.getValue());
                     }
 
@@ -501,15 +502,15 @@ public final class ItemStack implements DataComponentHolder {
                     }
 
                     // SPIGOT-4678
-                    if (this.item instanceof SignItem && SignItem.openSign != null) {
+                    if (this.item instanceof SignItem && SignItem.openSign.get() != null) { // Folia - region threading
                         try {
-                            if (serverLevel.getBlockEntity(SignItem.openSign) instanceof net.minecraft.world.level.block.entity.SignBlockEntity blockEntity) {
-                                if (serverLevel.getBlockState(SignItem.openSign).getBlock() instanceof net.minecraft.world.level.block.SignBlock signBlock) {
+                            if (serverLevel.getBlockEntity(SignItem.openSign.get()) instanceof net.minecraft.world.level.block.entity.SignBlockEntity blockEntity) { // Folia - region threading
+                                if (serverLevel.getBlockState(SignItem.openSign.get()).getBlock() instanceof net.minecraft.world.level.block.SignBlock signBlock) { // Folia - region threading
                                     signBlock.openTextEdit(player, blockEntity, true, io.papermc.paper.event.player.PlayerOpenSignEvent.Cause.PLACE); // CraftBukkit // Paper - Add PlayerOpenSignEvent
                                 }
                             }
                         } finally {
-                            SignItem.openSign = null;
+                            SignItem.openSign.set(null);
                         }
                     }
 
@@ -536,8 +537,8 @@ public final class ItemStack implements DataComponentHolder {
                     player.awardStat(Stats.ITEM_USED.get(item));
                 }
             }
-            serverLevel.capturedTileEntities.clear();
-            serverLevel.capturedBlockStates.clear();
+            worldData.capturedTileEntities.clear(); // Folia - region threading
+            worldData.capturedBlockStates.clear(); // Folia - region threading
             // CraftBukkit end
 
             return interactionResult;
diff --git a/net/minecraft/world/item/MapItem.java b/net/minecraft/world/item/MapItem.java
index 8479f971afdcae0143bbec25ab258485e49722af..097aa2f85ebcb00b4373d81406bd0c2a1192231d 100644
--- a/net/minecraft/world/item/MapItem.java
+++ b/net/minecraft/world/item/MapItem.java
@@ -66,6 +66,7 @@ public class MapItem extends Item {
     }
 
     public void update(Level level, Entity viewer, MapItemSavedData data) {
+        synchronized (data) { // Folia - make map data thread-safe
         if (level.dimension() == data.dimension && viewer instanceof Player) {
             int i = 1 << data.scale;
             int i1 = data.centerX;
@@ -95,8 +96,8 @@ public class MapItem extends Item {
                             int i9 = (i1 / i + i6 - 64) * i;
                             int i10 = (i2 / i + i7 - 64) * i;
                             Multiset<MapColor> multiset = LinkedHashMultiset.create();
-                            LevelChunk chunk = level.getChunkIfLoaded(SectionPos.blockToSectionCoord(i9), SectionPos.blockToSectionCoord(i10)); // Paper - Maps shouldn't load chunks
-                            if (chunk != null && !chunk.isEmpty()) { // Paper - Maps shouldn't load chunks
+                            LevelChunk chunk = level.getChunkIfLoaded(SectionPos.blockToSectionCoord(i9), SectionPos.blockToSectionCoord(i10)); // Paper - Maps shouldn't load chunks // Folia - super important that it uses getChunkIfLoaded
+                            if (chunk != null && !chunk.isEmpty() && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level, chunk.getPos())) { // Paper - Maps shouldn't load chunks // Folia - make sure chunk is owned
                                 int i11 = 0;
                                 double d1 = 0.0;
                                 if (level.dimensionType().hasCeiling()) {
@@ -178,6 +179,7 @@ public class MapItem extends Item {
                 }
             }
         }
+        } // Folia - make map data thread-safe
     }
 
     private BlockState getCorrectStateForFluidBlock(Level level, BlockState state, BlockPos pos) {
@@ -192,6 +194,7 @@ public class MapItem extends Item {
     public static void renderBiomePreviewMap(ServerLevel level, ItemStack stack) {
         MapItemSavedData savedData = getSavedData(stack, level);
         if (savedData != null) {
+            synchronized (savedData) { // Folia - make map data thread-safe
             if (level.dimension() == savedData.dimension) {
                 int i = 1 << savedData.scale;
                 int i1 = savedData.centerX;
@@ -261,6 +264,7 @@ public class MapItem extends Item {
                     }
                 }
             }
+            } // Folia - make map data thread-safe
         }
     }
 
@@ -268,6 +272,7 @@ public class MapItem extends Item {
     public void inventoryTick(ItemStack stack, ServerLevel level, Entity entity, @Nullable EquipmentSlot slot) {
         MapItemSavedData savedData = getSavedData(stack, level);
         if (savedData != null) {
+            synchronized (savedData) { // Folia - region threading
             if (entity instanceof Player player) {
                 savedData.tickCarriedBy(player, stack);
             }
@@ -275,6 +280,7 @@ public class MapItem extends Item {
             if (!savedData.locked && slot != null && slot.getType() == EquipmentSlot.Type.HAND) {
                 this.update(level, entity, savedData);
             }
+            } // Folia - region threading
         }
     }
 
diff --git a/net/minecraft/world/item/SignItem.java b/net/minecraft/world/item/SignItem.java
index 3a41cf80e347ae3b30858879fb91f719625c8bb6..acd0acd364ced2314a0e9a3a51b0806a5f3a7231 100644
--- a/net/minecraft/world/item/SignItem.java
+++ b/net/minecraft/world/item/SignItem.java
@@ -11,7 +11,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import org.jspecify.annotations.Nullable;
 
 public class SignItem extends StandingAndWallBlockItem {
-    public static BlockPos openSign; // CraftBukkit
+    public static final ThreadLocal<BlockPos> openSign = new ThreadLocal<>(); // CraftBukkit // Folia - region threading
     public SignItem(Block standingBlock, Block wallBlock, Item.Properties properties) {
         super(standingBlock, wallBlock, Direction.DOWN, properties);
     }
@@ -30,7 +30,7 @@ public class SignItem extends StandingAndWallBlockItem {
             && level.getBlockState(pos).getBlock() instanceof SignBlock signBlock) {
             // CraftBukkit start - SPIGOT-4678
             // signBlock.openTextEdit(player, signBlockEntity, true);
-            SignItem.openSign = pos;
+            SignItem.openSign.set(pos); // Folia - region threading
             // CraftBukkit end
         }
 
diff --git a/net/minecraft/world/item/component/LodestoneTracker.java b/net/minecraft/world/item/component/LodestoneTracker.java
index 049bb1419dc2d5cf7182dc78a2806264ffe47400..3a28c5e7a58ceb2082b35df955a6d824267a1bf9 100644
--- a/net/minecraft/world/item/component/LodestoneTracker.java
+++ b/net/minecraft/world/item/component/LodestoneTracker.java
@@ -29,7 +29,10 @@ public record LodestoneTracker(Optional<GlobalPos> target, boolean tracked) {
                 return this;
             } else {
                 BlockPos blockPos = this.target.get().pos();
-                return level.isInWorldBounds(blockPos) && (!level.hasChunkAt(blockPos) || level.getPoiManager().existsAtPosition(PoiTypes.LODESTONE, blockPos)) // Paper - Prevent compass from loading chunks
+                // Folia start - do not access the POI data off-region
+                net.minecraft.world.level.chunk.LevelChunk chunk = level.getChunkIfLoaded(blockPos);
+                return level.isInWorldBounds(blockPos) && (chunk == null || chunk.getBlockState(blockPos).getBlock() == net.minecraft.world.level.block.Blocks.LODESTONE) // Paper - Prevent compass from loading chunks
+                // Folia end - do not access the POI data off-region
                     ? this
                     : new LodestoneTracker(Optional.empty(), true);
             }
diff --git a/net/minecraft/world/level/BaseCommandBlock.java b/net/minecraft/world/level/BaseCommandBlock.java
index 183ad542a6589071a37f1036b9bbe7dd141f7ed8..938d3bf93f7f48c07cfdc5de2abf6a635b1ae650 100644
--- a/net/minecraft/world/level/BaseCommandBlock.java
+++ b/net/minecraft/world/level/BaseCommandBlock.java
@@ -91,6 +91,7 @@ public abstract class BaseCommandBlock {
     }
 
     public boolean performCommand(ServerLevel level) {
+        if (true) return false; // Folia - region threading
         if (level.getGameTime() == this.lastExecution) {
             return false;
         } else if ("Searge".equalsIgnoreCase(this.command)) {
@@ -171,9 +172,11 @@ public abstract class BaseCommandBlock {
 
     public abstract boolean isValid();
 
+    public void threadCheck() {} // Folia
+
     public class CloseableCommandBlockSource implements CommandSource, AutoCloseable { // Paper - public
         private final ServerLevel level;
-        private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm:ss", Locale.ROOT);
+        private static final ThreadLocal<DateTimeFormatter> TIME_FORMAT = ThreadLocal.withInitial(() -> DateTimeFormatter.ofPattern("HH:mm:ss", Locale.ROOT)); // Folia - region threading - SDF is not thread-safe
         private boolean closed;
 
         // Paper start - add back source when output disabled
@@ -207,7 +210,8 @@ public abstract class BaseCommandBlock {
         public void sendSystemMessage(Component message) {
             if (this.trackOutput && !this.closed) { // Paper - add back source when output disabled
                 org.spigotmc.AsyncCatcher.catchOp("sendSystemMessage to a command block"); // Paper - Don't broadcast messages to command blocks
-                BaseCommandBlock.this.lastOutput = Component.literal("[" + TIME_FORMAT.format(ZonedDateTime.now()) + "] ").append(message);
+                BaseCommandBlock.this.threadCheck(); // Folia
+                BaseCommandBlock.this.lastOutput = Component.literal("[" + TIME_FORMAT.get().format(ZonedDateTime.now()) + "] ").append(message); // Folia - region threading - SDF is not thread-safe
                 BaseCommandBlock.this.onUpdated(this.level);
             }
         }
diff --git a/net/minecraft/world/level/EntityGetter.java b/net/minecraft/world/level/EntityGetter.java
index bcbe39eed2d254861689c95f7040f27b6ff2d438..d49c42c60c8e2174e3654cc09acbd47e78aad0be 100644
--- a/net/minecraft/world/level/EntityGetter.java
+++ b/net/minecraft/world/level/EntityGetter.java
@@ -24,6 +24,12 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
         return this.getEntities(EntityTypeTest.forClass(entityClass), area, filter);
     }
 
+    // Folia start - region threading
+    default List<? extends Player> getLocalPlayers() {
+        return java.util.Collections.emptyList();
+    }
+    // Folia end - region threading
+
     List<? extends Player> players();
 
     default List<Entity> getEntities(@Nullable Entity entity, AABB area) {
@@ -122,7 +128,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
         double d = -1.0;
         Player player = null;
 
-        for (Player player1 : this.players()) {
+        for (Player player1 : this.getLocalPlayers()) { // Folia - region threading
             if (predicate == null || predicate.test(player1)) {
                 double d1 = player1.distanceToSqr(x, y, z);
                 if ((distance < 0.0 || d1 < distance * distance) && (d == -1.0 || d1 < d)) {
@@ -143,7 +149,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     default List<org.bukkit.entity.HumanEntity> findNearbyBukkitPlayers(double x, double y, double z, double radius, @Nullable Predicate<Entity> predicate) {
         com.google.common.collect.ImmutableList.Builder<org.bukkit.entity.HumanEntity> builder = com.google.common.collect.ImmutableList.builder();
 
-        for (Player human : this.players()) {
+        for (Player human : this.getLocalPlayers()) { // Folia - region threading
             if (predicate == null || predicate.test(human)) {
                 double distanceSquared = human.distanceToSqr(x, y, z);
 
@@ -168,7 +174,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
 
     // Paper start - Affects Spawning API
     default boolean hasNearbyAlivePlayerThatAffectsSpawning(double x, double y, double z, double range) {
-        for (Player player : this.players()) {
+        for (Player player : this.getLocalPlayers()) { // Folia - region threading
             if (EntitySelector.PLAYER_AFFECTS_SPAWNING.test(player)) { // combines NO_SPECTATORS and LIVING_ENTITY_STILL_ALIVE with an "affects spawning" check
                 double distanceSqr = player.distanceToSqr(x, y, z);
                 if (range < 0.0D || distanceSqr < range * range) {
@@ -181,7 +187,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     // Paper end - Affects Spawning API
 
     default boolean hasNearbyAlivePlayer(double x, double y, double z, double distance) {
-        for (Player player : this.players()) {
+        for (Player player : this.getLocalPlayers()) { // Folia - region threading
             if (EntitySelector.NO_SPECTATORS.test(player) && EntitySelector.LIVING_ENTITY_STILL_ALIVE.test(player)) {
                 double d = player.distanceToSqr(x, y, z);
                 if (distance < 0.0 || d < distance * distance) {
@@ -194,8 +200,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     }
 
     default @Nullable Player getPlayerByUUID(UUID uniqueId) {
-        for (int i = 0; i < this.players().size(); i++) {
-            Player player = this.players().get(i);
+        for (Player player : this.getLocalPlayers()) { // Folia - region threading
             if (uniqueId.equals(player.getUUID())) {
                 return player;
             }
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 0df3a12f64f9c48561d64059289727b18239d6ce..faa9fd5d905896e366c800263d3115ae4c6a919c 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -112,10 +112,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         .add(new ExplosionParticleInfo(ParticleTypes.POOF, 0.5F, 1.0F))
         .add(new ExplosionParticleInfo(ParticleTypes.SMOKE, 1.0F, 1.0F))
         .build();
-    public final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList();
-    protected final CollectingNeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
-    private boolean tickingBlockEntities;
+    //public final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); // Folia - region threading
+    public final int neighbourUpdateMax; //protected final CollectingNeighborUpdater neighborUpdater; // Folia - region threading
+    //private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList(); // Folia - region threading
+    //private boolean tickingBlockEntities; // Folia - region threading
     public final Thread thread;
     private final boolean isDebug;
     private int skyDarken;
@@ -125,7 +125,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public float rainLevel;
     protected float oThunderLevel;
     public float thunderLevel;
-    public final RandomSource random = new ca.spottedleaf.moonrise.common.util.ThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()); // Paper - replace random
+    public final RandomSource random = io.papermc.paper.threadedregions.util.ThreadLocalRandomSource.INSTANCE; // Paper - replace random // Folia - region threading
     @Deprecated
     private final RandomSource threadSafeRandom = RandomSource.createThreadSafe();
     private final Holder<DimensionType> dimensionTypeRegistration;
@@ -136,7 +136,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private final PalettedContainerFactory palettedContainerFactory;
-    private long subTickCount;
+    private final java.util.concurrent.atomic.AtomicLong subTickCount = new java.util.concurrent.atomic.AtomicLong(); //private long subTickCount; // Folia - region threading
 
     // CraftBukkit start
     public final io.papermc.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
@@ -144,20 +144,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public net.kyori.adventure.util.TriState pvpMode = net.kyori.adventure.util.TriState.NOT_SET;
     public org.bukkit.generator.@Nullable ChunkGenerator generator;
 
-    public boolean captureBlockStates = false;
-    public boolean captureTreeGeneration = false;
-    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper - Retain block place order when capturing blockstates
-    @Nullable
-    public List<net.minecraft.world.entity.item.ItemEntity> captureDrops;
+    // Folia - region threading - moved to regionised data
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
-    // Paper start - EAR 2
-    public int wakeupInactiveRemainingAnimals;
-    public int wakeupInactiveRemainingFlying;
-    public int wakeupInactiveRemainingMonsters;
-    public int wakeupInactiveRemainingVillagers;
-    // Paper end - EAR 2
-    public boolean populating;
+    // Folia - region threading - moved to regionised data
+    // Folia - region threading
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
     // Paper start - add paper world config
     private final io.papermc.paper.configuration.WorldConfiguration paperConfig;
@@ -167,9 +157,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     // Paper end - add paper world config
 
     public static @Nullable BlockPos lastPhysicsProblem; // Spigot
-    private int tileTickPosition;
-    public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions
-    public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here
+    //private int tileTickPosition; // Folia - region threading
+    //public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions // Folia - region threading
+    //public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here // Folia - region threading
 
     public CraftWorld getWorld() {
         return this.world;
@@ -818,6 +808,32 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return chunk != null ? chunk.getNoiseBiome(x, y, z) : this.getUncachedNoiseBiome(x, y, z);
     }
     // Paper end - optimise random ticking
+    // Folia start - region ticking
+    public final io.papermc.paper.threadedregions.RegionizedData<io.papermc.paper.threadedregions.RegionizedWorldData> worldRegionData
+        = new io.papermc.paper.threadedregions.RegionizedData<>(
+        (ServerLevel)this, (regionData) -> new io.papermc.paper.threadedregions.RegionizedWorldData((ServerLevel)Level.this, regionData),
+        io.papermc.paper.threadedregions.RegionizedWorldData.REGION_CALLBACK
+    );
+    public volatile io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData tickData;
+    public final java.util.concurrent.ConcurrentHashMap.KeySetView<net.minecraft.server.level.ChunkHolder, Boolean> needsChangeBroadcasting = java.util.concurrent.ConcurrentHashMap.newKeySet();
+
+    public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldData() {
+        final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
+        if (ret == null) {
+            return ret;
+        }
+        Level world = ret.world;
+        if (world != this) {
+            throw new IllegalStateException("World mismatch: expected " + this.getWorld().getName() + " but got " + world.getWorld().getName());
+        }
+        return ret;
+    }
+
+    @Override
+    public List<net.minecraft.server.level.ServerPlayer> getLocalPlayers() {
+        return this.getCurrentWorldData().getLocalPlayers();
+    }
+    // Folia end - region ticking
 
     protected Level(
         WritableLevelData levelData,
@@ -862,7 +878,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.thread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, biomeZoomSeed);
         this.isDebug = isDebug;
-        this.neighborUpdater = new CollectingNeighborUpdater(this, maxChainedNeighborUpdates);
+        this.neighbourUpdateMax = maxChainedNeighborUpdates; // Folia - region threading
         this.registryAccess = registryAccess;
         this.palettedContainerFactory = PalettedContainerFactory.create(registryAccess);
         this.damageSources = new DamageSources(registryAccess);
@@ -980,8 +996,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     @Nullable
     public final BlockState getBlockStateIfLoaded(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
-            CraftBlockState previous = this.capturedBlockStates.get(pos);
+        if (this.getCurrentWorldData().captureTreeGeneration) { // Folia - region threading
+            CraftBlockState previous = this.getCurrentWorldData().capturedBlockStates.get(pos); // Folia - region threading
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -1044,16 +1060,18 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, @Block.UpdateFlags int flags, int recursionLeft) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, pos, "Updating block asynchronously"); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.getCurrentWorldData(); // Folia - region threading
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
+        if (worldData.captureTreeGeneration) { // Folia - region threading
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
             BlockState type = getBlockState(pos);
             if (!type.isDestroyable()) return false;
             // Paper end - Protect Bedrock and End Portal/Frames from being destroyed
-            CraftBlockState blockstate = this.capturedBlockStates.get(pos);
+            CraftBlockState blockstate = worldData.capturedBlockStates.get(pos); // Folia - region threading
             if (blockstate == null) {
                 blockstate = org.bukkit.craftbukkit.block.CapturedBlockState.getTreeBlockState(this, pos, flags);
-                this.capturedBlockStates.put(pos.immutable(), blockstate);
+                worldData.capturedBlockStates.put(pos.immutable(), blockstate); // Folia - region threading
             }
             blockstate.setData(state);
             blockstate.setFlags(flags);
@@ -1069,14 +1087,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             Block block = state.getBlock();
             // CraftBukkit start - capture blockstates
             boolean captured = false;
-            if (this.captureBlockStates) {
+            if (worldData.captureBlockStates) { // Folia - region threading
                 final CraftBlockState snapshot;
-                if (!this.capturedBlockStates.containsKey(pos)) {
+                if (!worldData.capturedBlockStates.containsKey(pos)) { // Folia - region threading
                     snapshot = (CraftBlockState) org.bukkit.craftbukkit.block.CraftBlock.at(this, pos).getState(); // Paper - use CB getState to get a suitable snapshot
-                    this.capturedBlockStates.put(pos.immutable(), snapshot);
+                    worldData.capturedBlockStates.put(pos.immutable(), snapshot); // Folia - region threading
                     captured = true;
                 } else {
-                    snapshot = this.capturedBlockStates.get(pos);
+                    snapshot = worldData.capturedBlockStates.get(pos); // Folia - region threading
                 }
                 snapshot.setFlags(flags); // Paper - always set the flag of the most recent call to mitigate issues with multiple update at the same pos with different flags
             }
@@ -1085,8 +1103,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             // CraftBukkit end
             if (blockState == null) {
                 // CraftBukkit start - remove blockstate if failed (or the same)
-                if (this.captureBlockStates && captured) {
-                    this.capturedBlockStates.remove(pos);
+                if (worldData.captureBlockStates && captured) { // Folia - region threading
+                    worldData.capturedBlockStates.remove(pos); // Folia - region threading
                 }
                 // CraftBukkit end
                 return false;
@@ -1123,7 +1141,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 */
 
                 // CraftBukkit start
-                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                if (!worldData.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates // Folia - region threading
                     // Modularize client and physic updates
                     // Spigot start
                     try {
@@ -1167,7 +1185,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 // CraftBukkit start
                 blockState.updateIndirectNeighbourShapes(this, pos, i, recursionLeft - 1); // Don't call an event for the old block to limit event spam
                 boolean cancelledUpdates = false; // Paper - Fix block place logic
-                if (((ServerLevel)this).hasPhysicsEvent) { // Paper - BlockPhysicsEvent
+                if (((ServerLevel)this).getCurrentWorldData().hasPhysicsEvent) { // Paper - BlockPhysicsEvent // Folia - region threading
                     org.bukkit.event.block.BlockPhysicsEvent event = new org.bukkit.event.block.BlockPhysicsEvent(org.bukkit.craftbukkit.block.CraftBlock.at(this, pos), CraftBlockData.fromData(state));
                     cancelledUpdates = !event.callEvent(); // Paper - Fix block place logic
                 }
@@ -1262,7 +1280,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public void neighborShapeChanged(
         Direction direction, BlockPos pos, BlockPos neighborPos, BlockState neighborState, @Block.UpdateFlags int flags, int recursionLeft
     ) {
-        this.neighborUpdater.shapeUpdate(direction, neighborState, pos, neighborPos, flags, recursionLeft);
+        this.getCurrentWorldData().neighborUpdater.shapeUpdate(direction, neighborState, pos, neighborPos, flags, recursionLeft); // Folia - region threading
     }
 
     @Override
@@ -1286,11 +1304,34 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.getChunkSource().getLightEngine();
     }
 
+    // Folia start - region threading
+    @Nullable
+    public BlockState getBlockStateFromEmptyChunkIfLoaded(BlockPos pos) {
+        net.minecraft.server.level.ServerChunkCache chunkProvider = (net.minecraft.server.level.ServerChunkCache)this.getChunkSource();
+        ChunkAccess chunk = chunkProvider.getChunkAtImmediately(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk != null) {
+            return chunk.getBlockState(pos);
+        }
+        return null;
+    }
+
+    @Nullable
+    public BlockState getBlockStateFromEmptyChunk(BlockPos pos) {
+        net.minecraft.server.level.ServerChunkCache chunkProvider = (net.minecraft.server.level.ServerChunkCache)this.getChunkSource();
+        ChunkAccess chunk = chunkProvider.getChunkAtImmediately(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk != null) {
+            return chunk.getBlockState(pos);
+        }
+        chunk = chunkProvider.getChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.EMPTY, true);
+        return chunk.getBlockState(pos);
+    }
+    // Folia end - region threading
+
     @Override
     public BlockState getBlockState(BlockPos pos) {
         // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
-            CraftBlockState previous = this.capturedBlockStates.get(pos); // Paper
+        if (this.getCurrentWorldData().captureTreeGeneration) { // Folia - region threading
+            CraftBlockState previous = this.getCurrentWorldData().capturedBlockStates.get(pos); // Paper // Folia - region threading
             if (previous != null) {
                 return previous.getHandle();
             }
@@ -1388,15 +1429,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
-        (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
+        ((ServerLevel)this).getCurrentWorldData().addBlockEntityTicker(ticker); // Folia - regionised ticking
     }
 
     public void tickBlockEntities() {
-        this.tickingBlockEntities = true;
-        if (!this.pendingBlockEntityTickers.isEmpty()) {
-            this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
-            this.pendingBlockEntityTickers.clear();
-        }
+        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
+        regionizedWorldData.seTtickingBlockEntities(true); // Folia - regionised ticking
+        regionizedWorldData.pushPendingTickingBlockEntities(); // Folia - regionised ticking
+        List<TickingBlockEntity> blockEntityTickers = regionizedWorldData.getBlockEntityTickers(); // Folia - regionised ticking
 
         // Spigot start
         boolean runsNormally = this.tickRateManager().runsNormally();
@@ -1404,8 +1444,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         int tickedEntities = 0; // Paper - rewrite chunk system
         var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll
         toRemove.add(null); // Paper - Fix MC-117075
-        for (this.tileTickPosition = 0; this.tileTickPosition < this.blockEntityTickers.size(); this.tileTickPosition++) { // Paper - Disable tick limiters
-            TickingBlockEntity tickingBlockEntity = this.blockEntityTickers.get(this.tileTickPosition);
+        for (int i = 0; i < blockEntityTickers.size(); i++) { // Paper - Disable tick limiters // Folia - regionised ticking
+            TickingBlockEntity tickingBlockEntity = blockEntityTickers.get(i); // Folia - regionised ticking
             // Spigot end
             if (tickingBlockEntity.isRemoved()) {
                 toRemove.add(tickingBlockEntity); // Paper - Fix MC-117075; use removeAll
@@ -1418,10 +1458,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 // Paper end - rewrite chunk system
             }
         }
-        this.blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075
+        blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075 // Folia - regionised ticking
 
-        this.tickingBlockEntities = false;
-        this.spigotConfig.currentPrimedTnt = 0; // Spigot
+        regionizedWorldData.seTtickingBlockEntities(false); // Folia - regionised ticking
+        regionizedWorldData.currentPrimedTnt = 0; // Spigot // Folia - region threading
     }
 
     public <T extends Entity> void guardEntityTick(Consumer<T> action, T entity) {
@@ -1432,7 +1472,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
             MinecraftServer.LOGGER.error(msg, var6);
             getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, var6))); // Paper - ServerExceptionEvent
-            entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+            if (!(entity instanceof net.minecraft.server.level.ServerPlayer)) entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD); // Folia - properly disconnect players
+            if (entity instanceof net.minecraft.server.level.ServerPlayer player) player.connection.disconnect(net.minecraft.network.chat.Component.translatable("multiplayer.disconnect.generic"), org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN); // Folia - properly disconnect players
             // Paper end - Prevent block entity and entity crashes
         }
         this.moonrise$midTickTasks(); // Paper - rewrite chunk system
@@ -1576,9 +1617,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public @Nullable BlockEntity getBlockEntity(BlockPos pos) {
+        // Folia start - region threading
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) {
+            return null;
+        }
+        // Folia end - region threading
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
-        if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(pos)) != null) {
+        if (!this.getCurrentWorldData().capturedTileEntities.isEmpty() && (blockEntity = this.getCurrentWorldData().capturedTileEntities.get(pos)) != null) { // Folia - region threading
             return blockEntity;
         }
         // Paper end - Perf: Optimize capturedTileEntities lookup
@@ -1595,8 +1641,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         BlockPos blockPos = blockEntity.getBlockPos();
         if (this.isInValidBounds(blockPos)) {
             // CraftBukkit start
-            if (this.captureBlockStates) {
-                this.capturedTileEntities.put(blockPos.immutable(), blockEntity);
+            if (this.getCurrentWorldData().captureBlockStates) { // Folia - region threading
+                this.getCurrentWorldData().capturedTileEntities.put(blockPos.immutable(), blockEntity); // Folia - region threading
                 return;
             }
             // CraftBukkit end
@@ -1673,6 +1719,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AABB boundingBox, Predicate<? super Entity> predicate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, boundingBox, "Cannot getEntities asynchronously"); // Folia - region threading
         Profiler.get().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
 
@@ -1702,6 +1749,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public <T extends Entity> void getEntities(final EntityTypeTest<Entity, T> entityTypeTest,
                                                final AABB boundingBox, final Predicate<? super T> predicate,
                                                final List<? super T> into, final int maxCount) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, boundingBox, "Cannot getEntities asynchronously"); // Folia - region threading
         Profiler.get().incrementCounter("getEntities");
 
         if (entityTypeTest instanceof net.minecraft.world.entity.EntityType<T> byType) {
@@ -1840,9 +1888,29 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public void onBlockEntityAdded(BlockEntity entity) {
     }
 
+    // Folia start - region threading
+    @Override
+    public long getGameTime() {
+        // Dumb world gen thread calls this for some reason. So, check for null.
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.getCurrentWorldData();
+        return worldData == null ? this.getLevelData().getGameTime() : worldData.getTickData().nonRedstoneGameTime();
+    }
+    // Folia end - region threading
+
     public long getDayTime() {
-        return this.levelData.getDayTime();
+        // Folia start - region threading
+        // Dumb world gen thread calls this for some reason. So, check for null.
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.getCurrentWorldData();
+        return worldData == null ? this.getLevelData().getDayTime() : worldData.getTickData().dayTime();
+        // Folia end - region threading
+    }
+
+    // Folia start - region threading
+    @Override
+    public long getRedstoneGameTime() {
+        return this.getCurrentWorldData().getRedstoneGameTime();
     }
+    // Folia end - region threading
 
     public boolean mayInteract(Entity entity, BlockPos pos) {
         return true;
@@ -2005,8 +2073,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public abstract RecipeAccess recipeAccess();
 
     public BlockPos getBlockRandomPos(int x, int y, int z, int yMask) {
-        this.randValue = this.randValue * 3 + 1013904223;
-        int i = this.randValue >> 2;
+        int i = this.random.nextInt() >> 2; // Folia - region threading
         return new BlockPos(x + (i & 15), y + (i >> 16 & yMask), z + (i >> 8 & 15));
     }
 
@@ -2027,7 +2094,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public long nextSubTickCount() {
-        return this.subTickCount++;
+        return this.subTickCount.getAndIncrement(); // Folia - region threading
     }
 
     @Override
diff --git a/net/minecraft/world/level/LevelAccessor.java b/net/minecraft/world/level/LevelAccessor.java
index 21d5042282a4eeaadfbb1057f5995e90acc7388e..0a373007cf664422f0bd089652617c32865435e5 100644
--- a/net/minecraft/world/level/LevelAccessor.java
+++ b/net/minecraft/world/level/LevelAccessor.java
@@ -26,19 +26,25 @@ import org.jspecify.annotations.Nullable;
 public interface LevelAccessor extends CommonLevelAccessor, LevelReader, ScheduledTickAccess {
     long nextSubTickCount();
 
+    // Folia start - region threading
+    default long getRedstoneGameTime() {
+        return this.getLevelData().getGameTime();
+    }
+    // Folia end - region threading
+
     @Override
     default <T> ScheduledTick<T> createTick(BlockPos pos, T type, int delay, TickPriority priority) {
-        return new ScheduledTick<>(type, pos, this.getGameTime() + delay, priority, this.nextSubTickCount());
+        return new ScheduledTick<>(type, pos, this.getRedstoneGameTime() + delay, priority, this.nextSubTickCount()); // Folia - region threading
     }
 
     @Override
     default <T> ScheduledTick<T> createTick(BlockPos pos, T type, int delay) {
-        return new ScheduledTick<>(type, pos, this.getGameTime() + delay, this.nextSubTickCount());
+        return new ScheduledTick<>(type, pos, this.getRedstoneGameTime() + delay, this.nextSubTickCount()); // Folia - region threading
     }
 
     LevelData getLevelData();
 
-    default long getGameTime() {
+    default long getGameTime() { // Folia - region threading - make sure this is present
         return this.getLevelData().getGameTime();
     }
 
diff --git a/net/minecraft/world/level/LevelReader.java b/net/minecraft/world/level/LevelReader.java
index fd5a38a9f24c26f8eca738f78180446d354ff3ac..91f8027e2421fb4cdd75d1dbc1305cff7bc00d84 100644
--- a/net/minecraft/world/level/LevelReader.java
+++ b/net/minecraft/world/level/LevelReader.java
@@ -205,6 +205,25 @@ public interface LevelReader extends ca.spottedleaf.moonrise.patches.chunk_syste
         return toY >= this.getMinY() && fromY <= this.getMaxY() && this.hasChunksAt(fromX, fromZ, toX, toZ);
     }
 
+    // Folia start - region threading
+    default boolean hasAndOwnsChunksAt(int minX, int minZ, int maxX, int maxZ) {
+        int i = SectionPos.blockToSectionCoord(minX);
+        int j = SectionPos.blockToSectionCoord(maxX);
+        int k = SectionPos.blockToSectionCoord(minZ);
+        int l = SectionPos.blockToSectionCoord(maxZ);
+
+        for(int m = i; m <= j; ++m) {
+            for(int n = k; n <= l; ++n) {
+                if (!this.hasChunk(m, n) || (this instanceof net.minecraft.server.level.ServerLevel world && !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(world, m, n))) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+    // Folia end - region threading
+
     @Deprecated
     default boolean hasChunksAt(int fromX, int fromZ, int toX, int toZ) {
         int sectionPosCoord = SectionPos.blockToSectionCoord(fromX);
diff --git a/net/minecraft/world/level/NaturalSpawner.java b/net/minecraft/world/level/NaturalSpawner.java
index 4e5078495037078922ab6350a500acdabe177ca5..e661f80c1f8dbce666872788a0dd478fe397088d 100644
--- a/net/minecraft/world/level/NaturalSpawner.java
+++ b/net/minecraft/world/level/NaturalSpawner.java
@@ -134,7 +134,7 @@ public final class NaturalSpawner {
             int limit = mobCategory.getMaxInstancesPerChunk();
             org.bukkit.entity.SpawnCategory spawnCategory = org.bukkit.craftbukkit.util.CraftSpawnCategory.toBukkit(mobCategory);
             if (org.bukkit.craftbukkit.util.CraftSpawnCategory.isValidForLimits(spawnCategory)) {
-                spawnThisTick = level.ticksPerSpawnCategory.getLong(spawnCategory) != 0 && worlddata.getGameTime() % level.ticksPerSpawnCategory.getLong(spawnCategory) == 0;
+                spawnThisTick = level.ticksPerSpawnCategory.getLong(spawnCategory) != 0 && level.getRedstoneGameTime() % level.ticksPerSpawnCategory.getLong(spawnCategory) == 0; // Folia - region threading
                 limit = level.getWorld().getSpawnLimit(spawnCategory);
             }
 
diff --git a/net/minecraft/world/level/ServerExplosion.java b/net/minecraft/world/level/ServerExplosion.java
index 6279596058f76f113d238be3201cb0c6e6b49566..c8fa9a9ae29ecf9b2d6234e7efee61d05c8bc0ae 100644
--- a/net/minecraft/world/level/ServerExplosion.java
+++ b/net/minecraft/world/level/ServerExplosion.java
@@ -746,17 +746,18 @@ public class ServerExplosion implements Explosion {
         if (!this.level.paperConfig().environment.optimizeExplosions) {
             return this.getSeenFraction(vec3d, entity, this.directMappedBlockCache, this.mutablePos); // Paper - collision optimisations
         }
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
         CacheKey key = new CacheKey(this, entity.getBoundingBox());
-        Float blockDensity = this.level.explosionDensityCache.get(key);
+        Float blockDensity = worldData.explosionDensityCache.get(key); // Folia - region threading
         if (blockDensity == null) {
             blockDensity = this.getSeenFraction(vec3d, entity, this.directMappedBlockCache, this.mutablePos); // Paper - collision optimisations
-            this.level.explosionDensityCache.put(key, blockDensity);
+            worldData.explosionDensityCache.put(key, blockDensity); // Folia - region threading
         }
 
         return blockDensity;
     }
 
-    static class CacheKey {
+    public static class CacheKey { // Folia - region threading - public
         private final Level world;
         private final double posX, posY, posZ;
         private final double minX, minY, minZ;
diff --git a/net/minecraft/world/level/ServerLevelAccessor.java b/net/minecraft/world/level/ServerLevelAccessor.java
index d6065a576301deb8eb9a33a70f0ce44c9de9edf9..6a7a8273d215b6193d054f31ad543cdb2ed76745 100644
--- a/net/minecraft/world/level/ServerLevelAccessor.java
+++ b/net/minecraft/world/level/ServerLevelAccessor.java
@@ -8,6 +8,12 @@ import net.minecraft.world.entity.Entity;
 public interface ServerLevelAccessor extends LevelAccessor {
     ServerLevel getLevel();
 
+    // Folia start - region threading
+    default public StructureManager structureManager() {
+        throw new UnsupportedOperationException();
+    }
+    // Folia end - region threading
+
     DifficultyInstance getCurrentDifficultyAt(BlockPos pos);
 
     default void addFreshEntityWithPassengers(Entity entity) {
diff --git a/net/minecraft/world/level/StructureManager.java b/net/minecraft/world/level/StructureManager.java
index 471f743105613c4d72f87dbc96a08de581f8ca40..4f3d82a83f6616be4a2c0464d1061c63686f27be 100644
--- a/net/minecraft/world/level/StructureManager.java
+++ b/net/minecraft/world/level/StructureManager.java
@@ -48,12 +48,7 @@ public class StructureManager {
     }
 
     public List<StructureStart> startsForStructure(ChunkPos chunkPos, Predicate<Structure> structurePredicate) {
-        // Paper start - Fix swamp hut cat generation deadlock
-        return this.startsForStructure(chunkPos, structurePredicate, null);
-    }
-
-    public List<StructureStart> startsForStructure(ChunkPos chunkPos, Predicate<Structure> structurePredicate, @Nullable ServerLevelAccessor levelAccessor) {
-        Map<Structure, LongSet> allReferences = (levelAccessor == null ? this.level : levelAccessor).getChunk(chunkPos.x, chunkPos.z, ChunkStatus.STRUCTURE_REFERENCES).getAllReferences();
+        Map<Structure, LongSet> allReferences = this.level.getChunk(chunkPos.x, chunkPos.z, ChunkStatus.STRUCTURE_REFERENCES).getAllReferences(); // Folia - region threading
         // Paper end - Fix swamp hut cat generation deadlock
         Builder<StructureStart> builder = ImmutableList.builder();
 
@@ -119,29 +114,16 @@ public class StructureManager {
     }
 
     public StructureStart getStructureWithPieceAt(BlockPos pos, HolderSet<Structure> structures) {
-    // Paper start - Fix swamp hut cat generation deadlock
-        return this.getStructureWithPieceAt(pos, structures, null);
-    }
-    public StructureStart getStructureWithPieceAt(BlockPos pos, HolderSet<Structure> structures, final @Nullable ServerLevelAccessor levelAccessor) {
-        return this.getStructureWithPieceAt(pos, structures::contains, levelAccessor);
-    // Paper end - Fix swamp hut cat generation deadlock
+        return this.getStructureWithPieceAt(pos, structures::contains); // Folia - region threading
     }
 
     public StructureStart getStructureWithPieceAt(BlockPos pos, Predicate<Holder<Structure>> predicate) {
-        // Paper start - Fix swamp hut cat generation deadlock
-        return this.getStructureWithPieceAt(pos, predicate, null);
-    }
-
-    public StructureStart getStructureWithPieceAt(BlockPos pos, TagKey<Structure> tag, @Nullable ServerLevelAccessor levelAccessor) {
-        return this.getStructureWithPieceAt(pos, structure -> structure.is(tag), levelAccessor);
-    }
-
-    public StructureStart getStructureWithPieceAt(BlockPos pos, Predicate<Holder<Structure>> predicate, @Nullable ServerLevelAccessor levelAccessor) {
+        // Folia - region threading
         // Paper end - Fix swamp hut cat generation deadlock
         Registry<Structure> registry = this.registryAccess().lookupOrThrow(Registries.STRUCTURE);
 
         for (StructureStart structureStart : this.startsForStructure(
-            new ChunkPos(pos), structure -> registry.get(registry.getId(structure)).map(predicate::test).orElse(false), levelAccessor // Paper - Fix swamp hut cat generation deadlock
+            new ChunkPos(pos), structure -> registry.get(registry.getId(structure)).map(predicate::test).orElse(false) // Paper - Fix swamp hut cat generation deadlock // Folia - region threading
         )) {
             if (this.structureHasPieceAt(pos, structureStart)) {
                 return structureStart;
@@ -186,7 +168,7 @@ public class StructureManager {
     }
 
     public void addReference(StructureStart structureStart) {
-        structureStart.addReference();
+        //structureStart.addReference(); // Folia - region threading - move to caller
         this.structureCheck.incrementReference(structureStart.getChunkPos(), structureStart.getStructure());
     }
 
diff --git a/net/minecraft/world/level/block/BedBlock.java b/net/minecraft/world/level/block/BedBlock.java
index 7bfc62120cae4c5e83cb0d86b759b7ffb2336a95..19f3bee51888fd3cad0281a5918d1489c5a56b57 100644
--- a/net/minecraft/world/level/block/BedBlock.java
+++ b/net/minecraft/world/level/block/BedBlock.java
@@ -336,7 +336,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
             BlockPos blockPos = pos.relative(state.getValue(FACING));
             level.setBlock(blockPos, state.setValue(PART, BedPart.HEAD), Block.UPDATE_ALL);
             // CraftBukkit start - SPIGOT-7315: Don't updated if we capture block states
-            if (level.captureBlockStates) {
+            if (level.getCurrentWorldData().captureBlockStates) { // Folia - region threading
                 return;
             }
             // CraftBukkit end
diff --git a/net/minecraft/world/level/block/Block.java b/net/minecraft/world/level/block/Block.java
index ab08211e0f64a14a335e3cc4479bcf1f82e25cdd..13f06f1fbdf77b88493333b481b951d729579f11 100644
--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -458,8 +458,8 @@ public class Block extends BlockBehaviour implements ItemLike {
             ItemEntity itemEntity = itemEntitySupplier.get();
             itemEntity.setDefaultPickUpDelay();
             // CraftBukkit start
-            if (level.captureDrops != null) {
-                level.captureDrops.add(itemEntity);
+            if (level.getCurrentWorldData().captureDrops != null) { // Folia - region threading
+                level.getCurrentWorldData().captureDrops.add(itemEntity); // Folia - region threading
             } else {
                 level.addFreshEntity(itemEntity);
             }
diff --git a/net/minecraft/world/level/block/DaylightDetectorBlock.java b/net/minecraft/world/level/block/DaylightDetectorBlock.java
index 7a428ff04cdcff26f7c9582c388542ecc618506a..6ad7da0e7a86742219ea13ec5cef33d9eaaabac9 100644
--- a/net/minecraft/world/level/block/DaylightDetectorBlock.java
+++ b/net/minecraft/world/level/block/DaylightDetectorBlock.java
@@ -110,7 +110,7 @@ public class DaylightDetectorBlock extends BaseEntityBlock {
     }
 
     private static void tickEntity(Level level, BlockPos pos, BlockState state, DaylightDetectorBlockEntity blockEntity) {
-        if (level.getGameTime() % 20L == 0L) {
+        if (level.getRedstoneGameTime() % 20L == 0L) { // Folia - region threading
             updateSignalStrength(state, level, pos);
         }
     }
diff --git a/net/minecraft/world/level/block/DoublePlantBlock.java b/net/minecraft/world/level/block/DoublePlantBlock.java
index e67f2b0f8e12c99cc5451865487bbec845998619..beaef78ace07ebf641bd873232b4be7e2c417d80 100644
--- a/net/minecraft/world/level/block/DoublePlantBlock.java
+++ b/net/minecraft/world/level/block/DoublePlantBlock.java
@@ -115,7 +115,7 @@ public class DoublePlantBlock extends VegetationBlock {
 
     protected static void preventDropFromBottomPart(Level level, BlockPos pos, BlockState state, Player player) {
         // CraftBukkit start
-        if (((net.minecraft.server.level.ServerLevel)level).hasPhysicsEvent && org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(level, pos).isCancelled()) { // Paper
+        if (((net.minecraft.server.level.ServerLevel)level).getCurrentWorldData().hasPhysicsEvent && org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(level, pos).isCancelled()) { // Paper // Folia - region threading
             return;
         }
         // CraftBukkit end
diff --git a/net/minecraft/world/level/block/EndGatewayBlock.java b/net/minecraft/world/level/block/EndGatewayBlock.java
index 4b959091412defb5ae6ffe387f98ed1cc9a29e5f..a195db5ede094e46dfc1704e0b2a0c9d8d6b17ba 100644
--- a/net/minecraft/world/level/block/EndGatewayBlock.java
+++ b/net/minecraft/world/level/block/EndGatewayBlock.java
@@ -110,17 +110,43 @@ public class EndGatewayBlock extends BaseEntityBlock implements Portal {
             if (portalPosition == null) {
                 return null;
             } else {
-                return entity instanceof ThrownEnderpearl
-                    ? new TeleportTransition(level, portalPosition, Vec3.ZERO, 0.0F, 0.0F, Set.of(), TeleportTransition.PLACE_PORTAL_TICKET, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_GATEWAY) // CraftBukkit
-                    : new TeleportTransition(
-                        level, portalPosition, Vec3.ZERO, 0.0F, 0.0F, Relative.union(Relative.DELTA, Relative.ROTATION), TeleportTransition.PLACE_PORTAL_TICKET, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_GATEWAY // CraftBukkit
-                    );
+                return getTeleportTransition(level, entity, portalPosition); // Folia - region threading
             }
         } else {
             return null;
         }
     }
 
+    // Folia start - region threading
+    public static TeleportTransition getTeleportTransition(ServerLevel level, Entity entity, Vec3 portalPosition) {
+                return entity instanceof ThrownEnderpearl
+                        ? new TeleportTransition(level, portalPosition, Vec3.ZERO, 0.0F, 0.0F, Set.of(), TeleportTransition.PLACE_PORTAL_TICKET, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_GATEWAY) // CraftBukkit
+                        : new TeleportTransition(
+                        level, portalPosition, Vec3.ZERO, 0.0F, 0.0F, Relative.union(Relative.DELTA, Relative.ROTATION), TeleportTransition.PLACE_PORTAL_TICKET, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_GATEWAY // CraftBukkit
+                );
+    }
+
+    @Override
+    public boolean portalAsync(ServerLevel sourceWorld, Entity portalTarget, BlockPos portalPos) {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(portalTarget)) {
+            return false;
+        }
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(sourceWorld, portalPos)) {
+            return false;
+        }
+
+        BlockEntity tile = sourceWorld.getBlockEntity(portalPos);
+
+        if (!(tile instanceof TheEndGatewayBlockEntity endGateway)) {
+            return false;
+        }
+
+        return TheEndGatewayBlockEntity.teleportRegionThreading(
+            sourceWorld, portalPos, portalTarget, endGateway, TeleportTransition.PLACE_PORTAL_TICKET
+        );
+    }
+    // Folia end - region threading
+
     @Override
     protected RenderShape getRenderShape(BlockState state) {
         return RenderShape.INVISIBLE;
diff --git a/net/minecraft/world/level/block/EndPortalBlock.java b/net/minecraft/world/level/block/EndPortalBlock.java
index 19590aa5af0eaf0f9bf76dc189ed67e67c692c77..6bff1704203c2de91eb01bda5220f4ea4d49c6ec 100644
--- a/net/minecraft/world/level/block/EndPortalBlock.java
+++ b/net/minecraft/world/level/block/EndPortalBlock.java
@@ -66,7 +66,7 @@ public class EndPortalBlock extends BaseEntityBlock implements Portal {
             level.getCraftServer().getPluginManager().callEvent(event);
             if (event.isCancelled()) return; // Paper - make cancellable
             // CraftBukkit end
-            if (!level.isClientSide() && level.dimension() == Level.END && entity instanceof ServerPlayer serverPlayer && !serverPlayer.seenCredits) {
+            if (false && !level.isClientSide() && level.dimension() == Level.END && entity instanceof ServerPlayer serverPlayer && !serverPlayer.seenCredits) { // Folia - region threading - do not show credits
                 if (level.paperConfig().misc.disableEndCredits) {serverPlayer.seenCredits = true; return;} // Paper - Option to disable end credits
                 serverPlayer.showEndCredits();
             } else {
@@ -124,6 +124,20 @@ public class EndPortalBlock extends BaseEntityBlock implements Portal {
         }
     }
 
+    // Folia start - region threading
+    @Override
+    public boolean portalAsync(ServerLevel sourceWorld, Entity portalTarget, BlockPos portalPos) {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(portalTarget)) {
+            return false;
+        }
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(sourceWorld, portalPos)) {
+            return false;
+        }
+
+        return portalTarget.endPortalLogicAsync(portalPos);
+    }
+    // Folia end - region threading
+
     @Override
     public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
         double d = pos.getX() + random.nextDouble();
diff --git a/net/minecraft/world/level/block/FarmBlock.java b/net/minecraft/world/level/block/FarmBlock.java
index 8c8983b14f4cfff748c82643c613a0b73407ed6a..50bf7864366ff6fc52b46a7b5437a9f5a961c2cb 100644
--- a/net/minecraft/world/level/block/FarmBlock.java
+++ b/net/minecraft/world/level/block/FarmBlock.java
@@ -95,8 +95,8 @@ public class FarmBlock extends Block {
     @Override
     protected void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
         int moistureValue = state.getValue(MOISTURE);
-        if (moistureValue > 0 && level.paperConfig().tickRates.wetFarmland != 1 && (level.paperConfig().tickRates.wetFarmland < 1 || (net.minecraft.server.MinecraftServer.currentTick + pos.hashCode()) % level.paperConfig().tickRates.wetFarmland != 0)) { return; } // Paper - Configurable random tick rates for blocks
-        if (moistureValue == 0 && level.paperConfig().tickRates.dryFarmland != 1 && (level.paperConfig().tickRates.dryFarmland < 1 || (net.minecraft.server.MinecraftServer.currentTick + pos.hashCode()) % level.paperConfig().tickRates.dryFarmland != 0)) { return; } // Paper - Configurable random tick rates for blocks
+        if (moistureValue > 0 && level.paperConfig().tickRates.wetFarmland != 1 && (level.paperConfig().tickRates.wetFarmland < 1 || (level.getRedstoneGameTime() + pos.hashCode()) % level.paperConfig().tickRates.wetFarmland != 0)) { return; } // Paper - Configurable random tick rates for blocks // Folia - region threading
+        if (moistureValue == 0 && level.paperConfig().tickRates.dryFarmland != 1 && (level.paperConfig().tickRates.dryFarmland < 1 || (level.getRedstoneGameTime() + pos.hashCode()) % level.paperConfig().tickRates.dryFarmland != 0)) { return; } // Paper - Configurable random tick rates for blocks // Folia - region threading
         if (!isNearWater(level, pos) && !level.isRainingAt(pos.above())) {
             if (moistureValue > 0) {
                 org.bukkit.craftbukkit.event.CraftEventFactory.handleMoistureChangeEvent(level, pos, state.setValue(MOISTURE, moistureValue - 1), 2); // CraftBukkit
diff --git a/net/minecraft/world/level/block/FungusBlock.java b/net/minecraft/world/level/block/FungusBlock.java
index 9711efb088bd0da9168e9bcd0496bd7caddd2974..98714fac58961d21636001bf422bae09223d14da 100644
--- a/net/minecraft/world/level/block/FungusBlock.java
+++ b/net/minecraft/world/level/block/FungusBlock.java
@@ -76,9 +76,9 @@ public class FungusBlock extends VegetationBlock implements BonemealableBlock {
             // CraftBukkit start
             .map((value) -> {
                 if (this == Blocks.WARPED_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.WARPED_FUNGUS;
+                    SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.WARPED_FUNGUS); // Folia - region threading
                 } else if (this == Blocks.CRIMSON_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.CRIMSON_FUNGUS;
+                    SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.CRIMSON_FUNGUS); // Folia - region threading
                 }
                 return value;
             })
diff --git a/net/minecraft/world/level/block/HoneyBlock.java b/net/minecraft/world/level/block/HoneyBlock.java
index 66628e690453ab417e0e5805057e037e93b12754..614a87a26267936fafc2450dc1470cd50b97c0fc 100644
--- a/net/minecraft/world/level/block/HoneyBlock.java
+++ b/net/minecraft/world/level/block/HoneyBlock.java
@@ -96,7 +96,7 @@ public class HoneyBlock extends HalfTransparentBlock {
     }
 
     private void maybeDoSlideAchievement(Entity entity, BlockPos pos) {
-        if (entity instanceof ServerPlayer && entity.level().getGameTime() % 20L == 0L) {
+        if (entity instanceof ServerPlayer && entity.level().getRedstoneGameTime() % 20L == 0L) { // Folia - region threading
             CriteriaTriggers.HONEY_BLOCK_SLIDE.trigger((ServerPlayer)entity, entity.level().getBlockState(pos));
         }
     }
diff --git a/net/minecraft/world/level/block/LightningRodBlock.java b/net/minecraft/world/level/block/LightningRodBlock.java
index 622f28a3661eec0487179aa9798f5771c0d957f7..dbfe086123c4b3cdc866111e1b6ec37d8d38d394 100644
--- a/net/minecraft/world/level/block/LightningRodBlock.java
+++ b/net/minecraft/world/level/block/LightningRodBlock.java
@@ -114,7 +114,7 @@ public class LightningRodBlock extends RodBlock implements SimpleWaterloggedBloc
     @Override
     public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
         if (level.isThundering()
-            && level.random.nextInt(200) <= level.getGameTime() % 200L
+            && level.random.nextInt(200) <= level.getRedstoneGameTime() % 200L // Folia - region threading
             && pos.getY() == level.getHeight(Heightmap.Types.WORLD_SURFACE, pos.getX(), pos.getZ()) - 1) {
             ParticleUtils.spawnParticlesAlongAxis(state.getValue(FACING).getAxis(), level, pos, 0.125, ParticleTypes.ELECTRIC_SPARK, UniformInt.of(1, 2));
         }
diff --git a/net/minecraft/world/level/block/MushroomBlock.java b/net/minecraft/world/level/block/MushroomBlock.java
index 9176cf8c47b19d76eb49a7c00fc6723836344d4b..7d81282f58984d0d8ef5d3cd909516ae25de47bd 100644
--- a/net/minecraft/world/level/block/MushroomBlock.java
+++ b/net/minecraft/world/level/block/MushroomBlock.java
@@ -93,7 +93,7 @@ public class MushroomBlock extends VegetationBlock implements BonemealableBlock
             return false;
         } else {
             level.removeBlock(pos, false);
-            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM; // CraftBukkit
+            SaplingBlock.treeTypeRT.set((this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM); // CraftBukkit // Folia - region threading
             if (optional.get().value().place(level, level.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
diff --git a/net/minecraft/world/level/block/NetherPortalBlock.java b/net/minecraft/world/level/block/NetherPortalBlock.java
index 653b72855197733b33e310b0ccd4fbf04e22e95f..211103dbbf651a3bf52ce64cb7e5bf8c12dec1f7 100644
--- a/net/minecraft/world/level/block/NetherPortalBlock.java
+++ b/net/minecraft/world/level/block/NetherPortalBlock.java
@@ -173,6 +173,33 @@ public class NetherPortalBlock extends Block implements Portal {
         }
     }
 
+    // Folia start - region threading
+    @Override
+    public boolean portalAsync(ServerLevel sourceWorld, Entity portalTarget, BlockPos portalPos) {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(portalTarget)) {
+            return false;
+        }
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(sourceWorld, portalPos)) {
+            return false;
+        }
+
+        return portalTarget.netherPortalLogicAsync(portalPos);
+    }
+
+    public static BlockUtil.FoundRectangle findPortalAround(ServerLevel world, BlockPos rough, WorldBorder worldBorder, int searchRadius) {
+        BlockPos found = world.getPortalForcer().findClosestPortalPosition(rough, worldBorder, searchRadius).orElse(null);
+        if (found == null) {
+            return null;
+        }
+
+        BlockState portalState = world.getBlockStateFromEmptyChunk(found);
+
+        return BlockUtil.getLargestRectangleAround(found, portalState.getValue(BlockStateProperties.HORIZONTAL_AXIS), 21, Direction.Axis.Y, 21, (pos) -> {
+            return world.getBlockStateFromEmptyChunk(pos) == portalState;
+        });
+    }
+    // Folia end - region threading
+
     private @Nullable TeleportTransition getExitPortal(
         ServerLevel level, Entity entity, BlockPos pos, BlockPos exitPos, WorldBorder worldBorder, org.bukkit.craftbukkit.event.PortalEventResult result // CraftBukkit
     ) {
@@ -181,14 +208,14 @@ public class NetherPortalBlock extends Block implements Portal {
         TeleportTransition.PostTeleportTransition postTeleportTransition;
         if (optional.isPresent()) {
             BlockPos blockPos = optional.get();
-            BlockState blockState = level.getBlockState(blockPos);
+            BlockState blockState = level.getBlockStateFromEmptyChunk(blockPos); // Folia - region threading
             largestRectangleAround = BlockUtil.getLargestRectangleAround(
                 blockPos,
                 blockState.getValue(BlockStateProperties.HORIZONTAL_AXIS),
                 21,
                 Direction.Axis.Y,
                 21,
-                blockPos1 -> level.getBlockState(blockPos1) == blockState
+                blockPos1 -> level.getBlockStateFromEmptyChunk(blockPos1) == blockState // Folia - region threading
             );
             postTeleportTransition = TeleportTransition.PLAY_PORTAL_SOUND.then(entity1 -> entity1.placePortalTicket(blockPos));
         } else if (result.canCreatePortal()) { // CraftBukkit
@@ -231,7 +258,7 @@ public class NetherPortalBlock extends Block implements Portal {
         return createDimensionTransition(level, rectangle, axis, relativePortalPosition, entity, postTeleportTransition);
     }
 
-    private static TeleportTransition createDimensionTransition(
+    public static TeleportTransition createDimensionTransition( // Folia - region threading - public
         ServerLevel level,
         BlockUtil.FoundRectangle rectangle,
         Direction.Axis axis,
diff --git a/net/minecraft/world/level/block/Portal.java b/net/minecraft/world/level/block/Portal.java
index 226c3ecd7ec474c245ace09bfb7369fc99e5a050..8bb6627c4fe939a58a35fa39600f76d9360c225a 100644
--- a/net/minecraft/world/level/block/Portal.java
+++ b/net/minecraft/world/level/block/Portal.java
@@ -13,6 +13,10 @@ public interface Portal {
 
     @Nullable TeleportTransition getPortalDestination(ServerLevel level, Entity entity, BlockPos pos);
 
+    // Folia start - region threading
+    public boolean portalAsync(ServerLevel sourceWorld, Entity portalTarget, BlockPos portalPos);
+    // Folia end - region threading
+
     default Portal.Transition getLocalTransition() {
         return Portal.Transition.NONE;
     }
diff --git a/net/minecraft/world/level/block/RedStoneWireBlock.java b/net/minecraft/world/level/block/RedStoneWireBlock.java
index 6d98bc37d88459d1e0a171b52bbff5810d775c38..56df64e48482b4caa7dc5dc843a18e6bc1e3bfa1 100644
--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -64,7 +64,7 @@ public class RedStoneWireBlock extends Block {
     private final Function<BlockState, VoxelShape> shapes;
     private final BlockState crossState;
     private final RedstoneWireEvaluator evaluator = new DefaultRedstoneWireEvaluator(this);
-    public boolean shouldSignal = true;
+    //public boolean shouldSignal = true; // Folia - region threading - move to regionised world data
 
     @Override
     public MapCodec<RedStoneWireBlock> codec() {
@@ -267,6 +267,11 @@ public class RedStoneWireBlock extends Block {
     // Paper start - Optimize redstone (Eigencraft)
     // The bulk of the new functionality is found in RedstoneWireTurbo.java
     io.papermc.paper.redstone.RedstoneWireTurbo turbo = new io.papermc.paper.redstone.RedstoneWireTurbo(this);
+    // Folia start - region threading
+    private io.papermc.paper.redstone.RedstoneWireTurbo getTurbo(Level world) {
+        return world.getCurrentWorldData().turbo;
+    }
+    // Folia end - region threading
 
     /*
      * Modified version of pre-existing updateSurroundingRedstone, which is called from
@@ -282,7 +287,7 @@ public class RedStoneWireBlock extends Block {
             if (orientation != null) {
                 source = pos.relative(orientation.getFront().getOpposite());
             }
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            getTurbo(worldIn).updateSurroundingRedstone(worldIn, pos, state, source); // Folia - region threading
             return;
         }
         updatePowerStrength(worldIn, pos, state, orientation, blockAdded);
@@ -310,7 +315,7 @@ public class RedStoneWireBlock extends Block {
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS)) {
-                    turbo.updateNeighborShapes(level, pos, state);
+                    this.getTurbo(level).updateNeighborShapes(level, pos, state); // Folia - region threading
                 }
             }
         }
@@ -327,9 +332,9 @@ public class RedStoneWireBlock extends Block {
     }
 
     public int getBlockSignal(Level level, BlockPos pos) {
-        this.shouldSignal = false;
+        io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal = false; // Folia - region threading
         int bestNeighborSignal = level.getBestNeighborSignal(pos);
-        this.shouldSignal = true;
+        io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal = true; // Folia - region threading
         return bestNeighborSignal;
     }
 
@@ -421,12 +426,12 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected int getDirectSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        return !this.shouldSignal ? 0 : state.getSignal(level, pos, side);
+        return !io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal ? 0 : state.getSignal(level, pos, side); // Folia - region threading
     }
 
     @Override
     protected int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        if (this.shouldSignal && side != Direction.DOWN) {
+        if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().shouldSignal && side != Direction.DOWN) { // Folia - region threading
             int powerValue = state.getValue(POWER);
             if (powerValue == 0) {
                 return 0;
@@ -458,7 +463,10 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected boolean isSignalSource(BlockState state) {
-        return this.shouldSignal;
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
+        return worldData == null || worldData.shouldSignal;
+        // Folia end - region threading
     }
 
     public static int getColorForPower(int power) {
diff --git a/net/minecraft/world/level/block/RedstoneTorchBlock.java b/net/minecraft/world/level/block/RedstoneTorchBlock.java
index 5365cc6c2ec7f86376bf27551493b6621d4c412e..d1dbfc821f068f14bf975842f66251816ea5c985 100644
--- a/net/minecraft/world/level/block/RedstoneTorchBlock.java
+++ b/net/minecraft/world/level/block/RedstoneTorchBlock.java
@@ -73,10 +73,10 @@ public class RedstoneTorchBlock extends BaseTorchBlock {
     protected void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
         boolean hasNeighborSignal = this.hasNeighborSignal(level, pos, state);
         // Paper start - Faster redstone torch rapid clock removal
-        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> redstoneUpdateInfos = level.redstoneUpdateInfos;
+        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> redstoneUpdateInfos = level.getCurrentWorldData().redstoneUpdateInfos; // Folia - region threading
         if (redstoneUpdateInfos != null) {
             RedstoneTorchBlock.Toggle curr;
-            while ((curr = redstoneUpdateInfos.peek()) != null && level.getGameTime() - curr.when > 60L) {
+            while ((curr = redstoneUpdateInfos.peek()) != null && level.getRedstoneGameTime() - curr.when > 60L) { // Folia - region threading
                 redstoneUpdateInfos.poll();
             }
         }
@@ -154,13 +154,13 @@ public class RedstoneTorchBlock extends BaseTorchBlock {
 
     private static boolean isToggledTooFrequently(Level level, BlockPos pos, boolean logToggle) {
         // Paper start - Faster redstone torch rapid clock removal
-        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> list = level.redstoneUpdateInfos;
+        java.util.ArrayDeque<RedstoneTorchBlock.Toggle> list = level.getCurrentWorldData().redstoneUpdateInfos; // Folia - region threading
         if (list == null) {
-            list = level.redstoneUpdateInfos = new java.util.ArrayDeque<>();
+            list = level.getCurrentWorldData().redstoneUpdateInfos = new java.util.ArrayDeque<>(); // Folia - region threading
         }
         // Paper end - Faster redstone torch rapid clock removal
         if (logToggle) {
-            list.add(new RedstoneTorchBlock.Toggle(pos.immutable(), level.getGameTime()));
+            list.add(new RedstoneTorchBlock.Toggle(pos.immutable(), level.getRedstoneGameTime())); // Folia - region threading
         }
 
         int i = 0;
@@ -181,12 +181,18 @@ public class RedstoneTorchBlock extends BaseTorchBlock {
     }
 
     public static class Toggle {
-        final BlockPos pos;
-        final long when;
+        public final BlockPos pos; // Folia - region threading
+        long when; // Folia - region threading
 
         public Toggle(BlockPos pos, long when) {
             this.pos = pos;
             this.when = when;
         }
+
+        // Folia start - region ticking
+        public void offsetTime(long offset) {
+            this.when += offset;
+        }
+        // Folia end - region ticking
     }
 }
diff --git a/net/minecraft/world/level/block/SaplingBlock.java b/net/minecraft/world/level/block/SaplingBlock.java
index 23e9e5e7ef76fe3d6e1bbc41faf69ee65ca77d80..70fffd4e6399022c719a236c309e9ee0f7ccd447 100644
--- a/net/minecraft/world/level/block/SaplingBlock.java
+++ b/net/minecraft/world/level/block/SaplingBlock.java
@@ -25,7 +25,7 @@ public class SaplingBlock extends VegetationBlock implements BonemealableBlock {
     public static final IntegerProperty STAGE = BlockStateProperties.STAGE;
     private static final VoxelShape SHAPE = Block.column(12.0, 0.0, 12.0);
     protected final TreeGrower treeGrower;
-    public static @javax.annotation.Nullable org.bukkit.TreeType treeType; // CraftBukkit
+    public static final ThreadLocal<org.bukkit.TreeType> treeTypeRT = new ThreadLocal<>(); // CraftBukkit // Folia - region threading
 
     @Override
     public MapCodec<? extends SaplingBlock> codec() {
@@ -55,18 +55,19 @@ public class SaplingBlock extends VegetationBlock implements BonemealableBlock {
             level.setBlock(pos, state.cycle(STAGE), Block.UPDATE_NONE);
         } else {
             // CraftBukkit start
-            if (level.captureTreeGeneration) {
+            io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+            if (worldData.captureTreeGeneration) { // Folia - region threading
                 this.treeGrower.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
             } else {
-                level.captureTreeGeneration = true;
+                worldData.captureTreeGeneration = true; // Folia - region threading
                 this.treeGrower.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
-                level.captureTreeGeneration = false;
-                if (!level.capturedBlockStates.isEmpty()) {
-                    org.bukkit.TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                worldData.captureTreeGeneration = false; // Folia - region threading
+                if (!worldData.capturedBlockStates.isEmpty()) { // Folia - region threading
+                    org.bukkit.TreeType treeType = SaplingBlock.treeTypeRT.get(); // Folia - region threading
+                    SaplingBlock.treeTypeRT.set(null); // Folia - region threading
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level);
-                    java.util.List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(level.capturedBlockStates.values());
-                    level.capturedBlockStates.clear();
+                    java.util.List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldData.capturedBlockStates.values()); // Folia - region threading
+                    worldData.capturedBlockStates.clear(); // Folia - region threading
                     org.bukkit.event.world.StructureGrowEvent event = null;
                     if (treeType != null) {
                         event = new org.bukkit.event.world.StructureGrowEvent(location, treeType, false, null, blocks);
diff --git a/net/minecraft/world/level/block/SpreadingSnowyDirtBlock.java b/net/minecraft/world/level/block/SpreadingSnowyDirtBlock.java
index bae64d24e8ce704fdc146650fce478820362b437..13f1d5ef56b0ccbc4d976d6613d467a7a723d168 100644
--- a/net/minecraft/world/level/block/SpreadingSnowyDirtBlock.java
+++ b/net/minecraft/world/level/block/SpreadingSnowyDirtBlock.java
@@ -50,7 +50,7 @@ public abstract class SpreadingSnowyDirtBlock extends SnowyDirtBlock {
 
     @Override
     protected void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
-        if (this instanceof GrassBlock && level.paperConfig().tickRates.grassSpread != 1 && (level.paperConfig().tickRates.grassSpread < 1 || (net.minecraft.server.MinecraftServer.currentTick + pos.hashCode()) % level.paperConfig().tickRates.grassSpread != 0)) { return; } // Paper - Configurable random tick rates for blocks
+        if (this instanceof GrassBlock && level.paperConfig().tickRates.grassSpread != 1 && (level.paperConfig().tickRates.grassSpread < 1 || (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + pos.hashCode()) % level.paperConfig().tickRates.grassSpread != 0)) { return; } // Paper - Configurable random tick rates for blocks // Folia - regionised ticking
         // Paper start - Perf: optimize dirt and snow spreading
         final net.minecraft.world.level.chunk.ChunkAccess cachedBlockChunk = level.getChunkIfLoaded(pos);
         if (cachedBlockChunk == null) { // Is this needed?
diff --git a/net/minecraft/world/level/block/VegetationBlock.java b/net/minecraft/world/level/block/VegetationBlock.java
index 0aa7c1084fd6ed35260469572cdd914d87f3922a..55beb3206f499d6802e6eb011e8636190f36ab31 100644
--- a/net/minecraft/world/level/block/VegetationBlock.java
+++ b/net/minecraft/world/level/block/VegetationBlock.java
@@ -38,7 +38,7 @@ public abstract class VegetationBlock extends Block {
         // CraftBukkit start
         if (!state.canSurvive(level, pos)) {
             // Suppress during worldgen
-            if (!(level instanceof net.minecraft.server.level.ServerLevel serverLevel && serverLevel.hasPhysicsEvent) || !org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(serverLevel, pos).isCancelled()) { // Paper
+            if (!(level instanceof net.minecraft.server.level.ServerLevel serverLevel && serverLevel.getCurrentWorldData().hasPhysicsEvent) || !org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(serverLevel, pos).isCancelled()) { // Paper // Folia - region threading
                 return Blocks.AIR.defaultBlockState();
             }
         }
diff --git a/net/minecraft/world/level/block/WitherSkullBlock.java b/net/minecraft/world/level/block/WitherSkullBlock.java
index 24215493601ff724032660178c1261f3c40edd61..aff709c8d9a5173caf21cb8e2929f8171b8cf0d6 100644
--- a/net/minecraft/world/level/block/WitherSkullBlock.java
+++ b/net/minecraft/world/level/block/WitherSkullBlock.java
@@ -49,7 +49,7 @@ public class WitherSkullBlock extends SkullBlock {
     }
 
     public static void checkSpawn(Level level, BlockPos pos, SkullBlockEntity blockEntity) {
-        if (level.captureBlockStates) return; // CraftBukkit
+        if (level.getCurrentWorldData().captureBlockStates) return; // CraftBukkit // Folia - region threading
         if (!level.isClientSide()) {
             BlockState blockState = blockEntity.getBlockState();
             boolean flag = blockState.is(Blocks.WITHER_SKELETON_SKULL) || blockState.is(Blocks.WITHER_SKELETON_WALL_SKULL);
diff --git a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
index 0db33d7e1227e914326e9eb3b50338b001872938..deaac59e24dcc8c259567545507b52ca383f391e 100644
--- a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
@@ -209,7 +209,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
         }
 
         int i = blockEntity.levels; final int originalLevels = i; // Paper - OBFHELPER
-        if (level.getGameTime() % 80L == 0L) {
+        if (level.getRedstoneGameTime() % 80L == 0L) { // Folia - region threading
             if (!blockEntity.beamSections.isEmpty()) {
                 blockEntity.levels = updateBase(level, x, y, z);
             }
@@ -344,7 +344,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
             list = level.getEntitiesOfClass(Player.class, aabb); // Diff from applyEffect
         } else {
             list = new java.util.ArrayList<>();
-            for (final Player player : level.players()) {
+            for (final Player player : level.getLocalPlayers()) { // Folia - region threading
                 if (!net.minecraft.world.entity.EntitySelector.NO_SPECTATORS.test(player)) continue;
                 if (player.getBoundingBox().intersects(aabb)) {
                     list.add(player);
diff --git a/net/minecraft/world/level/block/entity/BlockEntity.java b/net/minecraft/world/level/block/entity/BlockEntity.java
index fb22ebe9758014ebf2aebcda21155f1c4c83fafe..c8699e6461f9def2f9fbd96d466b8a8fb75f2bc5 100644
--- a/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -37,7 +37,7 @@ import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
 
 public abstract class BlockEntity implements DebugValueSource {
-    static boolean ignoreBlockEntityUpdates; // Paper - Perf: Optimize Hoppers
+    static final ThreadLocal<Boolean> IGNORE_TILE_UPDATES = ThreadLocal.withInitial(() -> Boolean.FALSE);; // Paper - Perf: Optimize Hoppers // Folia - region threading
     // CraftBukkit start - data containers
     private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
     public final org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer persistentDataContainer;
@@ -51,6 +51,12 @@ public abstract class BlockEntity implements DebugValueSource {
     private BlockState blockState;
     private DataComponentMap components = DataComponentMap.EMPTY;
 
+    // Folia start - region ticking
+    public void updateTicks(final long fromTickOffset, final long fromRedstoneTimeOffset) {
+
+    }
+    // Folia end - region ticking
+
     public BlockEntity(BlockEntityType<?> type, BlockPos pos, BlockState blockState) {
         this.type = type;
         this.worldPosition = pos.immutable();
@@ -227,7 +233,7 @@ public abstract class BlockEntity implements DebugValueSource {
 
     public void setChanged() {
         if (this.level != null) {
-            if (ignoreBlockEntityUpdates) return; // Paper - Perf: Optimize Hoppers
+            if (IGNORE_TILE_UPDATES.get().booleanValue()) return; // Paper - Perf: Optimize Hoppers // Folia - region threading
             setChanged(this.level, this.worldPosition, this.blockState);
         }
     }
diff --git a/net/minecraft/world/level/block/entity/CommandBlockEntity.java b/net/minecraft/world/level/block/entity/CommandBlockEntity.java
index 01b20c1aba5f85c506ceb0678c1372bece291d2b..e48a2833b2600e31b562360dc86f8348acd2c3c5 100644
--- a/net/minecraft/world/level/block/entity/CommandBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/CommandBlockEntity.java
@@ -67,6 +67,13 @@ public class CommandBlockEntity extends BlockEntity {
             );
         }
 
+        // Folia start
+        @Override
+        public void threadCheck() {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel) CommandBlockEntity.this.level, CommandBlockEntity.this.worldPosition, "Asynchronous sendSystemMessage to a command block");
+        }
+        // Folia end
+
         @Override
         public boolean isValid() {
             return !CommandBlockEntity.this.isRemoved();
diff --git a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
index be4b46d56ca67cb5c0fac5e0bbc9456fb5552d78..74df43d2bb8f1094ac91d8c32a318d36a6c01b23 100644
--- a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
@@ -76,7 +76,7 @@ public class ConduitBlockEntity extends BlockEntity {
 
     public static void clientTick(Level level, BlockPos pos, BlockState state, ConduitBlockEntity blockEntity) {
         blockEntity.tickCount++;
-        long gameTime = level.getGameTime();
+        long gameTime = level.getRedstoneGameTime(); // Folia - region threading
         List<BlockPos> list = blockEntity.effectBlocks;
         if (gameTime % 40L == 0L) {
             blockEntity.isActive = updateShape(level, pos, list);
@@ -92,7 +92,7 @@ public class ConduitBlockEntity extends BlockEntity {
 
     public static void serverTick(Level level, BlockPos pos, BlockState state, ConduitBlockEntity blockEntity) {
         blockEntity.tickCount++;
-        long gameTime = level.getGameTime();
+        long gameTime = level.getRedstoneGameTime(); // Folia - region threading
         List<BlockPos> list = blockEntity.effectBlocks;
         if (gameTime % 40L == 0L) {
             boolean flag = updateShape(level, pos, list);
diff --git a/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 12f8105d6b12c5d63cb6e5e79435c7fd22655475..21546db5e061536f9e0c04a6dc7404a07c032f35 100644
--- a/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -36,7 +36,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     private static final Component DEFAULT_NAME = Component.translatable("container.hopper");
     private NonNullList<ItemStack> items = NonNullList.withSize(5, ItemStack.EMPTY);
     public int cooldownTime = -1;
-    private long tickedGameTime;
+    private long tickedGameTime = Long.MIN_VALUE; // Folia - region threading
     private Direction facing;
 
     // CraftBukkit start - add fields and methods
@@ -73,6 +73,16 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     }
     // CraftBukkit end
 
+    // Folia start - region threading
+    @Override
+    public void updateTicks(final long fromTickOffset, final long fromRedstoneTimeOffset) {
+        super.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+        if (this.tickedGameTime != Long.MIN_VALUE) {
+            this.tickedGameTime += fromRedstoneTimeOffset;
+        }
+    }
+    // Folia end - region threading
+
     public HopperBlockEntity(BlockPos pos, BlockState blockState) {
         super(BlockEntityType.HOPPER, pos, blockState);
         this.facing = blockState.getValue(HopperBlock.FACING);
@@ -130,7 +140,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     public static void pushItemsTick(Level level, BlockPos pos, BlockState state, HopperBlockEntity blockEntity) {
         blockEntity.cooldownTime--;
-        blockEntity.tickedGameTime = level.getGameTime();
+        blockEntity.tickedGameTime = level.getRedstoneGameTime(); // Folia - region threading
         if (!blockEntity.isOnCooldown()) {
             blockEntity.setCooldown(0);
             // Spigot start
@@ -218,12 +228,11 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     }
 
     // Paper start - Perf: Optimize Hoppers
-    public static boolean skipHopperEvents;
-    private static boolean skipPullModeEventFire;
-    private static boolean skipPushModeEventFire;
+    // Folia - region threading - moved to RegionizedWorldData
 
     private static boolean hopperPush(final Level level, final Container destination, final Direction direction, final HopperBlockEntity hopper) {
-        skipPushModeEventFire = skipHopperEvents;
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+        worldData.skipPushModeEventFire = worldData.skipHopperEvents; // Folia - region threading
         boolean foundItem = false;
         for (int i = 0; i < hopper.getContainerSize(); ++i) {
             final ItemStack item = hopper.getItem(i);
@@ -238,7 +247,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
                 // We only need to fire the event once to give protection plugins a chance to cancel this event
                 // Because nothing uses getItem, every event call should end up the same result.
-                if (!skipPushModeEventFire) {
+                if (!worldData.skipPushModeEventFire) { // Folia - region threading
                     movedItem = callPushMoveEvent(destination, movedItem, hopper);
                     if (movedItem == null) { // cancelled
                         origItemStack.setCount(originalItemCount);
@@ -268,13 +277,14 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     }
 
     private static boolean hopperPull(final Level level, final Hopper hopper, final Container container, ItemStack origItemStack, final int i) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
         ItemStack movedItem = origItemStack;
         final int originalItemCount = origItemStack.getCount();
         final int movedItemCount = Math.min(level.spigotConfig.hopperAmount, originalItemCount);
         container.setChanged(); // original logic always marks source inv as changed even if no move happens.
         movedItem.setCount(movedItemCount);
 
-        if (!skipPullModeEventFire) {
+        if (!worldData.skipPullModeEventFire) { // Folia - region threading
             movedItem = callPullMoveEvent(hopper, container, movedItem);
             if (movedItem == null) { // cancelled
                 origItemStack.setCount(originalItemCount);
@@ -294,9 +304,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                 origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
             }
 
-            ignoreBlockEntityUpdates = true;
+            IGNORE_TILE_UPDATES.set(true); // Folia - region threading
             container.setItem(i, origItemStack);
-            ignoreBlockEntityUpdates = false;
+            IGNORE_TILE_UPDATES.set(false); // Folia - region threading
             container.setChanged();
             return true;
         }
@@ -311,6 +321,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     @Nullable
     private static ItemStack callPushMoveEvent(Container destination, ItemStack itemStack, HopperBlockEntity hopper) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         final org.bukkit.inventory.Inventory destinationInventory = getInventory(destination);
         final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(
             hopper.getOwner(false).getInventory(),
@@ -320,7 +331,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         );
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPushModeEventFire = true;
+            worldData.skipPushModeEventFire = true; // Folia - region threading
         }
         if (!result) {
             applyCooldown(hopper);
@@ -336,6 +347,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     @Nullable
     private static ItemStack callPullMoveEvent(final Hopper hopper, final Container container, final ItemStack itemstack) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         final org.bukkit.inventory.Inventory sourceInventory = getInventory(container);
         final org.bukkit.inventory.Inventory destination = getInventory(hopper);
 
@@ -343,7 +355,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(sourceInventory, org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack), destination, false);
         final boolean result = event.callEvent();
         if (!event.calledGetItem && !event.calledSetItem) {
-            skipPullModeEventFire = true;
+            worldData.skipPullModeEventFire = true; // Folia - region threading
         }
         if (!result) {
             applyCooldown(hopper);
@@ -529,12 +541,13 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     }
 
     public static boolean suckInItems(Level level, Hopper hopper) {
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         BlockPos blockPos = BlockPos.containing(hopper.getLevelX(), hopper.getLevelY() + 1.0, hopper.getLevelZ());
         BlockState blockState = level.getBlockState(blockPos);
         Container sourceContainer = getSourceContainer(level, hopper, blockPos, blockState);
         if (sourceContainer != null) {
             Direction direction = Direction.DOWN;
-            skipPullModeEventFire = skipHopperEvents; // Paper - Perf: Optimize Hoppers
+            worldData.skipPullModeEventFire = worldData.skipHopperEvents; // Paper - Perf: Optimize Hoppers // Folia - region threading
 
             for (int i : getSlots(sourceContainer, direction)) {
                 if (tryTakeInItemFromSlot(hopper, sourceContainer, i, direction, level)) { // Spigot
@@ -683,9 +696,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                     stack = stack.split(destination.getMaxStackSize());
                 }
                 // Spigot end
-                ignoreBlockEntityUpdates = true; // Paper - Perf: Optimize Hoppers
+                IGNORE_TILE_UPDATES.set(Boolean.TRUE); // Paper - Perf: Optimize Hoppers // Folia - region threading
                 destination.setItem(slot, stack);
-                ignoreBlockEntityUpdates = false; // Paper - Perf: Optimize Hoppers
+                IGNORE_TILE_UPDATES.set(Boolean.FALSE); // Paper - Perf: Optimize Hoppers // Folia - region threading
                 stack = leftover; // Paper - Make hoppers respect inventory max stack size
                 flag = true;
             } else if (canMergeItems(item, stack)) {
diff --git a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index ab7be4298be22af32c4726f178b93896b96f599d..7e07a634c0cfc0244247f6b69bdcfef9ba531fb1 100644
--- a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -44,9 +44,9 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
     // Paper end - Fix NPE in SculkBloomEvent world access
 
     public static void serverTick(Level level, BlockPos pos, BlockState state, SculkCatalystBlockEntity sculkCatalyst) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = sculkCatalyst.getBlockPos(); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(sculkCatalyst.getBlockPos()); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // Folia - region threading
         sculkCatalyst.catalystListener.getSculkSpreader().updateCursors(level, pos, level.getRandom(), true);
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = null; // CraftBukkit
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(null); // CraftBukkit // Folia - region threading
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java b/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
index 74fff57ac1ab7d35cd12ec7aeefa2cd4c43065ba..23f1b6dc3b43b12c868070c3d6b803d426ec8623 100644
--- a/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
@@ -37,9 +37,12 @@ public class TheEndGatewayBlockEntity extends TheEndPortalBlockEntity {
     private static final boolean DEFAULT_EXACT_TELEPORT = false;
     public long age = 0L;
     private int teleportCooldown;
-    public @Nullable BlockPos exitPortal;
+    public volatile @Nullable BlockPos exitPortal; // Folia - region threading - volatile
     public boolean exactTeleport = false;
 
+    private static final java.util.concurrent.atomic.AtomicLong SEARCHING_FOR_EXIT_ID_GENERATOR = new java.util.concurrent.atomic.AtomicLong(); // Folia - region threading
+    private Long searchingForExitId; // Folia - region threading
+
     public TheEndGatewayBlockEntity(BlockPos pos, BlockState blockState) {
         super(BlockEntityType.END_GATEWAY, pos, blockState);
     }
@@ -128,6 +131,104 @@ public class TheEndGatewayBlockEntity extends TheEndPortalBlockEntity {
         }
     }
 
+    // Folia start - region threading
+    private void trySearchForExit(ServerLevel world, BlockPos fromPos) {
+        if (this.searchingForExitId != null) {
+            return;
+        }
+        this.searchingForExitId = Long.valueOf(SEARCHING_FOR_EXIT_ID_GENERATOR.getAndIncrement());
+        int chunkX = fromPos.getX() >> 4;
+        int chunkZ = fromPos.getZ() >> 4;
+        world.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+            net.minecraft.server.level.TicketType.END_GATEWAY_EXIT_SEARCH,
+            chunkX, chunkZ,
+            ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.BLOCK_TICKING_TICKET_LEVEL,
+            this.searchingForExitId
+        );
+
+        ca.spottedleaf.concurrentutil.completable.CallbackCompletable<BlockPos> complete = new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+
+        complete.addWaiter((tpLoc, throwable) -> {
+            // create the exit portal
+            TheEndGatewayBlockEntity.LOGGER.debug("Creating portal at {}", tpLoc);
+            TheEndGatewayBlockEntity.spawnGatewayPortal(world, tpLoc, EndGatewayConfiguration.knownExit(fromPos, false));
+
+            // need to go onto the tick thread to avoid saving issues
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                world, chunkX, chunkZ,
+                () -> {
+                    // update the exit portal location
+                    TheEndGatewayBlockEntity.this.exitPortal = tpLoc;
+
+                    // remove ticket keeping the gateway loaded
+                    world.moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
+                        net.minecraft.server.level.TicketType.END_GATEWAY_EXIT_SEARCH,
+                        chunkX, chunkZ,
+                        ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.BLOCK_TICKING_TICKET_LEVEL,
+                        this.searchingForExitId
+                    );
+                    TheEndGatewayBlockEntity.this.searchingForExitId = null;
+                }
+            );
+        });
+
+        findOrCreateValidTeleportPosRegionThreading(world, fromPos, complete);
+    }
+
+    public static boolean teleportRegionThreading(ServerLevel portalWorld, BlockPos portalPos,
+                                                  net.minecraft.world.entity.Entity toTeleport,
+                                                  TheEndGatewayBlockEntity portalTile,
+                                                  net.minecraft.world.level.portal.TeleportTransition.PostTeleportTransition post) {
+        // can we even teleport in this dimension?
+        if (portalTile.exitPortal == null && portalWorld.getTypeKey() != net.minecraft.world.level.dimension.LevelStem.END) {
+            return false;
+        }
+
+        // First, find the position we are trying to teleport to
+        BlockPos teleportPos = portalTile.exitPortal;
+        boolean isExactTeleport = portalTile.exactTeleport;
+
+        if (teleportPos == null) {
+            portalTile.trySearchForExit(portalWorld, portalPos);
+            return false;
+        }
+
+        // note: we handle the position from the TeleportTransition
+        net.minecraft.world.level.portal.TeleportTransition teleport = net.minecraft.world.level.block.EndGatewayBlock.getTeleportTransition(
+            portalWorld, toTeleport, Vec3.atCenterOf(teleportPos)
+        );
+
+
+        if (isExactTeleport) {
+            // blind teleport
+            return toTeleport.teleportAsync(
+                teleport, net.minecraft.world.entity.Entity.TELEPORT_FLAG_LOAD_CHUNK | net.minecraft.world.entity.Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                post == null ? null : (net.minecraft.world.entity.Entity teleportedEntity) -> {
+                    post.onTransition(teleportedEntity);
+                }
+            );
+        } else {
+            // we could hack around by first loading the chunks, then calling back to here and checking if the entity
+            // should be teleported, something something else...
+            // however, we know the target location cannot differ by one region section: so we can
+            // just teleport and adjust the position after
+            return toTeleport.teleportAsync(
+                teleport, net.minecraft.world.entity.Entity.TELEPORT_FLAG_LOAD_CHUNK | net.minecraft.world.entity.Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                (net.minecraft.world.entity.Entity teleportedEntity) -> {
+                    // adjust to the final exit position
+                    Vec3 adjusted = Vec3.atCenterOf(TheEndGatewayBlockEntity.findExitPosition(portalWorld, teleportPos));
+                    // teleportTo will adjust rider positions
+                    teleportedEntity.teleportTo(adjusted.x, adjusted.y, adjusted.z);
+
+                    if (post != null) {
+                        post.onTransition(teleportedEntity);
+                    }
+                }
+            );
+        }
+    }
+    // Folia end - region threading
+
     public @Nullable Vec3 getPortalPosition(ServerLevel level, BlockPos pos) {
         if (this.exitPortal == null && level.getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END) { // CraftBukkit - work in alternate worlds
             BlockPos blockPos = findOrCreateValidTeleportPos(level, pos);
@@ -172,6 +273,124 @@ public class TheEndGatewayBlockEntity extends TheEndPortalBlockEntity {
         return findTallestBlock(level, blockPos, 16, true);
     }
 
+    // Folia start - region threading
+    private static void findOrCreateValidTeleportPosRegionThreading(ServerLevel world, BlockPos pos,
+                                                                    ca.spottedleaf.concurrentutil.completable.CallbackCompletable<BlockPos> complete) {
+        ca.spottedleaf.concurrentutil.completable.CallbackCompletable<Vec3> tentativeSelection = new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
+
+        tentativeSelection.addWaiter((vec3d, throwable) -> {
+            LevelChunk chunk = TheEndGatewayBlockEntity.getChunk(world, vec3d);
+            BlockPos blockposition1 = TheEndGatewayBlockEntity.findValidSpawnInChunk(chunk);
+            if (blockposition1 == null) {
+                BlockPos blockposition2 = BlockPos.containing(vec3d.x + 0.5D, 75.0D, vec3d.z + 0.5D);
+
+                TheEndGatewayBlockEntity.LOGGER.debug("Failed to find a suitable block to teleport to, spawning an island on {}", blockposition2);
+                world.registryAccess().lookup(Registries.CONFIGURED_FEATURE).flatMap((iregistry) -> {
+                    return iregistry.get(EndFeatures.END_ISLAND);
+                }).ifPresent((holder_c) -> {
+                    ((net.minecraft.world.level.levelgen.feature.ConfiguredFeature) holder_c.value()).place(world, world.getChunkSource().getGenerator(), RandomSource.create(blockposition2.asLong()), blockposition2);
+                });
+                blockposition1 = blockposition2;
+            } else {
+                TheEndGatewayBlockEntity.LOGGER.debug("Found suitable block to teleport to: {}", blockposition1);
+            }
+
+            // Here, there is no guarantee the chunks in 1 radius are in this region due to the fact that we just chained
+            // possibly 16x chunk loads along an axis (findExitPortalXZPosTentativeRegionThreading) using the chunk queue
+            // (regioniser only guarantees at least 8 chunks along a single axis)
+            // so, we need to schedule for the next tick
+            int posX = blockposition1.getX();
+            int posZ = blockposition1.getZ();
+            int radius = 16;
+
+            BlockPos finalBlockPosition1 = blockposition1;
+            world.moonrise$loadChunksAsync(blockposition1, radius,
+                    ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                    (java.util.List<net.minecraft.world.level.chunk.ChunkAccess> chunks) -> {
+                        // make sure chunks are kept loaded
+                        for (net.minecraft.world.level.chunk.ChunkAccess access : chunks) {
+                            world.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                                    net.minecraft.server.level.TicketType.DELAYED, access.getPos(),
+                                    ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.FULL_LOADED_TICKET_LEVEL,
+                                    null
+                            );
+                        }
+                        // now after the chunks are loaded, we can delay by one tick
+                        io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                                world, posX >> 4, posZ >> 4, () -> {
+                                    // find final location
+                                    BlockPos tpLoc = TheEndGatewayBlockEntity.findTallestBlock(world, finalBlockPosition1, radius, true).above(GATEWAY_HEIGHT_ABOVE_SURFACE);
+
+                                    // done
+                                    complete.complete(tpLoc);
+                                }
+                        );
+                    }
+            );
+        });
+
+        // fire off chain
+        findExitPortalXZPosTentativeRegionThreading(world, pos, tentativeSelection);
+    }
+
+    private static void findExitPortalXZPosTentativeRegionThreading(ServerLevel world, BlockPos pos,
+                                                                    ca.spottedleaf.concurrentutil.completable.CallbackCompletable<Vec3> complete) {
+        Vec3 posDirFromOrigin = new Vec3(pos.getX(), 0.0D, pos.getZ()).normalize();
+        Vec3 posDirExtruded = posDirFromOrigin.scale(1024.0D);
+
+        class Vars {
+            int i = 16;
+            boolean mode = false;
+            Vec3 currPos = posDirExtruded;
+        }
+        Vars vars = new Vars();
+
+        Runnable handle = new Runnable() {
+            @Override
+            public void run() {
+                if (vars.mode != TheEndGatewayBlockEntity.isChunkEmpty(world, vars.currPos)) {
+                    vars.i = 0; // fall back to completing
+                }
+
+                // try to load next chunk
+                if (vars.i-- <= 0) {
+                    if (vars.mode) {
+                        complete.complete(vars.currPos);
+                        return;
+                    }
+                    vars.mode = true;
+                    vars.i = 16;
+                }
+
+                vars.currPos = vars.currPos.add(posDirFromOrigin.scale(vars.mode ? 16.0 : -16.0));
+                // schedule next iteration
+                world.moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+                        ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(vars.currPos),
+                        ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(vars.currPos),
+                        net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                        true,
+                        ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                        (chunk) -> {
+                            this.run();
+                        }
+                );
+            }
+        };
+
+        // kick off first chunk load
+        world.moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+                ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(posDirExtruded),
+                ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(posDirExtruded),
+                net.minecraft.world.level.chunk.status.ChunkStatus.FULL,
+                true,
+                ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
+                (chunk) -> {
+                    handle.run();
+                }
+        );
+    }
+    // Folia end - region threading
+
     private static Vec3 findExitPortalXZPosTentative(ServerLevel level, BlockPos pos) {
         Vec3 vec3 = new Vec3(pos.getX(), 0.0, pos.getZ()).normalize();
         int i = 1024;
diff --git a/net/minecraft/world/level/block/entity/TickingBlockEntity.java b/net/minecraft/world/level/block/entity/TickingBlockEntity.java
index 28e3b73507b988f7234cbf29c4024c88180d0aef..c8facee29ee08e0975528083f89b64f0b593957f 100644
--- a/net/minecraft/world/level/block/entity/TickingBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/TickingBlockEntity.java
@@ -10,4 +10,6 @@ public interface TickingBlockEntity {
     BlockPos getPos();
 
     String getType();
+
+    BlockEntity getTileEntity(); // Folia - region threading
 }
diff --git a/net/minecraft/world/level/block/grower/TreeGrower.java b/net/minecraft/world/level/block/grower/TreeGrower.java
index 5471619a0484ece08640e2b3fd26746c351dc3e0..b59e0f5f093b638b780913b044e60b40f6e43b4b 100644
--- a/net/minecraft/world/level/block/grower/TreeGrower.java
+++ b/net/minecraft/world/level/block/grower/TreeGrower.java
@@ -201,55 +201,57 @@ public final class TreeGrower {
 
     // CraftBukkit start
     private void setTreeType(Holder<ConfiguredFeature<?, ?>> feature) {
+        org.bukkit.TreeType treeType; // Folia - region threading
         if (feature.is(TreeFeatures.OAK) || feature.is(TreeFeatures.OAK_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TREE;
+            treeType = org.bukkit.TreeType.TREE; // Folia - region threading
         } else if (feature.is(TreeFeatures.HUGE_RED_MUSHROOM)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.RED_MUSHROOM;
+            treeType = org.bukkit.TreeType.RED_MUSHROOM; // Folia - region threading
         } else if (feature.is(TreeFeatures.HUGE_BROWN_MUSHROOM)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BROWN_MUSHROOM;
+            treeType = org.bukkit.TreeType.BROWN_MUSHROOM; // Folia - region threading
         } else if (feature.is(TreeFeatures.JUNGLE_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.COCOA_TREE;
+            treeType = org.bukkit.TreeType.COCOA_TREE; // Folia - region threading
         } else if (feature.is(TreeFeatures.JUNGLE_TREE_NO_VINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SMALL_JUNGLE;
+            treeType = org.bukkit.TreeType.SMALL_JUNGLE; // Folia - region threading
         } else if (feature.is(TreeFeatures.PINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_REDWOOD;
+            treeType = org.bukkit.TreeType.TALL_REDWOOD; // Folia - region threading
         } else if (feature.is(TreeFeatures.SPRUCE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.REDWOOD;
+            treeType = org.bukkit.TreeType.REDWOOD; // Folia - region threading
         } else if (feature.is(TreeFeatures.ACACIA)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.ACACIA;
+            treeType = org.bukkit.TreeType.ACACIA; // Folia - region threading
         } else if (feature.is(TreeFeatures.BIRCH) || feature.is(TreeFeatures.BIRCH_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIRCH;
+            treeType = org.bukkit.TreeType.BIRCH; // Folia - region threading
         } else if (feature.is(TreeFeatures.SUPER_BIRCH_BEES_0002)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_BIRCH;
+            treeType = org.bukkit.TreeType.TALL_BIRCH; // Folia - region threading
         } else if (feature.is(TreeFeatures.SWAMP_OAK)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SWAMP;
+            treeType = org.bukkit.TreeType.SWAMP; // Folia - region threading
         } else if (feature.is(TreeFeatures.FANCY_OAK) || feature.is(TreeFeatures.FANCY_OAK_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIG_TREE;
+            treeType = org.bukkit.TreeType.BIG_TREE; // Folia - region threading
         } else if (feature.is(TreeFeatures.JUNGLE_BUSH)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE_BUSH;
+            treeType = org.bukkit.TreeType.JUNGLE_BUSH; // Folia - region threading
         } else if (feature.is(TreeFeatures.DARK_OAK)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.DARK_OAK;
+            treeType = org.bukkit.TreeType.DARK_OAK; // Folia - region threading
         } else if (feature.is(TreeFeatures.MEGA_SPRUCE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_REDWOOD;
+            treeType = org.bukkit.TreeType.MEGA_REDWOOD; // Folia - region threading
         } else if (feature.is(TreeFeatures.MEGA_PINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_PINE;
+            treeType = org.bukkit.TreeType.MEGA_PINE; // Folia - region threading
         } else if (feature.is(TreeFeatures.MEGA_JUNGLE_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE;
+            treeType = org.bukkit.TreeType.JUNGLE; // Folia - region threading
         } else if (feature.is(TreeFeatures.AZALEA_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.AZALEA;
+            treeType = org.bukkit.TreeType.AZALEA; // Folia - region threading
         } else if (feature.is(TreeFeatures.MANGROVE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MANGROVE;
+            treeType = org.bukkit.TreeType.MANGROVE; // Folia - region threading
         } else if (feature.is(TreeFeatures.TALL_MANGROVE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_MANGROVE;
+            treeType = org.bukkit.TreeType.TALL_MANGROVE; // Folia - region threading
         } else if (feature.is(TreeFeatures.CHERRY) || feature.is(TreeFeatures.CHERRY_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.CHERRY;
+            treeType = org.bukkit.TreeType.CHERRY; // Folia - region threading
         } else if (feature.is(TreeFeatures.PALE_OAK) || feature.is(TreeFeatures.PALE_OAK_BONEMEAL)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK;
+            treeType = org.bukkit.TreeType.PALE_OAK; // Folia - region threading
         } else if (feature.is(TreeFeatures.PALE_OAK_CREAKING)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK_CREAKING;
+            treeType = org.bukkit.TreeType.PALE_OAK_CREAKING; // Folia - region threading
         } else {
             throw new IllegalArgumentException("Unknown tree generator " + feature);
         }
+        net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(treeType); // Folia - region threading
     }
     // CraftBukkit end
 }
diff --git a/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 3bbfa079a2a2da3de361352738b6101894acf82c..31907239431e83515b4e9c8b53dc1ee4d6f29e4d 100644
--- a/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -117,7 +117,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 && pistonMovingBlockEntity.isExtending()
                 && (
                     pistonMovingBlockEntity.getProgress(0.0F) < 0.5F
-                        || level.getGameTime() == pistonMovingBlockEntity.getLastTicked()
+                        || level.getRedstoneGameTime() == pistonMovingBlockEntity.getLastTicked() // Folia - region threading
                         || ((ServerLevel)level).isHandlingTick()
                 )) {
                 i = 2;
diff --git a/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 59a002711531f8337a86d85b6e8b11b5fad8ced7..adc8c8a7b8a02cf395e919eb51aefc47ff6ed9ab 100644
--- a/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -44,9 +44,19 @@ public class PistonMovingBlockEntity extends BlockEntity {
     private static final ThreadLocal<Direction> NOCLIP = ThreadLocal.withInitial(() -> null);
     private float progress = 0.0F;
     private float progressO = 0.0F;
-    private long lastTicked;
+    private long lastTicked = Long.MIN_VALUE; // Folia - region threading
     private int deathTicks;
 
+    // Folia start - region threading
+    @Override
+    public void updateTicks(long fromTickOffset, long fromRedstoneTimeOffset) {
+        super.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
+        if (this.lastTicked != Long.MIN_VALUE) {
+            this.lastTicked += fromRedstoneTimeOffset;
+        }
+    }
+    // Folia end - region threading
+
     public PistonMovingBlockEntity(BlockPos pos, BlockState blockState) {
         super(BlockEntityType.PISTON, pos, blockState);
     }
@@ -153,8 +163,8 @@ public class PistonMovingBlockEntity extends BlockEntity {
 
                                 entity.setDeltaMovement(d1, d2, d3);
                                 // Paper - EAR items stuck in slime pushed by a piston
-                                entity.activatedTick = Math.max(entity.activatedTick, net.minecraft.server.MinecraftServer.currentTick + 10);
-                                entity.activatedImmunityTick = Math.max(entity.activatedImmunityTick, net.minecraft.server.MinecraftServer.currentTick + 10);
+                                entity.activatedTick = Math.max(entity.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
+                                entity.activatedImmunityTick = Math.max(entity.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 10); // Folia - region threading
                                 // Paper end
                                 break;
                             }
@@ -302,7 +312,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     public static void tick(Level level, BlockPos pos, BlockState state, PistonMovingBlockEntity blockEntity) {
-        blockEntity.lastTicked = level.getGameTime();
+        blockEntity.lastTicked = level.getRedstoneGameTime(); // Folia - region threading
         blockEntity.progressO = blockEntity.progress;
         if (blockEntity.progressO >= 1.0F) {
             if (level.isClientSide() && blockEntity.deathTicks < 5) {
diff --git a/net/minecraft/world/level/border/WorldBorder.java b/net/minecraft/world/level/border/WorldBorder.java
index c8a46b548fb128ddca7422a3f29cfdf16d5d44e5..40e493c03c5b792810f639946dea629781dd203f 100644
--- a/net/minecraft/world/level/border/WorldBorder.java
+++ b/net/minecraft/world/level/border/WorldBorder.java
@@ -43,6 +43,8 @@ public class WorldBorder extends SavedData {
         this.settings = settings;
     }
 
+    // Folia - region threading - TODO make this shit thread-safe
+
     public boolean isWithinBounds(BlockPos pos) {
         return this.isWithinBounds(pos.getX(), pos.getZ());
     }
@@ -56,16 +58,14 @@ public class WorldBorder extends SavedData {
     }
 
     // Paper start - Bound treasure maps to world border
-    private final BlockPos.MutableBlockPos mutPos = new BlockPos.MutableBlockPos();
+    private static final ThreadLocal<BlockPos.MutableBlockPos> mutPos = ThreadLocal.withInitial(() -> new BlockPos.MutableBlockPos()); // Folia - region threading
 
     public boolean isBlockInBounds(int x, int z) {
-        this.mutPos.set(x, 64, z);
-        return this.isWithinBounds(this.mutPos);
+        return this.isWithinBounds(mutPos.get().set(x, 64, z)); // Folia - region threading
     }
 
     public boolean isChunkInBounds(int chunkX, int chunkZ) {
-        this.mutPos.set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
-        return this.isWithinBounds(this.mutPos);
+        return this.isWithinBounds(mutPos.get().set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15)); // Folia - region threading
     }
     // Paper end - Bound treasure maps to world border
 
diff --git a/net/minecraft/world/level/chunk/ChunkGenerator.java b/net/minecraft/world/level/chunk/ChunkGenerator.java
index 78600f4c583056403c93e72ec0996b00ec6d1284..f52a1a92b4bcbf9e35a07d2994d22492400bc14d 100644
--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -326,7 +326,7 @@ public abstract class ChunkGenerator {
     }
 
     private static boolean tryAddReference(StructureManager structureManager, StructureStart structureStart) {
-        if (structureStart.canBeReferenced()) {
+        if (structureStart.tryReference()) { // Folia - region threading
             structureManager.addReference(structureStart);
             return true;
         } else {
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index 7f2fa1978c2ca5620f0f3c1f26570d924d7fb3e5..b5fafd0a5d84ed3dd3f852c232a438b8b1b6869d 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -70,6 +70,13 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
         public void tick() {
         }
 
+        // Folia start - region threading
+        @Override
+        public BlockEntity getTileEntity() {
+            return null;
+        }
+        // Folia end - region threading
+
         @Override
         public boolean isRemoved() {
             return true;
@@ -239,11 +246,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
 
     @Override
     public void markUnsaved() {
-        boolean isUnsaved = this.isUnsaved();
-        super.markUnsaved();
-        if (!isUnsaved) {
-            this.unsavedListener.setUnsaved(this.chunkPos);
-        }
+        super.markUnsaved(); // Folia - region threading - unsavedListener is not really use
     }
 
     @Override
@@ -365,6 +368,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
 
     @Override
     public @Nullable BlockState setBlockState(BlockPos pos, BlockState state, @Block.UpdateFlags int flags) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, pos, "Updating block asynchronously"); // Folia - region threading
         int y = pos.getY();
         LevelChunkSection section = this.getSection(this.getSectionIndex(y));
         boolean hasOnlyAir = section.hasOnlyAir();
@@ -421,7 +425,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
                 if (!section.getBlockState(i, i1, i2).is(block)) {
                     return null;
                 } else {
-                    if (!this.level.isClientSide() && (flags & 512) == 0 && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                    if (!this.level.isClientSide() && (flags & 512) == 0 && (!this.level.getCurrentWorldData().captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled. // Folia - region threading
                         state.onPlace(this.level, pos, blockState, flag1);
                     }
 
@@ -473,7 +477,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
 
     public @Nullable BlockEntity getBlockEntity(BlockPos pos, LevelChunk.EntityCreationType creationType) {
         // CraftBukkit start
-        BlockEntity blockEntity = this.level.capturedTileEntities.get(pos);
+        BlockEntity blockEntity = this.level.getCurrentWorldData().capturedTileEntities.get(pos); // Folia - region threading
         if (blockEntity == null) {
             blockEntity = this.blockEntities.get(pos);
         }
@@ -661,13 +665,13 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
 
                 org.bukkit.World world = this.level.getWorld();
                 if (world != null) {
-                    this.level.populating = true;
+                    this.level.getCurrentWorldData().populating = true; // Folia - region threading
                     try {
                         for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
                             populator.populate(world, random, bukkitChunk);
                         }
                     } finally {
-                        this.level.populating = false;
+                        this.level.getCurrentWorldData().populating = false; // Folia - region threading
                     }
                 }
                 server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
@@ -693,7 +697,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
     @Override
     public boolean isUnsaved() {
         // Paper start - rewrite chunk system
-        final long gameTime = this.level.getGameTime();
+        final long gameTime = this.level.getRedstoneGameTime(); // Folia - region threading
         if (((ca.spottedleaf.moonrise.patches.chunk_system.ticks.ChunkSystemLevelChunkTicks)this.blockTicks).moonrise$isDirty(gameTime)
             || ((ca.spottedleaf.moonrise.patches.chunk_system.ticks.ChunkSystemLevelChunkTicks)this.fluidTicks).moonrise$isDirty(gameTime)) {
             return true;
@@ -946,6 +950,13 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
             this.ticker = ticker;
         }
 
+        // Folia start - region threading
+        @Override
+        public BlockEntity getTileEntity() {
+            return this.blockEntity;
+        }
+        // Folia end - region threading
+
         @Override
         public void tick() {
             if (!this.blockEntity.isRemoved() && this.blockEntity.hasLevel()) {
@@ -1024,6 +1035,13 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
             this.ticker = ticker;
         }
 
+        // Folia start - region threading
+        @Override
+        public BlockEntity getTileEntity() {
+            return this.ticker == null ? null : this.ticker.getTileEntity();
+        }
+        // Folia end - region threading
+
         @Override
         public void tick() {
             this.ticker.tick();
diff --git a/net/minecraft/world/level/chunk/storage/SerializableChunkData.java b/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
index 95c8d65a4b6db8d0721460ae55cb8fb8143ea9a2..a58e6801d112457ab3e44a85403f8f5d4382ba6c 100644
--- a/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
+++ b/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
@@ -525,7 +525,7 @@ public record SerializableChunkData(
                 }
             }
 
-            ChunkAccess.PackedTicks ticksForSerialization = chunk.getTicksForSerialization(level.getGameTime());
+            ChunkAccess.PackedTicks ticksForSerialization = chunk.getTicksForSerialization(level.getRedstoneGameTime()); // Folia - region threading
             ShortList[] lists = Arrays.stream(chunk.getPostProcessing())
                 .map(list3 -> list3 != null && !list3.isEmpty() ? new ShortArrayList(list3) : null)
                 .toArray(ShortList[]::new);
diff --git a/net/minecraft/world/level/dimension/end/EndDragonFight.java b/net/minecraft/world/level/dimension/end/EndDragonFight.java
index cb6e5f2ad837a0eb11ceccee297f557f4355d304..2b3f2cd92d9dbb3f05f80de198a2160bf4a6ed9a 100644
--- a/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -77,7 +77,7 @@ public class EndDragonFight {
         .setPlayBossMusic(true)
         .setCreateWorldFog(true);
     public final ServerLevel level;
-    private final BlockPos origin;
+    public final BlockPos origin; // Folia - region threading
     public final ObjectArrayList<Integer> gateways = new ObjectArrayList<>();
     private final BlockPattern exitPortalPattern;
     private int ticksSinceDragonSeen;
@@ -158,7 +158,7 @@ public class EndDragonFight {
 
         if (!this.dragonEvent.getPlayers().isEmpty()) {
             this.level.getChunkSource().addTicketWithRadius(TicketType.DRAGON, new ChunkPos(0, 0), 9);
-            boolean isArenaLoaded = this.isArenaLoaded();
+            boolean isArenaLoaded = this.isArenaLoaded(); if (!isArenaLoaded) { return; } // Folia - region threading - don't tick if we don't own the entire region
             if (this.needsStateScanning && isArenaLoaded) {
                 this.scanState();
                 this.needsStateScanning = false;
@@ -204,6 +204,12 @@ public class EndDragonFight {
         }
 
         List<? extends EnderDragon> dragons = this.level.getDragons();
+        // Folia start - region threading
+        // we do not want to deal with any dragons NOT nearby
+        dragons.removeIf((EnderDragon dragon) -> {
+            return !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(dragon);
+        });
+        // Folia end - region threading
         if (dragons.isEmpty()) {
             this.dragonKilled = true;
         } else {
@@ -318,8 +324,8 @@ public class EndDragonFight {
 
             for (int i = -8 + chunkPos.x; i <= 8 + chunkPos.x; i++) {
                 for (int i1 = 8 + chunkPos.z; i1 <= 8 + chunkPos.z; i1++) {
-                    ChunkAccess chunk = this.level.getChunk(i, i1, ChunkStatus.FULL, false);
-                    if (!(chunk instanceof LevelChunk)) {
+                    ChunkAccess chunk = this.level.getChunkIfLoaded(i, i1); // Folia - region threading
+                    if (!(chunk instanceof LevelChunk) || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level, i, i1, this.level.regioniser.regionSectionChunkSize)) {
                         return false;
                     }
 
@@ -492,6 +498,11 @@ public class EndDragonFight {
     }
 
     public void onCrystalDestroyed(EndCrystal crystal, DamageSource damageSource) {
+        // Folia start - region threading
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level, this.origin)) {
+            return;
+        }
+        // Folia end - region threading
         if (this.respawnStage != null && this.respawnCrystals.contains(crystal)) {
             LOGGER.debug("Aborting respawn sequence");
             this.respawnStage = null;
@@ -517,7 +528,7 @@ public class EndDragonFight {
 
     public boolean tryRespawn(@Nullable BlockPos placedEndCrystalPos) { // placedEndCrystalPos is null if the tryRespawn() call was not caused by a placed end crystal
         // Paper end - Perf: Do crystal-portal proximity check before entity lookup
-        if (this.dragonKilled && this.respawnStage == null) {
+        if (this.dragonKilled && this.respawnStage == null && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level, this.origin)) { // Folia - region threading
             BlockPos blockPos = this.portalLocation;
             if (blockPos == null) {
                 LOGGER.debug("Tried to respawn, but need to find the portal first.");
diff --git a/net/minecraft/world/level/levelgen/PatrolSpawner.java b/net/minecraft/world/level/levelgen/PatrolSpawner.java
index 124da784f902d9569c3ffce186bfdf6ea9161d85..a78f05bf8134799cbf9e65e49db58b91a9c4a2ed 100644
--- a/net/minecraft/world/level/levelgen/PatrolSpawner.java
+++ b/net/minecraft/world/level/levelgen/PatrolSpawner.java
@@ -14,7 +14,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gamerules.GameRules;
 
 public class PatrolSpawner implements CustomSpawner {
-    private int nextTick;
+    //private int nextTick; // Folia - region threading
 
     @Override
     public void tick(ServerLevel level, boolean spawnEnemies) {
@@ -22,14 +22,15 @@ public class PatrolSpawner implements CustomSpawner {
         if (spawnEnemies) {
             if (level.getGameRules().get(GameRules.SPAWN_PATROLS)) {
                 RandomSource randomSource = level.random;
+                io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
                 // this.nextTick--;
                 // Paper start - Pillager patrol spawn settings and per player options
-                int size = level.players().size();
+                int size = level.getLocalPlayers().size(); // Folia - region threading
                 if (size < 1) {
                     return;
                 }
 
-                net.minecraft.server.level.ServerPlayer player = level.players().get(randomSource.nextInt(size));
+                net.minecraft.server.level.ServerPlayer player = level.getLocalPlayers().get(randomSource.nextInt(size)); // Folia - region threading
                 if (player.isSpectator()) {
                     return;
                 }
@@ -39,8 +40,8 @@ public class PatrolSpawner implements CustomSpawner {
                     --player.patrolSpawnDelay;
                     patrolSpawnDelay = player.patrolSpawnDelay;
                 } else {
-                    this.nextTick--;
-                    patrolSpawnDelay = this.nextTick;
+                    worldData.patrolSpawnerNextTick--; // Folia - region threading
+                    patrolSpawnDelay = worldData.patrolSpawnerNextTick; // Folia - region threading
                 }
                 if (patrolSpawnDelay <= 0) {
                     long dayCount;
@@ -52,7 +53,7 @@ public class PatrolSpawner implements CustomSpawner {
                     if (level.paperConfig().entities.behavior.pillagerPatrols.spawnDelay.perPlayer) {
                         player.patrolSpawnDelay += level.paperConfig().entities.behavior.pillagerPatrols.spawnDelay.ticks + randomSource.nextInt(1200);
                     } else {
-                        this.nextTick += level.paperConfig().entities.behavior.pillagerPatrols.spawnDelay.ticks + randomSource.nextInt(1200);
+                        worldData.patrolSpawnerNextTick += level.paperConfig().entities.behavior.pillagerPatrols.spawnDelay.ticks + randomSource.nextInt(1200); // Folia - region threading
                     }
 
                     if (dayCount >= level.paperConfig().entities.behavior.pillagerPatrols.start.day && level.isBrightOutside()) {
diff --git a/net/minecraft/world/level/levelgen/PhantomSpawner.java b/net/minecraft/world/level/levelgen/PhantomSpawner.java
index 135e8cc1b423d5a2a96ede693a306534ea45686b..e9c40ecb2309d386a2214593181f2d4f289eb28b 100644
--- a/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -19,7 +19,7 @@ import net.minecraft.world.level.gamerules.GameRules;
 import net.minecraft.world.level.material.FluidState;
 
 public class PhantomSpawner implements CustomSpawner {
-    private int nextTick;
+    //private int nextTick; // Folia - region threading
 
     @Override
     public void tick(ServerLevel level, boolean spawnEnemies) {
@@ -31,15 +31,16 @@ public class PhantomSpawner implements CustomSpawner {
                 }
                 // Paper end - Ability to control player's insomnia and phantoms
                 RandomSource randomSource = level.random;
-                this.nextTick--;
-                if (this.nextTick <= 0) {
+                io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
+                worldData.phantomSpawnerNextTick--; // Folia - region threading
+                if (worldData.phantomSpawnerNextTick <= 0) { // Folia - region threading
                     // Paper start - Ability to control player's insomnia and phantoms
                     int spawnAttemptMinSeconds = level.paperConfig().entities.behavior.phantomsSpawnAttemptMinSeconds;
                     int spawnAttemptMaxSeconds = level.paperConfig().entities.behavior.phantomsSpawnAttemptMaxSeconds;
-                    this.nextTick += (spawnAttemptMinSeconds + randomSource.nextInt(spawnAttemptMaxSeconds - spawnAttemptMinSeconds + 1)) * 20;
+                    worldData.phantomSpawnerNextTick += (spawnAttemptMinSeconds + randomSource.nextInt(spawnAttemptMaxSeconds - spawnAttemptMinSeconds + 1)) * 20; // Folia - region threading
                     // Paper end - Ability to control player's insomnia and phantoms
                     if (level.getSkyDarken() >= 5 || !level.dimensionType().hasSkyLight()) {
-                        for (ServerPlayer serverPlayer : level.players()) {
+                        for (ServerPlayer serverPlayer : level.getLocalPlayers()) { // Folia - region threading
                             if (!serverPlayer.isSpectator() && (!level.paperConfig().entities.behavior.phantomsDoNotSpawnOnCreativePlayers || !serverPlayer.isCreative())) { // Paper - Add phantom creative and insomniac controls
                                 BlockPos blockPos = serverPlayer.blockPosition();
                                 if (!level.dimensionType().hasSkyLight() || blockPos.getY() >= level.getSeaLevel() && level.canSeeSky(blockPos)) {
diff --git a/net/minecraft/world/level/levelgen/feature/EndPlatformFeature.java b/net/minecraft/world/level/levelgen/feature/EndPlatformFeature.java
index dfe8b815987a0ee385846616e4845428a81f2782..49b810ae9d9a8d0718a5f8c512e15a5573ed04fd 100644
--- a/net/minecraft/world/level/levelgen/feature/EndPlatformFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/EndPlatformFeature.java
@@ -46,7 +46,7 @@ public class EndPlatformFeature extends Feature<NoneFeatureConfiguration> {
 
         // CraftBukkit start
         // SPIGOT-7746: Entity will only be null during world generation, which is async, so just generate without event
-        if (entity != null) {
+        if (false) { // Folia - region threading
             org.bukkit.World bworld = level.getLevel().getWorld();
             org.bukkit.event.world.PortalCreateEvent portalEvent = new org.bukkit.event.world.PortalCreateEvent((java.util.List<org.bukkit.block.BlockState>) (java.util.List) blockList.getSnapshotBlocks(), bworld, entity.getBukkitEntity(), org.bukkit.event.world.PortalCreateEvent.CreateReason.END_PLATFORM);
             level.getLevel().getCraftServer().getPluginManager().callEvent(portalEvent);
diff --git a/net/minecraft/world/level/levelgen/structure/StructureStart.java b/net/minecraft/world/level/levelgen/structure/StructureStart.java
index 063d79ec9975dd30602024c4096579ca5b2f1135..64d8d07307c3ffe372913dee1e291c56fdae6ffe 100644
--- a/net/minecraft/world/level/levelgen/structure/StructureStart.java
+++ b/net/minecraft/world/level/levelgen/structure/StructureStart.java
@@ -26,7 +26,7 @@ public final class StructureStart {
     private final Structure structure;
     private final PiecesContainer pieceContainer;
     private final ChunkPos chunkPos;
-    private int references;
+    private final java.util.concurrent.atomic.AtomicInteger references; // Folia - region threading
     private volatile @Nullable BoundingBox cachedBoundingBox;
 
     // CraftBukkit start
@@ -38,7 +38,7 @@ public final class StructureStart {
     public StructureStart(Structure structure, ChunkPos chunkPos, int references, PiecesContainer pieceContainer) {
         this.structure = structure;
         this.chunkPos = chunkPos;
-        this.references = references;
+        this.references = new java.util.concurrent.atomic.AtomicInteger(references); // Folia - region threading
         this.pieceContainer = pieceContainer;
     }
 
@@ -124,7 +124,7 @@ public final class StructureStart {
             compoundTag.putString("id", context.registryAccess().lookupOrThrow(Registries.STRUCTURE).getKey(this.structure).toString());
             compoundTag.putInt("ChunkX", chunkPos.x);
             compoundTag.putInt("ChunkZ", chunkPos.z);
-            compoundTag.putInt("references", this.references);
+            compoundTag.putInt("references", this.references.get()); // Folia - region threading
             compoundTag.put("Children", this.pieceContainer.save(context));
             return compoundTag;
         } else {
@@ -142,15 +142,29 @@ public final class StructureStart {
     }
 
     public boolean canBeReferenced() {
-        return this.references < this.getMaxReferences();
+        throw new UnsupportedOperationException("Use tryReference()"); // Folia - region threading
     }
 
+    // Folia start - region threading
+    public boolean tryReference() {
+        for (int curr = this.references.get();;) {
+            if (curr >= this.getMaxReferences()) {
+                return false;
+            }
+
+            if (curr == (curr = this.references.compareAndExchange(curr, curr + 1))) {
+                return true;
+            } // else: try again
+        }
+    }
+    // Folia end - region threading
+
     public void addReference() {
-        this.references++;
+       throw new UnsupportedOperationException("Use tryReference()"); // Folia - region threading
     }
 
     public int getReferences() {
-        return this.references;
+        return this.references.get(); // Folia - region threading
     }
 
     protected int getMaxReferences() {
diff --git a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 0a60ff97dc77108997568c75c94327cb6858018f..70b4c63b5ff80f7d26761f016ecccac760328297 100644
--- a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -53,6 +53,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     private void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates updates) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((net.minecraft.server.level.ServerLevel)this.level, pos, "Adding block without owning region"); // Folia - region threading
         boolean flag = this.count > 0;
         boolean flag1 = this.maxChainedNeighborUpdates >= 0 && this.count >= this.maxChainedNeighborUpdates;
         this.count++;
diff --git a/net/minecraft/world/level/saveddata/SavedData.java b/net/minecraft/world/level/saveddata/SavedData.java
index 042280eb84f2e6ddf9b2b42a94000844c461d48d..3dc992386a63c42723542434e1df3b1e73b0a12f 100644
--- a/net/minecraft/world/level/saveddata/SavedData.java
+++ b/net/minecraft/world/level/saveddata/SavedData.java
@@ -1,7 +1,7 @@
 package net.minecraft.world.level.saveddata;
 
 public abstract class SavedData {
-    private boolean dirty;
+    private volatile boolean dirty; // Folia - make map data thread-safe
 
     public void setDirty() {
         this.setDirty(true);
diff --git a/net/minecraft/world/level/saveddata/maps/MapIndex.java b/net/minecraft/world/level/saveddata/maps/MapIndex.java
index 06025d79cc2297119b22224d777aca79f9d3d9c1..610d16bf5a218796ffcd17789299a0b7f4d9e75d 100644
--- a/net/minecraft/world/level/saveddata/maps/MapIndex.java
+++ b/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -9,21 +9,21 @@ import net.minecraft.world.level.saveddata.SavedDataType;
 public class MapIndex extends SavedData {
     private static final int NO_MAP_ID = -1;
     public static final Codec<MapIndex> CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(Codec.INT.optionalFieldOf("map", -1).forGetter(mapIndex -> mapIndex.lastMapId)).apply(instance, MapIndex::new)
+        instance -> instance.group(Codec.INT.optionalFieldOf("map", -1).forGetter(mapIndex -> mapIndex.lastMapId.get())).apply(instance, MapIndex::new) // Folia - make map data thread-safe
     );
     public static final SavedDataType<MapIndex> TYPE = new SavedDataType<>("idcounts", MapIndex::new, CODEC, DataFixTypes.SAVED_DATA_MAP_INDEX);
-    private int lastMapId;
+    private final java.util.concurrent.atomic.AtomicInteger lastMapId = new java.util.concurrent.atomic.AtomicInteger(); // Folia - make map data thread-safe
 
     public MapIndex() {
         this(-1);
     }
 
     public MapIndex(int lastMapId) {
-        this.lastMapId = lastMapId;
+        this.lastMapId.set(lastMapId); // Folia - make map data thread-safe
     }
 
     public MapId getNextMapId() {
-        MapId mapId = new MapId(++this.lastMapId);
+        MapId mapId = new MapId(this.lastMapId.incrementAndGet()); // Folia - make map data thread-safe
         this.setDirty();
         return mapId;
     }
diff --git a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index 1af585f9554278983148096c73c86e18166f5471..99be63df22932b8f2bc2c7a5e48e88be6045e16d 100644
--- a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -178,7 +178,7 @@ public class MapItemSavedData extends SavedData {
         return new MapItemSavedData(0, 0, scale, false, false, locked, dimension);
     }
 
-    public MapItemSavedData locked() {
+    public synchronized MapItemSavedData locked() { // Folia - make map data thread-safe
         MapItemSavedData mapItemSavedData = new MapItemSavedData(
             this.centerX, this.centerZ, this.scale, this.trackingPosition, this.unlimitedTracking, true, this.dimension
         );
@@ -189,7 +189,7 @@ public class MapItemSavedData extends SavedData {
         return mapItemSavedData;
     }
 
-    public MapItemSavedData scaled() {
+    public synchronized MapItemSavedData scaled() { // Folia - make map data thread-safe
         return createFresh(this.centerX, this.centerZ, (byte)Mth.clamp(this.scale + 1, 0, 4), this.trackingPosition, this.unlimitedTracking, this.dimension);
     }
 
@@ -198,7 +198,8 @@ public class MapItemSavedData extends SavedData {
         return itemStack -> itemStack == stack || itemStack.is(stack.getItem()) && Objects.equals(mapId, itemStack.get(DataComponents.MAP_ID));
     }
 
-    public void tickCarriedBy(Player player, ItemStack mapStack) {
+    public synchronized void tickCarriedBy(Player player, ItemStack mapStack) { // Folia - make map data thread-safe
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(player, "Ticking map player in incorrect region"); // Folia - region threading
         if (!this.carriedByPlayers.containsKey(player)) {
             MapItemSavedData.HoldingPlayer holdingPlayer = new MapItemSavedData.HoldingPlayer(player);
             this.carriedByPlayers.put(player, holdingPlayer);
@@ -380,7 +381,7 @@ public class MapItemSavedData extends SavedData {
         }
     }
 
-    public @Nullable Packet<?> getUpdatePacket(MapId mapId, Player player) {
+    public synchronized @Nullable Packet<?> getUpdatePacket(MapId mapId, Player player) { // Folia - make map data thread-safe
         MapItemSavedData.HoldingPlayer holdingPlayer = this.carriedByPlayers.get(player);
         return holdingPlayer == null ? null : holdingPlayer.nextUpdatePacket(mapId);
     }
@@ -389,20 +390,21 @@ public class MapItemSavedData extends SavedData {
     // Paper start - Fix unnecessary map data saves
         this.setColorsDirty(x, z, true);
     }
-    public void setColorsDirty(int x, int z, boolean markFileDirty) {
-        if (markFileDirty) this.setDirty();
+    public synchronized void setColorsDirty(int x, int z, boolean markFileDirty) { // Folia - make map data thread-safe
+        //if (markFileDirty) this.setDirty(); // Folia - make map data thread-safe - move down
     // Paper end - Fix unnecessary map data saves
 
         for (MapItemSavedData.HoldingPlayer holdingPlayer : this.carriedBy) {
             holdingPlayer.markColorsDirty(x, z);
         }
+        if (markFileDirty) this.setDirty(); // Folia - make map data thread-safe - moved down
     }
 
-    public void setDecorationsDirty() {
+    public synchronized void setDecorationsDirty() { // Folia - make map data thread-safe
         this.carriedBy.forEach(MapItemSavedData.HoldingPlayer::markDecorationsDirty);
     }
 
-    public MapItemSavedData.HoldingPlayer getHoldingPlayer(Player player) {
+    public synchronized MapItemSavedData.HoldingPlayer getHoldingPlayer(Player player) { // Folia - make map data thread-safe
         MapItemSavedData.HoldingPlayer holdingPlayer = this.carriedByPlayers.get(player);
         if (holdingPlayer == null) {
             holdingPlayer = new MapItemSavedData.HoldingPlayer(player);
@@ -413,7 +415,7 @@ public class MapItemSavedData extends SavedData {
         return holdingPlayer;
     }
 
-    public boolean toggleBanner(LevelAccessor level, BlockPos pos) {
+    public synchronized boolean toggleBanner(LevelAccessor level, BlockPos pos) { // Folia - make map data thread-safe
         double d = pos.getX() + 0.5;
         double d1 = pos.getZ() + 0.5;
         int i = 1 << this.scale;
@@ -421,7 +423,7 @@ public class MapItemSavedData extends SavedData {
         double d3 = (d1 - this.centerZ) / i;
         int i1 = 63;
         if (d2 >= -63.0 && d3 >= -63.0 && d2 <= 63.0 && d3 <= 63.0) {
-            MapBanner mapBanner = MapBanner.fromWorld(level, pos);
+            MapBanner mapBanner = level.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4) == null || !ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(level.getMinecraftWorld(), pos) ? null : MapBanner.fromWorld(level, pos); // Folia - make map data thread-safe - don't sync load or read data we do not own
             if (mapBanner == null) {
                 return false;
             }
@@ -443,7 +445,7 @@ public class MapItemSavedData extends SavedData {
         return false;
     }
 
-    public void checkBanners(BlockGetter level, int x, int z) {
+    public synchronized void checkBanners(BlockGetter level, int x, int z) { // Folia - make map data thread-safe
         Iterator<MapBanner> iterator = this.bannerMarkers.values().iterator();
 
         while (iterator.hasNext()) {
@@ -463,13 +465,13 @@ public class MapItemSavedData extends SavedData {
         return this.bannerMarkers.values();
     }
 
-    public void removedFromFrame(BlockPos pos, int entityId) {
+    public synchronized void removedFromFrame(BlockPos pos, int entityId) { // Folia - make map data thread-safe
         this.removeDecoration(getFrameKey(entityId));
         this.frameMarkers.remove(MapFrame.frameId(pos));
         this.setDirty();
     }
 
-    public boolean updateColor(int x, int z, byte color) {
+    public synchronized boolean updateColor(int x, int z, byte color) { // Folia - make map data thread-safe
         byte b = this.colors[x + z * 128];
         if (b != color) {
             this.setColor(x, z, color);
@@ -479,12 +481,12 @@ public class MapItemSavedData extends SavedData {
         }
     }
 
-    public void setColor(int x, int z, byte color) {
+    public synchronized void setColor(int x, int z, byte color) { // Folia - make map data thread-safe
         this.colors[x + z * 128] = color;
         this.setColorsDirty(x, z);
     }
 
-    public boolean isExplorationMap() {
+    public synchronized boolean isExplorationMap() { // Folia - make map data thread-safe
         for (MapDecoration mapDecoration : this.decorations.values()) {
             if (mapDecoration.type().value().explorationMapElement()) {
                 return true;
@@ -494,7 +496,7 @@ public class MapItemSavedData extends SavedData {
         return false;
     }
 
-    public void addClientSideDecorations(List<MapDecoration> decorations) {
+    public synchronized void addClientSideDecorations(List<MapDecoration> decorations) { // Folia - make map data thread-safe
         this.decorations.clear();
         this.trackedDecorationCount = 0;
 
@@ -511,7 +513,7 @@ public class MapItemSavedData extends SavedData {
         return this.decorations.values();
     }
 
-    public boolean isTrackedCountOverLimit(int trackedCount) {
+    public synchronized boolean isTrackedCountOverLimit(int trackedCount) { // Folia - make map data thread-safe
         return this.trackedDecorationCount >= trackedCount;
     }
 
@@ -665,11 +667,13 @@ public class MapItemSavedData extends SavedData {
         }
 
         public void applyToMap(MapItemSavedData savedData) {
+            synchronized (savedData) { // Folia - make map data thread-safe
             for (int i = 0; i < this.width; i++) {
                 for (int i1 = 0; i1 < this.height; i1++) {
                     savedData.setColor(this.startX + i, this.startY + i1, this.mapColors[i + i1 * this.width]);
                 }
             }
+            } // Folia - make map data thread-safe
         }
     }
 
diff --git a/net/minecraft/world/level/storage/DimensionDataStorage.java b/net/minecraft/world/level/storage/DimensionDataStorage.java
index b932e6236975fd4a755bdbf4b7a958599383f3f8..a1449d9b7a45c0119bbd268db3e82035cefbb166 100644
--- a/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -55,6 +55,7 @@ public class DimensionDataStorage implements AutoCloseable {
     }
 
     public <T extends SavedData> T computeIfAbsent(SavedDataType<T> type) {
+        synchronized (this.cache) { // Folia - make map data thread-safe
         T savedData = this.get(type);
         if (savedData != null) {
             return savedData;
@@ -63,9 +64,11 @@ public class DimensionDataStorage implements AutoCloseable {
             this.set(type, savedData1);
             return savedData1;
         }
+        } // Folia - make map data thread-safe
     }
 
     public <T extends SavedData> @Nullable T get(SavedDataType<T> type) {
+        synchronized (this.cache) { // Folia - make map data thread-safe
         Optional<SavedData> optional = this.cache.get(type);
         if (optional == null) {
             optional = Optional.ofNullable(this.readSavedData(type));
@@ -73,6 +76,7 @@ public class DimensionDataStorage implements AutoCloseable {
         }
 
         return (T)optional.orElse(null);
+        } // Folia - make map data thread-safe
     }
 
     private <T extends SavedData> @Nullable T readSavedData(SavedDataType<T> type) {
@@ -94,8 +98,10 @@ public class DimensionDataStorage implements AutoCloseable {
     }
 
     public <T extends SavedData> void set(SavedDataType<T> type, T value) {
+        synchronized (this.cache) { // Folia - make map data thread-safe
         this.cache.put(type, Optional.of(value));
         value.setDirty();
+        } // Folia - make map data thread-safe
     }
 
     public CompoundTag readTagFromDisk(String filename, DataFixTypes dataFixType, int version) throws IOException {
@@ -189,7 +195,9 @@ public class DimensionDataStorage implements AutoCloseable {
     private <T extends SavedData> CompoundTag encodeUnchecked(SavedDataType<T> type, SavedData data, RegistryOps<Tag> ops) {
         Codec<T> codec = type.codec();
         CompoundTag compoundTag = new CompoundTag();
+        synchronized(data) { // Folia - make map data thread-safe
         compoundTag.put("data", codec.encodeStart(ops, (T)data).getOrThrow());
+        } // Folia - make map data thread-safe
         NbtUtils.addCurrentDataVersion(compoundTag);
         return compoundTag;
     }
diff --git a/net/minecraft/world/ticks/LevelChunkTicks.java b/net/minecraft/world/ticks/LevelChunkTicks.java
index 0b13971259f58876b778c0d28ad20c3510ed46ad..ced6c0e7d1d79a27e81fc6f1034251a44d4da20a 100644
--- a/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -42,6 +42,21 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
         this.dirty = false;
     }
     // Paper end - rewrite chunk system
+    // Folia start - region threading
+    public void offsetTicks(final long offset) {
+        if (offset == 0 || this.tickQueue.isEmpty()) {
+            return;
+        }
+        final ScheduledTick<T>[] queue = this.tickQueue.toArray(new ScheduledTick[0]);
+        this.tickQueue.clear();
+        for (final ScheduledTick<T> entry : queue) {
+            final ScheduledTick<T> newEntry = new ScheduledTick<>(
+                entry.type(), entry.pos(), entry.triggerTick() + offset, entry.subTickOrder()
+            );
+            this.tickQueue.add(newEntry);
+        }
+    }
+    // Folia end - region threading
 
     public LevelChunkTicks() {
     }
diff --git a/net/minecraft/world/ticks/LevelTicks.java b/net/minecraft/world/ticks/LevelTicks.java
index b932f32d08ad663cd05910140c861045a9b1f922..3be480aff4a95f75d0deedeada5bcd9ba18a5f3b 100644
--- a/net/minecraft/world/ticks/LevelTicks.java
+++ b/net/minecraft/world/ticks/LevelTicks.java
@@ -39,12 +39,69 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (levelChunkTicks, scheduledTick) -> {
-        if (scheduledTick.equals(levelChunkTicks.peek())) {
-            this.updateContainerScheduling(scheduledTick);
+        if (scheduledTick.equals(levelChunkTicks.peek())) { // Folia - diff on change
+            this.updateContainerScheduling(scheduledTick); // Folia - diff on change
         }
     };
 
-    public LevelTicks(LongPredicate tickCheck) {
+    // Folia start - region threading
+    public final net.minecraft.server.level.ServerLevel world;
+    public final boolean isBlock;
+
+    public void merge(final LevelTicks<T> into, final long tickOffset) {
+        // note: containersToTick, toRunThisTick, alreadyRunThisTick, toRunThisTickSet
+        // are all transient state, only ever non-empty during tick. But merging regions occurs while there
+        // is no tick happening, so we assume they are empty.
+        for (final java.util.Iterator<Long2ObjectMap.Entry<LevelChunkTicks<T>>> iterator =
+             ((Long2ObjectOpenHashMap<LevelChunkTicks<T>>)this.allContainers).long2ObjectEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2ObjectMap.Entry<LevelChunkTicks<T>> entry = iterator.next();
+            final LevelChunkTicks<T> tickContainer = entry.getValue();
+            tickContainer.offsetTicks(tickOffset);
+            into.allContainers.put(entry.getLongKey(), tickContainer);
+        }
+        for (final java.util.Iterator<Long2LongMap.Entry> iterator = ((Long2LongOpenHashMap)this.nextTickForContainer).long2LongEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2LongMap.Entry entry = iterator.next();
+            into.nextTickForContainer.put(entry.getLongKey(), entry.getLongValue() + tickOffset);
+        }
+    }
+
+    public void split(final int chunkToRegionShift,
+                      final it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap<LevelTicks<T>> regionToData) {
+        for (final java.util.Iterator<Long2ObjectMap.Entry<LevelChunkTicks<T>>> iterator =
+             ((Long2ObjectOpenHashMap<LevelChunkTicks<T>>)this.allContainers).long2ObjectEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2ObjectMap.Entry<LevelChunkTicks<T>> entry = iterator.next();
+
+            final long chunkKey = entry.getLongKey();
+            final int chunkX = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkKey);
+            final int chunkZ = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkKey);
+
+            final long regionSectionKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(
+                    chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift
+            );
+            // Should always be non-null, since containers are removed on unload.
+            regionToData.get(regionSectionKey).allContainers.put(chunkKey, entry.getValue());
+        }
+        for (final java.util.Iterator<Long2LongMap.Entry> iterator = ((Long2LongOpenHashMap)this.nextTickForContainer).long2LongEntrySet().fastIterator();
+             iterator.hasNext();) {
+            final Long2LongMap.Entry entry = iterator.next();
+            final long chunkKey = entry.getLongKey();
+            final int chunkX = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkKey);
+            final int chunkZ = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkKey);
+
+            final long regionSectionKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(
+                    chunkX >> chunkToRegionShift, chunkZ >> chunkToRegionShift
+            );
+
+            // Should always be non-null, since containers are removed on unload.
+            regionToData.get(regionSectionKey).nextTickForContainer.put(chunkKey, entry.getLongValue());
+        }
+    }
+    // Folia end - region threading
+
+    public LevelTicks(LongPredicate tickCheck, net.minecraft.server.level.ServerLevel world, boolean isBlock) { this.world = world; this.isBlock = isBlock; // Folia - add world and isBlock
         this.tickCheck = tickCheck;
     }
 
@@ -56,7 +113,17 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
             this.nextTickForContainer.put(packedChunkPos, scheduledTick.triggerTick());
         }
 
-        chunkTicks.setOnTickAdded(this.chunkScheduleUpdater);
+        // Folia start - region threading
+        final boolean isBlock = this.isBlock;
+        final net.minecraft.server.level.ServerLevel world = this.world;
+        // make sure the lambda contains no reference to this LevelTicks
+        chunkTicks.setOnTickAdded((LevelChunkTicks<T> levelChunkTicks, ScheduledTick<T> tick) -> {
+            if (tick.equals(levelChunkTicks.peek())) {
+                io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData();
+                ((LevelTicks<T>)(isBlock ? worldData.getBlockLevelTicks() : worldData.getFluidLevelTicks())).updateContainerScheduling(tick);
+            }
+        });
+        // Folia end - region threading
     }
 
     public void removeContainer(ChunkPos chunkPos) {
@@ -70,6 +137,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
 
     @Override
     public void schedule(ScheduledTick<T> tick) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, tick.pos(), "Cannot schedule tick for another region!"); // Folia - region threading
         long packedChunkPos = ChunkPos.asLong(tick.pos());
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(packedChunkPos);
         if (levelChunkTicks == null) {
